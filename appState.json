{"EDITOR_STATE_NAME":{"allProjectFiles":{"4c694dd6-8dfe-4e5f-bdde-ea6e84f0e65a":{"id":"4c694dd6-8dfe-4e5f-bdde-ea6e84f0e65a","parent":null,"name":"PJ","type":"DIRECTORY","isDirectory":true,"children":["4705ce0d-bce9-4245-80d4-3ffc7f0621e6"],"isRemovable":false,"filePath":"PJ","resources":{}},"4705ce0d-bce9-4245-80d4-3ffc7f0621e6":{"id":"4705ce0d-bce9-4245-80d4-3ffc7f0621e6","parent":"4c694dd6-8dfe-4e5f-bdde-ea6e84f0e65a","name":"PJ-lambda.js","type":"LAMBDA_FILE","isDirectory":false,"children":[],"isRemovable":true,"filePath":"PJ/PJ-lambda.js","resources":{"ddb-test_table":{"name":"ddb-test_table","type":"DynamoDB","config":{"mode":1,"operation":"put","table":{"arn":"arn:aws:dynamodb:us-east-1:480964559519:table/test_table","name":"test_table","partitionKey":"id","partitionKeyType":"S","hasSortKey":false,"sortKey":"","sortKeyType":"S"},"parameters":{"Key":{},"Item":{"HI":"OKAY"}}}},"apig-iamapi-ruwan-listrole":{"name":"apig-iamapi-ruwan-listrole","type":"API_GATEWAY","config":{"apiMode":1,"apiName":"iamapi-ruwan","apiId":"cdqo4fbd05","endpointType":"EDGE","resourceMode":1,"resourcePath":"/listrole","resourceName":"listrole","resourceId":"ptww7c","restMethod":"GET"}}},"code":"const ddb = AWS.DynamoDB.DocumentClient();\nfunction handle(event, context, callback) {\n\n\n    ddb.put({\n        TableName: 'test_table',\n        Item: { HI: 'OKAY_XYZ' }\n    }, function (err, data) {\n        if (err) {\n            //handle error\n        } else {\n            //your logic goes here\n        }\n    });\n\n\n\n}","ast":{"type":"File","start":0,"end":319,"loc":{"start":{"line":1,"column":0},"end":{"line":18,"column":1}},"program":{"type":"Program","start":0,"end":319,"loc":{"start":{"line":1,"column":0},"end":{"line":18,"column":1}},"sourceType":"module","body":[{"type":"VariableDeclaration","start":0,"end":42,"loc":{"start":{"line":1,"column":0},"end":{"line":1,"column":42}},"declarations":[{"type":"VariableDeclarator","start":6,"end":41,"loc":{"start":{"line":1,"column":6},"end":{"line":1,"column":41}},"id":{"type":"Identifier","start":6,"end":9,"loc":{"start":{"line":1,"column":6},"end":{"line":1,"column":9},"identifierName":"ddb"},"name":"ddb"},"init":{"type":"CallExpression","start":12,"end":41,"loc":{"start":{"line":1,"column":12},"end":{"line":1,"column":41}},"callee":{"type":"MemberExpression","start":12,"end":39,"loc":{"start":{"line":1,"column":12},"end":{"line":1,"column":39}},"object":{"type":"MemberExpression","start":12,"end":24,"loc":{"start":{"line":1,"column":12},"end":{"line":1,"column":24}},"object":{"type":"Identifier","start":12,"end":15,"loc":{"start":{"line":1,"column":12},"end":{"line":1,"column":15},"identifierName":"AWS"},"name":"AWS"},"property":{"type":"Identifier","start":16,"end":24,"loc":{"start":{"line":1,"column":16},"end":{"line":1,"column":24},"identifierName":"DynamoDB"},"name":"DynamoDB"},"computed":false},"property":{"type":"Identifier","start":25,"end":39,"loc":{"start":{"line":1,"column":25},"end":{"line":1,"column":39},"identifierName":"DocumentClient"},"name":"DocumentClient"},"computed":false},"arguments":[]}}],"kind":"const"},{"type":"FunctionDeclaration","start":43,"end":319,"loc":{"start":{"line":2,"column":0},"end":{"line":18,"column":1}},"id":{"type":"Identifier","start":52,"end":58,"loc":{"start":{"line":2,"column":9},"end":{"line":2,"column":15},"identifierName":"handle"},"name":"handle"},"generator":false,"async":false,"params":[{"type":"Identifier","start":59,"end":64,"loc":{"start":{"line":2,"column":16},"end":{"line":2,"column":21},"identifierName":"event"},"name":"event"},{"type":"Identifier","start":66,"end":73,"loc":{"start":{"line":2,"column":23},"end":{"line":2,"column":30},"identifierName":"context"},"name":"context"},{"type":"Identifier","start":75,"end":83,"loc":{"start":{"line":2,"column":32},"end":{"line":2,"column":40},"identifierName":"callback"},"name":"callback"}],"body":{"type":"BlockStatement","start":85,"end":319,"loc":{"start":{"line":2,"column":42},"end":{"line":18,"column":1}},"body":[{"type":"ExpressionStatement","start":93,"end":314,"loc":{"start":{"line":5,"column":4},"end":{"line":14,"column":7}},"expression":{"type":"CallExpression","start":93,"end":313,"loc":{"start":{"line":5,"column":4},"end":{"line":14,"column":6}},"callee":{"type":"MemberExpression","start":93,"end":100,"loc":{"start":{"line":5,"column":4},"end":{"line":5,"column":11}},"object":{"type":"Identifier","start":93,"end":96,"loc":{"start":{"line":5,"column":4},"end":{"line":5,"column":7},"identifierName":"ddb"},"name":"ddb"},"property":{"type":"Identifier","start":97,"end":100,"loc":{"start":{"line":5,"column":8},"end":{"line":5,"column":11},"identifierName":"put"},"name":"put"},"computed":false},"arguments":[{"type":"ObjectExpression","start":101,"end":174,"loc":{"start":{"line":5,"column":12},"end":{"line":8,"column":5}},"properties":[{"type":"ObjectProperty","start":111,"end":134,"loc":{"start":{"line":6,"column":8},"end":{"line":6,"column":31}},"method":false,"key":{"type":"Identifier","start":111,"end":120,"loc":{"start":{"line":6,"column":8},"end":{"line":6,"column":17},"identifierName":"TableName"},"name":"TableName"},"computed":false,"shorthand":false,"value":{"type":"StringLiteral","start":122,"end":134,"loc":{"start":{"line":6,"column":19},"end":{"line":6,"column":31}},"extra":{"rawValue":"test_table","raw":"'test_table'"},"value":"test_table"}},{"type":"ObjectProperty","start":144,"end":168,"loc":{"start":{"line":7,"column":8},"end":{"line":7,"column":32}},"method":false,"key":{"type":"Identifier","start":144,"end":148,"loc":{"start":{"line":7,"column":8},"end":{"line":7,"column":12},"identifierName":"Item"},"name":"Item"},"computed":false,"shorthand":false,"value":{"type":"ObjectExpression","start":150,"end":168,"loc":{"start":{"line":7,"column":14},"end":{"line":7,"column":32}},"properties":[{"type":"ObjectProperty","start":152,"end":166,"loc":{"start":{"line":7,"column":16},"end":{"line":7,"column":30}},"method":false,"key":{"type":"Identifier","start":152,"end":154,"loc":{"start":{"line":7,"column":16},"end":{"line":7,"column":18},"identifierName":"HI"},"name":"HI"},"computed":false,"shorthand":false,"value":{"type":"StringLiteral","start":156,"end":166,"loc":{"start":{"line":7,"column":20},"end":{"line":7,"column":30}},"extra":{"rawValue":"OKAY_XYZ","raw":"'OKAY_XYZ'"},"value":"OKAY_XYZ"}}]}}]},{"type":"FunctionExpression","start":176,"end":312,"loc":{"start":{"line":8,"column":7},"end":{"line":14,"column":5}},"id":null,"generator":false,"async":false,"params":[{"type":"Identifier","start":186,"end":189,"loc":{"start":{"line":8,"column":17},"end":{"line":8,"column":20},"identifierName":"err"},"name":"err"},{"type":"Identifier","start":191,"end":195,"loc":{"start":{"line":8,"column":22},"end":{"line":8,"column":26},"identifierName":"data"},"name":"data"}],"body":{"type":"BlockStatement","start":197,"end":312,"loc":{"start":{"line":8,"column":28},"end":{"line":14,"column":5}},"body":[{"type":"IfStatement","start":207,"end":306,"loc":{"start":{"line":9,"column":8},"end":{"line":13,"column":9}},"test":{"type":"Identifier","start":211,"end":214,"loc":{"start":{"line":9,"column":12},"end":{"line":9,"column":15},"identifierName":"err"},"name":"err"},"consequent":{"type":"BlockStatement","start":216,"end":254,"loc":{"start":{"line":9,"column":17},"end":{"line":11,"column":9}},"body":[],"directives":[],"leadingComments":null,"innerComments":[{"type":"CommentLine","value":"handle error","start":230,"end":244,"loc":{"start":{"line":10,"column":12},"end":{"line":10,"column":26}}}]},"alternate":{"type":"BlockStatement","start":260,"end":306,"loc":{"start":{"line":11,"column":15},"end":{"line":13,"column":9}},"body":[],"directives":[],"leadingComments":[{"type":"CommentLine","value":"handle error","start":230,"end":244,"loc":{"start":{"line":10,"column":12},"end":{"line":10,"column":26}}}],"innerComments":[{"type":"CommentLine","value":"your logic goes here","start":274,"end":296,"loc":{"start":{"line":12,"column":12},"end":{"line":12,"column":34}}}]}}],"directives":[]},"trailingComments":[{"type":"CommentLine","value":"handle error","start":230,"end":244,"loc":{"start":{"line":10,"column":12},"end":{"line":10,"column":26}}},{"type":"CommentLine","value":"your logic goes here","start":274,"end":296,"loc":{"start":{"line":12,"column":12},"end":{"line":12,"column":34}}}]}]}}],"directives":[]}}],"directives":[]},"comments":[{"type":"CommentLine","value":"handle error","start":230,"end":244,"loc":{"start":{"line":10,"column":12},"end":{"line":10,"column":26}}},{"type":"CommentLine","value":"your logic goes here","start":274,"end":296,"loc":{"start":{"line":12,"column":12},"end":{"line":12,"column":34}}}]},"formatted":true,"triggers":["apig-iamapi-ruwan-listrole"]}},"rootNode":"4c694dd6-8dfe-4e5f-bdde-ea6e84f0e65a","openFiles":["4705ce0d-bce9-4245-80d4-3ffc7f0621e6"],"currentFileId":"4705ce0d-bce9-4245-80d4-3ffc7f0621e6","resources":{},"packageJSON":{"dependencies":{"lodash":{"name":"lodash","concatenatedName":"lodash","downloadsLast30Days":41838589,"downloadsRatio":0.3282378440873623,"humanDownloadsLast30Days":"41.8m","popular":true,"version":"4.17.4","versions":{"0.1.0":"2012-04-23T16:37:12.603Z","0.2.0":"2012-05-22T04:06:24.044Z","0.2.1":"2012-05-24T21:53:08.449Z","0.2.2":"2012-05-30T07:56:26.644Z","0.3.0":"2012-06-06T20:01:49.669Z","0.3.1":"2012-06-11T04:12:51.792Z","0.3.2":"2012-06-14T19:19:49.846Z","0.4.0":"2012-07-11T17:14:20.142Z","0.4.1":"2012-07-12T04:56:31.883Z","0.4.2":"2012-07-16T18:49:41.162Z","0.5.0-rc.1":"2012-08-07T15:08:27.331Z","0.5.0":"2012-08-17T20:13:07.054Z","0.5.1":"2012-08-18T20:15:42.131Z","0.5.2":"2012-08-22T16:22:03.757Z","0.6.0":"2012-08-28T16:01:09.459Z","0.6.1":"2012-08-30T08:01:38.808Z","0.7.0":"2012-09-11T16:24:07.425Z","0.8.0":"2012-10-02T06:49:38.116Z","0.8.1":"2012-10-04T08:53:29.540Z","0.8.2":"2012-10-10T07:51:31.600Z","0.9.0":"2013-08-31T04:46:20.474Z","0.9.1":"2013-08-31T04:49:15.754Z","0.9.2":"2013-08-31T04:52:21.307Z","0.10.0":"2013-08-31T04:56:09.871Z","1.0.0-rc.1":"2013-08-31T05:00:28.060Z","1.0.0-rc.2":"2013-08-31T05:05:31.147Z","1.0.0-rc.3":"2013-08-31T05:08:51.705Z","1.0.0":"2013-08-31T05:11:42.645Z","1.0.1":"2013-08-31T05:16:47.715Z","1.1.0":"2013-09-04T14:23:45.728Z","1.1.1":"2013-09-04T14:24:07.907Z","1.2.0":"2013-09-04T14:24:34.140Z","1.2.1":"2013-09-04T14:24:58.381Z","1.3.0":"2013-09-04T14:25:19.793Z","1.3.1":"2013-09-04T14:25:40.429Z","2.0.0":"2013-09-14T04:22:28.159Z","2.1.0":"2013-09-23T05:57:42.595Z","2.2.0":"2013-09-29T21:52:47.266Z","2.2.1":"2013-10-03T18:29:30.163Z","2.3.0":"2013-11-11T17:30:27.058Z","2.4.0":"2013-11-26T19:40:30.164Z","2.4.1":"2013-12-03T16:51:12.879Z","3.0.0":"2015-01-26T15:09:31.198Z","3.0.1":"2015-01-30T09:33:51.621Z","3.1.0":"2015-02-03T16:53:35.795Z","3.2.0":"2015-02-12T17:01:18.403Z","3.3.0":"2015-02-20T17:08:28.864Z","3.3.1":"2015-02-24T16:02:47.458Z","3.4.0":"2015-03-06T16:44:06.018Z","3.5.0":"2015-03-09T05:01:51.264Z","3.6.0":"2015-03-25T15:36:29.983Z","1.0.2":"2015-03-30T15:58:01.337Z","3.7.0":"2015-04-16T15:47:35.770Z","2.4.2":"2015-04-26T21:04:49.443Z","3.8.0":"2015-05-01T15:45:44.760Z","3.9.0":"2015-05-19T18:26:55.450Z","3.9.1":"2015-05-19T21:00:20.625Z","3.9.2":"2015-05-24T20:57:57.973Z","3.9.3":"2015-05-26T01:47:44.058Z","3.10.0":"2015-06-30T15:13:28.602Z","3.10.1":"2015-08-04T06:05:06.887Z","4.0.0":"2016-01-12T23:13:20.539Z","4.0.1":"2016-01-25T16:06:17.924Z","4.1.0":"2016-01-29T16:33:24.543Z","4.2.0":"2016-02-02T08:50:17.287Z","4.2.1":"2016-02-03T16:00:16.046Z","4.3.0":"2016-02-08T08:57:19.880Z","4.4.0":"2016-02-16T07:10:16.856Z","4.5.0":"2016-02-17T08:39:42.533Z","4.5.1":"2016-02-22T06:42:24.244Z","4.6.0":"2016-03-02T03:24:37.179Z","4.6.1":"2016-03-02T18:09:40.696Z","4.7.0":"2016-03-31T15:46:33.373Z","4.8.0":"2016-04-04T14:54:33.612Z","4.8.1":"2016-04-04T15:43:49.109Z","4.8.2":"2016-04-05T02:15:16.661Z","4.9.0":"2016-04-08T15:22:34.228Z","4.10.0":"2016-04-11T14:43:56.586Z","4.11.0":"2016-04-13T15:32:30.507Z","4.11.1":"2016-04-14T07:21:23.548Z","4.11.2":"2016-05-02T15:01:02.189Z","4.12.0":"2016-05-08T19:25:43.826Z","4.13.0":"2016-05-23T05:07:23.403Z","4.13.1":"2016-05-23T15:59:05.944Z","4.14.0":"2016-07-24T18:40:58.495Z","4.14.1":"2016-07-29T14:49:10.278Z","4.14.2":"2016-08-08T15:35:49.019Z","4.15.0":"2016-08-12T14:39:28.783Z","4.16.0":"2016-09-19T14:59:14.886Z","4.16.1":"2016-09-20T16:59:53.967Z","4.16.2":"2016-09-26T03:11:05.302Z","4.16.3":"2016-10-03T16:43:31.571Z","4.16.4":"2016-10-06T15:13:30.196Z","4.16.5":"2016-10-31T06:49:14.797Z","4.16.6":"2016-11-01T06:38:07.989Z","4.17.0":"2016-11-14T07:00:08.291Z","4.17.1":"2016-11-15T07:03:25.950Z","4.17.2":"2016-11-16T07:21:41.106Z","4.17.3":"2016-12-24T14:25:39.754Z","4.17.4":"2016-12-31T22:33:56.623Z"},"tags":{"latest":"4.17.4"},"description":"Lodash modular utilities.","dependencies":{},"devDependencies":{},"githubRepo":{"user":"lodash","project":"lodash","path":"","head":"master"},"gitHead":"master","readme":"# lodash v4.17.4\n\nThe [Lodash](https://lodash.com/) library exported as [Node.js](https://nodejs.org/) modules.\n\n## Installation\n\nUsing npm:\n```shell\n$ npm i -g npm\n$ npm i --save lodash\n```\n\nIn Node.js:\n```js\n// Load the full build.\nvar _ = require('lodash');\n// Load the core build.\nvar _ = require('lodash/core');\n// Load the FP build for immutable auto-curried iteratee-first data-last methods.\nvar fp = require('lodash/fp');\n\n// Load method categories.\nvar array = require('lodash/array');\nvar object = require('lodash/fp/object');\n\n// Cherry-pick methods for smaller browserify/rollup/webpack bundles.\nvar at = require('lodash/at');\nvar curryN = require('lodash/fp/curryN');\n```\n\nSee the [package source](https://github.com/lodash/lodash/tree/4.17.4-npm) for more details.\n\n**Note:**<br>\nInstall [n_](https://www.npmjs.com/package/n_) for Lodash use in the Node.js < 6 REPL.\n\n## Support\n\nTested in Chrome 54-55, Firefox 49-50, IE 11, Edge 14, Safari 9-10, Node.js 6-7, & PhantomJS 2.1.1.<br>\nAutomated [browser](https://saucelabs.com/u/lodash) & [CI](https://travis-ci.org/lodash/lodash/) test runs are available.\n","owner":{"name":"lodash","avatar":"https://github.com/lodash.png","link":"https://github.com/lodash"},"deprecated":false,"badPackage":false,"homepage":"https://lodash.com/","license":"MIT","keywords":["modules","stdlib","util"],"created":1335199031912,"modified":1514940573778,"lastPublisher":{"name":"jdalton","email":"john.david.dalton@gmail.com","avatar":"https://gravatar.com/avatar/299a3d891ff1920b69c364d061007043","link":"https://www.npmjs.com/~jdalton"},"owners":[{"email":"mathias@qiwi.be","name":"mathias","avatar":"https://gravatar.com/avatar/24e08a9ea84deb17ae121074d0f17125","link":"https://www.npmjs.com/~mathias"},{"email":"john.david.dalton@gmail.com","name":"jdalton","avatar":"https://gravatar.com/avatar/299a3d891ff1920b69c364d061007043","link":"https://www.npmjs.com/~jdalton"}],"lastCrawl":"2018-01-03T00:49:34.902Z","popularName":"lodash","dependents":1672148,"humanDependents":"1.7m","changelogFilename":"https://raw.githubusercontent.com/lodash/lodash/master/CHANGELOG","objectID":"lodash","_highlightResult":{"name":{"value":"<em>lodash</em>","matchLevel":"full","fullyHighlighted":true,"matchedWords":["lodash"]},"concatenatedName":{"value":"<em>lodash</em>","matchLevel":"full","fullyHighlighted":true,"matchedWords":["lodash"]},"description":{"value":"<em>Lodash</em> modular utilities.","matchLevel":"full","fullyHighlighted":false,"matchedWords":["lodash"]},"owner":{"name":{"value":"<em>lodash</em>","matchLevel":"full","fullyHighlighted":true,"matchedWords":["lodash"]}},"keywords":[{"value":"modules","matchLevel":"none","matchedWords":[]},{"value":"stdlib","matchLevel":"none","matchedWords":[]},{"value":"util","matchLevel":"none","matchedWords":[]}],"owners":[{"name":{"value":"mathias","matchLevel":"none","matchedWords":[]}},{"name":{"value":"jdalton","matchLevel":"none","matchedWords":[]}}],"popularName":{"value":"<em>lodash</em>","matchLevel":"full","fullyHighlighted":true,"matchedWords":["lodash"]}},"types":"// Type definitions for Lo-Dash 4.14\n// Project: http://lodash.com/\n// Definitions by: Brian Zengel <https://github.com/bczengel>,\n//                 Ilya Mochalov <https://github.com/chrootsu>,\n//                 Stepan Mikhaylyuk <https://github.com/stepancar>,\n//                 Eric L Anderson <https://github.com/ericanderson>,\n//                 AJ Richardson <https://github.com/aj-r>,\n//                 Junyoung Clare Jang <https://github.com/ailrun>,\n//                 e-cloud <https://github.com/e-cloud>,\n//                 Georgii Dolzhykov <https://github.com/thorn0>,\n//                 Jack Moore <https://github.com/jtmthf>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.2\n\n/**\n### 4.0.0 Changelog (https://github.com/lodash/lodash/wiki/Changelog)\n\n#### TODO:\nremoved:\n- [x] Removed _.support\n- [x] Removed _.findWhere in favor of _.find with iteratee shorthand\n- [x] Removed _.where in favor of _.filter with iteratee shorthand\n- [x] Removed _.pluck in favor of _.map with iteratee shorthand\n\nrenamed:\n- [x] Renamed _.first to _.head\n- [x] Renamed _.indexBy to _.keyBy\n- [x] Renamed _.invoke to _.invokeMap\n- [x] Renamed _.overArgs to _.overArgs\n- [x] Renamed _.padLeft & _.padRight to _.padStart & _.padEnd\n- [x] Renamed _.pairs to _.toPairs\n- [x] Renamed _.rest to _.tail\n- [x] Renamed _.restParam to _.rest\n- [x] Renamed _.sortByOrder to _.orderBy\n- [x] Renamed _.trimLeft & _.trimRight to _.trimStart & _.trimEnd\n- [x] Renamed _.trunc to _.truncate\n\nsplit:\n- [x] Split _.indexOf & _.lastIndexOf into _.sortedIndexOf & _.sortedLastIndexOf\n- [x] Split _.max & _.min into _.maxBy & _.minBy\n- [x] Split _.omit & _.pick into _.omitBy & _.pickBy\n- [x] Split _.sample into _.sampleSize\n- [x] Split _.sortedIndex into _.sortedIndexBy\n- [x] Split _.sortedLastIndex into _.sortedLastIndexBy\n- [x] Split _.uniq into _.sortedUniq, _.sortedUniqBy, & _.uniqBy\n\nchanges:\n- [x] Absorbed _.sortByAll into _.sortBy\n- [x] Changed the category of _.at to âObjectâ\n- [x] Changed the category of _.bindAll to âUtilityâ\n- [x] Made _.capitalize uppercase the first character & lowercase the rest\n- [x] Made _.functions return only own method names\n\nadded 23 array methods:\n- [x] _.concat\n- [x] _.differenceBy\n- [x] _.differenceWith\n- [x] _.flatMap\n- [x] _.fromPairs\n- [x] _.intersectionBy\n- [x] _.intersectionWith\n- [x] _.join\n- [x] _.pullAll\n- [x] _.pullAllBy\n- [x] _.reverse\n- [x] _.sortedIndexBy\n- [x] _.sortedIndexOf\n- [x] _.sortedLastIndexBy\n- [x] _.sortedLastIndexOf\n- [x] _.sortedUniq\n- [x] _.sortedUniqBy\n- [x] _.unionBy\n- [x] _.unionWith\n- [x] _.uniqBy\n- [x] _.uniqWith\n- [x] _.xorBy\n- [x] _.xorWith\n\nadded 20 lang methods:\n- [x] _.cloneDeepWith\n- [x] _.cloneWith\n- [x] _.eq\n- [x] _.isArrayLike\n- [x] _.isArrayLikeObject\n- [x] _.isEqualWith\n- [x] _.isInteger\n- [x] _.isLength\n- [x] _.isMatchWith\n- [x] _.isNil\n- [x] _.isObjectLike\n- [x] _.isSafeInteger\n- [x] _.isSymbol\n- [x] _.toInteger\n- [x] _.toLength\n- [x] _.toNumber\n- [x] _.toSafeInteger\n- [x] _.toString\n- [X] _.conforms\n- [X] _.conformsTo\n\nadded 13 object methods:\n- [x] _.assignIn\n- [x] _.assignInWith\n- [x] _.assignWith\n- [x] _.functionsIn\n- [x] _.hasIn\n- [x] _.mergeWith\n- [x] _.omitBy\n- [x] _.pickBy\n\nadded 8 string methods:\n- [x] _.lowerCase\n- [x] _.lowerFirst\n- [x] _.upperCase\n- [x] _.upperFirst\n- [x] _.toLower\n- [x] _.toUpper\n\nadded 8 utility methods:\n- [x] _.toPath\n\nadded 4 math methods:\n- [x] _.maxBy\n- [x] _.mean\n- [x] _.minBy\n- [x] _.sumBy\n\nadded 2 function methods:\n- [x] _.flip\n- [x] _.unary\n\nadded 2 number methods:\n- [x] _.clamp\n- [x] _.subtract\n\nadded collection method:\n- [x] _.sampleSize\n\nAdded 3 aliases\n\n- [x] _.first as an alias of _.head\n\nRemoved 17 aliases\n- [x] Removed aliase _.all\n- [x] Removed aliase _.any\n- [x] Removed aliase _.backflow\n- [x] Removed aliase _.callback\n- [x] Removed aliase _.collect\n- [x] Removed aliase _.compose\n- [x] Removed aliase _.contains\n- [x] Removed aliase _.detect\n- [x] Removed aliase _.foldl\n- [x] Removed aliase _.foldr\n- [x] Removed aliase _.include\n- [x] Removed aliase _.inject\n- [x] Removed aliase _.methods\n- [x] Removed aliase _.object\n- [x] Removed aliase _.run\n- [x] Removed aliase _.select\n- [x] Removed aliase _.unique\n\nOther changes\n- [x] Added support for array buffers to _.isEqual\n- [x] Added support for converting iterators to _.toArray\n- [x] Added support for deep paths to _.zipObject\n- [x] Changed UMD to export to window or self when available regardless of other exports\n- [x] Ensured debounce cancel clears args & thisArg references\n- [x] Ensured _.add, _.subtract, & _.sum donât skip NaN values\n- [x] Ensured _.clone treats generators like functions\n- [x] Ensured _.clone produces clones with the sourceâs [[Prototype]]\n- [x] Ensured _.defaults assigns properties that shadow Object.prototype\n- [x] Ensured _.defaultsDeep doesnât merge a string into an array\n- [x] Ensured _.defaultsDeep & _.merge donât modify sources\n- [x] Ensured _.defaultsDeep works with circular references\n- [x] Ensured _.keys skips âlengthâ on strict mode arguments objects in Safari 9\n- [x] Ensured _.merge doesnât convert strings to arrays\n- [x] Ensured _.merge merges plain-objects onto non plain-objects\n- [x] Ensured _#plant resets iterator data of cloned sequences\n- [x] Ensured _.random swaps min & max if min is greater than max\n- [x] Ensured _.range preserves the sign of start of -0\n- [x] Ensured _.reduce & _.reduceRight use getIteratee in their array branch\n- [x] Fixed rounding issue with the precision param of _.floor\n- [x] Added flush method to debounced & throttled functions\n\n** LATER **\nMisc:\n- [ ] Made _.forEach, _.forIn, _.forOwn, & _.times implicitly end a chain sequence\n- [ ] Removed thisArg params from most methods\n- [ ] Made âByâ methods provide a single param to iteratees\n- [ ] Made _.words chainable by default\n- [ ] Removed isDeep params from _.clone & _.flatten\n- [ ] Removed _.bindAll support for binding all methods when no names are provided\n- [ ] Removed func-first param signature from _.before & _.after\n- [ ] _.extend as an alias of _.assignIn\n- [ ] _.extendWith as an alias of _.assignInWith\n- [ ] Added clear method to _.memoize.Cache\n- [ ] Added support for ES6 maps, sets, & symbols to _.clone, _.isEqual, & _.toArray\n- [x] Enabled _.flow & _.flowRight to accept an array of functions\n- [ ] Ensured âCollectionâ methods treat functions as objects\n- [ ] Ensured _.assign, _.defaults, & _.merge coerce object values to objects\n- [ ] Ensured _.bindKey bound functions call object[key] when called with the new operator\n- [ ] Ensured _.isFunction returns true for generator functions\n- [ ] Ensured _.merge assigns typed arrays directly\n- [ ] Made _(...) an iterator & iterable\n- [ ] Made _.drop, _.take, & right forms coerce n of undefined to 0\n\nMethods:\n- [ ] _.concat\n- [ ] _.differenceBy\n- [ ] _.differenceWith\n- [ ] _.flatMap\n- [ ] _.fromPairs\n- [ ] _.intersectionBy\n- [ ] _.intersectionWith\n- [ ] _.join\n- [ ] _.pullAll\n- [ ] _.pullAllBy\n- [ ] _.reverse\n- [ ] _.sortedLastIndexOf\n- [ ] _.unionBy\n- [ ] _.unionWith\n- [ ] _.uniqWith\n- [ ] _.xorBy\n- [ ] _.xorWith\n- [ ] _.toString\n\n- [ ] _.invoke\n- [ ] _.setWith\n- [ ] _.toPairs\n- [ ] _.toPairsIn\n- [ ] _.unset\n\n- [ ] _.replace\n- [ ] _.split\n\n- [ ] _.cond\n- [ ] _.nthArg\n- [ ] _.over\n- [ ] _.overEvery\n- [ ] _.overSome\n- [ ] _.rangeRight\n\n- [ ] _.next\n*/\n\nexport = _;\nexport as namespace _;\n\ndeclare let _: _.LoDashStatic;\n\ntype PartialObject<T> = Partial<T>;\n\ndeclare namespace _ {\n    type Many<T> = T | T[];\n\n    interface LoDashStatic {\n        /**\n        * Creates a lodash object which wraps value to enable implicit method chain sequences.\n        * Methods that operate on and return arrays, collections, and functions can be chained together.\n        * Methods that retrieve a single value or may return a primitive value will automatically end the\n        * chain sequence and return the unwrapped value. Otherwise, the value must be unwrapped with value().\n        *\n        * Explicit chain sequences, which must be unwrapped with value(), may be enabled using _.chain.\n        *\n        * The execution of chained methods is lazy, that is, it's deferred until value() is\n        * implicitly or explicitly called.\n        *\n        * Lazy evaluation allows several methods to support shortcut fusion. Shortcut fusion\n        * is an optimization to merge iteratee calls; this avoids the creation of intermediate\n        * arrays and can greatly reduce the number of iteratee executions. Sections of a chain\n        * sequence qualify for shortcut fusion if the section is applied to an array and iteratees\n        * accept only one argument. The heuristic for whether a section qualifies for shortcut\n        * fusion is subject to change.\n        *\n        * Chaining is supported in custom builds as long as the value() method is directly or\n        * indirectly included in the build.\n        *\n        * In addition to lodash methods, wrappers have Array and String methods.\n        * The wrapper Array methods are:\n        * concat, join, pop, push, shift, sort, splice, and unshift.\n        * The wrapper String methods are:\n        * replace and split.\n        *\n        * The wrapper methods that support shortcut fusion are:\n        * at, compact, drop, dropRight, dropWhile, filter, find, findLast, head, initial, last,\n        * map, reject, reverse, slice, tail, take, takeRight, takeRightWhile, takeWhile, and toArray\n        *\n        * The chainable wrapper methods are:\n        * after, ary, assign, assignIn, assignInWith, assignWith, at, before, bind, bindAll, bindKey,\n        * castArray, chain, chunk, commit, compact, concat, conforms, constant, countBy, create,\n        * curry, debounce, defaults, defaultsDeep, defer, delay, difference, differenceBy, differenceWith,\n        * drop, dropRight, dropRightWhile, dropWhile, extend, extendWith, fill, filter, flatMap,\n        * flatMapDeep, flatMapDepth, flatten, flattenDeep, flattenDepth, flip, flow, flowRight,\n        * fromPairs, functions, functionsIn, groupBy, initial, intersection, intersectionBy, intersectionWith,\n        * invert, invertBy, invokeMap, iteratee, keyBy, keys, keysIn, map, mapKeys, mapValues,\n        * matches, matchesProperty, memoize, merge, mergeWith, method, methodOf, mixin, negate,\n        * nthArg, omit, omitBy, once, orderBy, over, overArgs, overEvery, overSome, partial, partialRight,\n        * partition, pick, pickBy, plant, property, propertyOf, pull, pullAll, pullAllBy, pullAllWith, pullAt,\n        * push, range, rangeRight, rearg, reject, remove, rest, reverse, sampleSize, set, setWith,\n        * shuffle, slice, sort, sortBy, sortedUniq, sortedUniqBy, splice, spread, tail, take,\n        * takeRight, takeRightWhile, takeWhile, tap, throttle, thru, toArray, toPairs, toPairsIn,\n        * toPath, toPlainObject, transform, unary, union, unionBy, unionWith, uniq, uniqBy, uniqWith,\n        * unset, unshift, unzip, unzipWith, update, updateWith, values, valuesIn, without, wrap,\n        * xor, xorBy, xorWith, zip, zipObject, zipObjectDeep, and zipWith.\n        *\n        * The wrapper methods that are not chainable by default are:\n        * add, attempt, camelCase, capitalize, ceil, clamp, clone, cloneDeep, cloneDeepWith, cloneWith,\n        * conformsTo, deburr, defaultTo, divide, each, eachRight, endsWith, eq, escape, escapeRegExp,\n        * every, find, findIndex, findKey, findLast, findLastIndex, findLastKey, first, floor, forEach,\n        * forEachRight, forIn, forInRight, forOwn, forOwnRight, get, gt, gte, has, hasIn, head,\n        * identity, includes, indexOf, inRange, invoke, isArguments, isArray, isArrayBuffer,\n        * isArrayLike, isArrayLikeObject, isBoolean, isBuffer, isDate, isElement, isEmpty, isEqual, isEqualWith,\n        * isError, isFinite, isFunction, isInteger, isLength, isMap, isMatch, isMatchWith, isNaN,\n        * isNative, isNil, isNull, isNumber, isObject, isObjectLike, isPlainObject, isRegExp,\n        * isSafeInteger, isSet, isString, isUndefined, isTypedArray, isWeakMap, isWeakSet, join,\n        * kebabCase, last, lastIndexOf, lowerCase, lowerFirst, lt, lte, max, maxBy, mean, meanBy,\n        * min, minBy, multiply, noConflict, noop, now, nth, pad, padEnd, padStart, parseInt, pop,\n        * random, reduce, reduceRight, repeat, result, round, runInContext, sample, shift, size,\n        * snakeCase, some, sortedIndex, sortedIndexBy, sortedLastIndex, sortedLastIndexBy, startCase,\n        * startsWith, stubArray, stubFalse, stubObject, stubString, stubTrue, subtract, sum, sumBy,\n        * template, times, toFinite, toInteger, toJSON, toLength, toLower, toNumber, toSafeInteger,\n        * toString, toUpper, trim, trimEnd, trimStart, truncate, unescape, uniqueId, upperCase,\n        * upperFirst, value, and words.\n        **/\n        <T>(value: T): LoDashImplicitWrapper<T>;\n\n        /**\n        * The semantic version number.\n        **/\n        VERSION: string;\n\n        /**\n        * By default, the template delimiters used by Lo-Dash are similar to those in embedded Ruby\n        * (ERB). Change the following template settings to use alternative delimiters.\n        **/\n        templateSettings: TemplateSettings;\n    }\n\n    /**\n    * By default, the template delimiters used by Lo-Dash are similar to those in embedded Ruby\n    * (ERB). Change the following template settings to use alternative delimiters.\n    **/\n    interface TemplateSettings {\n        /**\n        * The \"escape\" delimiter.\n        **/\n        escape?: RegExp;\n\n        /**\n        * The \"evaluate\" delimiter.\n        **/\n        evaluate?: RegExp;\n\n        /**\n        * An object to import into the template as local variables.\n        **/\n        imports?: Dictionary<any>;\n\n        /**\n        * The \"interpolate\" delimiter.\n        **/\n        interpolate?: RegExp;\n\n        /**\n        * Used to reference the data object in the template text.\n        **/\n        variable?: string;\n    }\n\n    /**\n     * Creates a cache object to store key/value pairs.\n     */\n    interface MapCache {\n        /**\n         * Removes `key` and its value from the cache.\n         * @param key The key of the value to remove.\n         * @return Returns `true` if the entry was removed successfully, else `false`.\n         */\n        delete(key: string): boolean;\n\n        /**\n         * Gets the cached value for `key`.\n         * @param key The key of the value to get.\n         * @return Returns the cached value.\n         */\n        get(key: string): any;\n\n        /**\n         * Checks if a cached value for `key` exists.\n         * @param key The key of the entry to check.\n         * @return Returns `true` if an entry for `key` exists, else `false`.\n         */\n        has(key: string): boolean;\n\n        /**\n         * Sets `value` to `key` of the cache.\n         * @param key The key of the value to cache.\n         * @param value The value to cache.\n         * @return Returns the cache object.\n         */\n        set(key: string, value: any): Dictionary<any>;\n\n        /**\n         * Removes all key-value entries from the map.\n         */\n        clear(): void;\n    }\n    interface MapCacheConstructor {\n        new (): MapCache;\n    }\n\n    interface LoDashWrapper<TValue> { }\n\n    interface LoDashImplicitWrapper<TValue> extends LoDashWrapper<TValue> {\n        pop<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>): T | undefined;\n        push<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>, ...items: T[]): this;\n        shift<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>): T | undefined;\n        sort<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>, compareFn?: (a: T, b: T) => number): this;\n        splice<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>, start: number, deleteCount?: number, ...items: T[]): this;\n        unshift<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>, ...items: T[]): this;\n    }\n\n    interface LoDashExplicitWrapper<TValue> extends LoDashWrapper<TValue> {\n        pop<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>): LoDashExplicitWrapper<T | undefined>;\n        push<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>, ...items: T[]): this;\n        shift<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>): LoDashExplicitWrapper<T | undefined>;\n        sort<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>, compareFn?: (a: T, b: T) => number): this;\n        splice<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>, start: number, deleteCount?: number, ...items: T[]): this;\n        unshift<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>, ...items: T[]): this;\n    }\n\n    /*********\n     * Array *\n     *********/\n\n    //_.chunk\n    interface LoDashStatic {\n        /**\n         * Creates an array of elements split into groups the length of size. If collection canât be split evenly, the\n         * final chunk will be the remaining elements.\n         *\n         * @param array The array to process.\n         * @param size The length of each chunk.\n         * @return Returns the new array containing chunks.\n         */\n        chunk<T>(\n            array: List<T> | null | undefined,\n            size?: number\n        ): T[][];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.chunk\n         */\n        chunk<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            size?: number,\n        ): LoDashImplicitWrapper<T[][]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.chunk\n         */\n        chunk<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            size?: number,\n        ): LoDashExplicitWrapper<T[][]>;\n    }\n\n    //_.compact\n    interface LoDashStatic {\n        /**\n         * Creates an array with all falsey values removed. The values false, null, 0, \"\", undefined, and NaN are\n         * falsey.\n         *\n         * @param array The array to compact.\n         * @return Returns the new array of filtered values.\n         */\n        compact<T>(array: List<T | null | undefined | false | \"\" | 0> | null | undefined): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.compact\n         */\n        compact<T>(this: LoDashImplicitWrapper<List<T | null | undefined | false | \"\" | 0> | null | undefined>): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.compact\n         */\n        compact<T>(this: LoDashExplicitWrapper<List<T | null | undefined | false | \"\" | 0> | null | undefined>): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.concat\n    interface LoDashStatic {\n        /**\n         * Creates a new array concatenating `array` with any additional arrays\n         * and/or values.\n         *\n         * @category Array\n         * @param array The array to concatenate.\n         * @param [values] The values to concatenate.\n         * @returns Returns the new concatenated array.\n         * @example\n         *\n         * var array = [1];\n         * var other = _.concat(array, 2, [3], [[4]]);\n         *\n         * console.log(other);\n         * // => [1, 2, 3, [4]]\n         *\n         * console.log(array);\n         * // => [1]\n         */\n         concat<T>(array: Many<T>, ...values: Array<Many<T>>): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.compact\n         */\n        concat<T>(this: LoDashImplicitWrapper<Many<T>>, ...values: Array<Many<T>>): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.compact\n         */\n        concat<T>(this: LoDashExplicitWrapper<Many<T>>, ...values: Array<Many<T>>): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.difference\n    interface LoDashStatic {\n        /**\n         * Creates an array of unique array values not included in the other provided arrays using SameValueZero for\n         * equality comparisons.\n         *\n         * @param array The array to inspect.\n         * @param values The arrays of values to exclude.\n         * @return Returns the new array of filtered values.\n         */\n        difference<T>(\n            array: List<T> | null | undefined,\n            ...values: Array<List<T>>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.difference\n         */\n        difference<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            ...values: Array<List<T>>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.difference\n         */\n        difference<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            ...values: Array<List<T>>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.differenceBy\n    interface LoDashStatic {\n        /**\n         * This method is like _.difference except that it accepts iteratee which is invoked for each element of array\n         * and values to generate the criterion by which uniqueness is computed. The iteratee is invoked with one\n         * argument: (value).\n         *\n         * @param array The array to inspect.\n         * @param values The values to exclude.\n         * @param iteratee The iteratee invoked per element.\n         * @returns Returns the new array of filtered values.\n         */\n        differenceBy<T1, T2>(\n            array: List<T1> | null | undefined,\n            values: List<T2>,\n            iteratee: ValueIteratee<T1 | T2>\n        ): T1[];\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2, T3>(\n            array: List<T1> | null | undefined,\n            values1: List<T2>,\n            values2: List<T3>,\n            iteratee: ValueIteratee<T1 | T2 | T3>\n        ): T1[];\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2, T3, T4>(\n            array: List<T1> | null | undefined,\n            values1: List<T2>,\n            values2: List<T3>,\n            values3: List<T4>,\n            iteratee: ValueIteratee<T1 | T2 | T3 | T4>\n        ): T1[];\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2, T3, T4, T5>(\n            array: List<T1> | null | undefined,\n            values1: List<T2>,\n            values2: List<T3>,\n            values3: List<T4>,\n            values4: List<T5>,\n            iteratee: ValueIteratee<T1 | T2 | T3 | T4 | T5>\n        ): T1[];\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2, T3, T4, T5, T6>(\n            array: List<T1> | null | undefined,\n            values1: List<T2>,\n            values2: List<T3>,\n            values3: List<T4>,\n            values4: List<T5>,\n            values5: List<T6>,\n            iteratee: ValueIteratee<T1 | T2 | T3 | T4 | T5 | T6>\n        ): T1[];\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2, T3, T4, T5, T6, T7>(\n            array: List<T1> | null | undefined,\n            values1: List<T2>,\n            values2: List<T3>,\n            values3: List<T4>,\n            values4: List<T5>,\n            values5: List<T6>,\n            ...values: Array<List<T7> | ValueIteratee<T1 | T2 | T3 | T4 | T5 | T6 | T7>>\n        ): T1[];\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T>(\n            array: List<T> | null | undefined,\n            ...values: Array<List<T>>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2>(\n            this: LoDashImplicitWrapper<List<T1> | null | undefined>,\n            values: List<T2>,\n            iteratee: ValueIteratee<T1 | T2>\n        ): LoDashImplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2, T3>(\n            this: LoDashImplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            iteratee: ValueIteratee<T1 | T2 | T3>\n        ): LoDashImplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2, T3, T4>(\n            this: LoDashImplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            values3: List<T4>,\n            iteratee: ValueIteratee<T1 | T2 | T3 | T4>\n        ): LoDashImplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2, T3, T4, T5>(\n            this: LoDashImplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            values3: List<T4>,\n            values4: List<T5>,\n            iteratee: ValueIteratee<T1 | T2 | T3 | T4 | T5>\n        ): LoDashImplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2, T3, T4, T5, T6>(\n            this: LoDashImplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            values3: List<T4>,\n            values4: List<T5>,\n            values5: List<T6>,\n            iteratee: ValueIteratee<T1 | T2 | T3 | T4 | T5 | T6>\n        ): LoDashImplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2, T3, T4, T5, T6, T7>(\n            this: LoDashImplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            values3: List<T4>,\n            values4: List<T5>,\n            values5: List<T6>,\n            ...values: Array<List<T7> | ValueIteratee<T1 | T2 | T3 | T4 | T5 | T6 | T7>>\n        ): LoDashImplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            ...values: Array<List<T>>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2>(\n            this: LoDashExplicitWrapper<List<T1> | null | undefined>,\n            values: List<T2>,\n            iteratee: ValueIteratee<T1 | T2>\n        ): LoDashExplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2, T3>(\n            this: LoDashExplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            iteratee: ValueIteratee<T1 | T2 | T3>\n        ): LoDashExplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2, T3, T4>(\n            this: LoDashExplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            values3: List<T4>,\n            iteratee: ValueIteratee<T1 | T2 | T3 | T4>\n        ): LoDashExplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2, T3, T4, T5>(\n            this: LoDashExplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            values3: List<T4>,\n            values4: List<T5>,\n            iteratee: ValueIteratee<T1 | T2 | T3 | T4 | T5>\n        ): LoDashExplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2, T3, T4, T5, T6>(\n            this: LoDashExplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            values3: List<T4>,\n            values4: List<T5>,\n            values5: List<T6>,\n            iteratee: ValueIteratee<T1 | T2 | T3 | T4 | T5 | T6>\n        ): LoDashExplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T1, T2, T3, T4, T5, T6, T7>(\n            this: LoDashExplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            values3: List<T4>,\n            values4: List<T5>,\n            values5: List<T6>,\n            ...values: Array<List<T7> | ValueIteratee<T1 | T2 | T3 | T4 | T5 | T6 | T7>>\n        ): LoDashExplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceBy\n         */\n        differenceBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            ...values: Array<List<T>>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.differenceWith\n    interface LoDashStatic {\n        /**\n         * Creates an array of unique `array` values not included in the other\n         * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n         * for equality comparisons.\n         *\n         * @category Array\n         * @param [values] The arrays to inspect.\n         * @param [comparator] The comparator invoked per element.\n         * @returns Returns the new array of filtered values.\n         * @example\n         *\n         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n\n         * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);\n         * // => [{ 'x': 2, 'y': 1 }]\n         */\n        differenceWith<T1, T2>(\n            array: List<T1> | null | undefined,\n            values: List<T2>,\n            comparator: Comparator2<T1, T2>\n        ): T1[];\n\n        /**\n         * @see _.differenceWith\n         */\n        differenceWith<T1, T2, T3>(\n            array: List<T1> | null | undefined,\n            values1: List<T2>,\n            values2: List<T3>,\n            comparator: Comparator2<T1, T2 | T3>\n        ): T1[];\n\n        /**\n         * @see _.differenceWith\n         */\n        differenceWith<T1, T2, T3, T4>(\n            array: List<T1> | null | undefined,\n            values1: List<T2>,\n            values2: List<T3>,\n            ...values: Array<List<T4> | Comparator2<T1, T2 | T3 | T4>>\n        ): T1[];\n\n        /**\n         * @see _.differenceWith\n         */\n        differenceWith<T>(\n            array: List<T> | null | undefined,\n            ...values: Array<List<T>>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.differenceWith\n         */\n        differenceWith<T1, T2>(\n            this: LoDashImplicitWrapper<List<T1> | null | undefined>,\n            values: List<T2>,\n            comparator: Comparator2<T1, T2>\n        ): LoDashImplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceWith\n         */\n        differenceWith<T1, T2, T3>(\n            this: LoDashImplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            comparator: Comparator2<T1, T2 | T3>\n        ): LoDashImplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceWith\n         */\n        differenceWith<T1, T2, T3, T4>(\n            this: LoDashImplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            ...values: Array<List<T4> | Comparator2<T1, T2 | T3 | T4>>\n        ): LoDashImplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceWith\n         */\n        differenceWith<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            ...values: Array<List<T>>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.differenceWith\n         */\n        differenceWith<T1, T2>(\n            this: LoDashExplicitWrapper<List<T1> | null | undefined>,\n            values: List<T2>,\n            comparator: Comparator2<T1, T2>\n        ): LoDashExplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceWith\n         */\n        differenceWith<T1, T2, T3>(\n            this: LoDashExplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            comparator: Comparator2<T1, T2 | T3>\n        ): LoDashExplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceWith\n         */\n        differenceWith<T1, T2, T3, T4>(\n            this: LoDashExplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            ...values: Array<List<T4> | Comparator2<T1, T2 | T3 | T4>>\n        ): LoDashExplicitWrapper<T1[]>;\n\n        /**\n         * @see _.differenceWith\n         */\n        differenceWith<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            ...values: Array<List<T>>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.drop\n    interface LoDashStatic {\n        /**\n         * Creates a slice of array with n elements dropped from the beginning.\n         *\n         * @param array The array to query.\n         * @param n The number of elements to drop.\n         * @return Returns the slice of array.\n         */\n        drop<T>(array: List<T> | null | undefined, n?: number): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.drop\n         */\n        drop<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>, n?: number): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.drop\n         */\n        drop<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>, n?: number): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.dropRight\n    interface LoDashStatic {\n        /**\n         * Creates a slice of array with n elements dropped from the end.\n         *\n         * @param array The array to query.\n         * @param n The number of elements to drop.\n         * @return Returns the slice of array.\n         */\n        dropRight<T>(\n            array: List<T> | null | undefined,\n            n?: number\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.dropRight\n         */\n        dropRight<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>, n?: number): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.dropRight\n         */\n        dropRight<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>, n?: number): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.dropRightWhile\n    interface LoDashStatic {\n        /**\n         * Creates a slice of array excluding elements dropped from the end. Elements are dropped until predicate\n         * returns falsey. The predicate is bound to thisArg and invoked with three arguments: (value, index, array).\n         *\n         * If a property name is provided for predicate the created _.property style callback returns the property\n         * value of the given element.\n         *\n         * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for\n         * elements that have a matching property value, else false.\n         *\n         * If an object is provided for predicate the created _.matches style callback returns true for elements that\n         * match the properties of the given object, else false.\n         *\n         * @param array The array to query.\n         * @param predicate The function invoked per iteration.\n         * @param thisArg The this binding of predicate.\n         * @return Returns the slice of array.\n         */\n        dropRightWhile<T>(\n            array: List<T> | null | undefined,\n            predicate?: ListIteratee<T>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.dropRightWhile\n         */\n        dropRightWhile<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIteratee<T>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.dropRightWhile\n         */\n        dropRightWhile<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIteratee<T>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.dropWhile\n    interface LoDashStatic {\n        /**\n         * Creates a slice of array excluding elements dropped from the beginning. Elements are dropped until predicate\n         * returns falsey. The predicate is bound to thisArg and invoked with three arguments: (value, index, array).\n         *\n         * If a property name is provided for predicate the created _.property style callback returns the property\n         * value of the given element.\n         *\n         * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for\n         * elements that have a matching property value, else false.\n         *\n         * If an object is provided for predicate the created _.matches style callback returns true for elements that\n         * have the properties of the given object, else false.\n         *\n         * @param array The array to query.\n         * @param predicate The function invoked per iteration.\n         * @param thisArg The this binding of predicate.\n         * @return Returns the slice of array.\n         */\n        dropWhile<T>(\n            array: List<T> | null | undefined,\n            predicate?: ListIteratee<T>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.dropWhile\n         */\n        dropWhile<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIteratee<T>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.dropWhile\n         */\n        dropWhile<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIteratee<T>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.fill\n    interface LoDashStatic {\n        /**\n         * Fills elements of array with value from start up to, but not including, end.\n         *\n         * Note: This method mutates array.\n         *\n         * @param array The array to fill.\n         * @param value The value to fill array with.\n         * @param start The start position.\n         * @param end The end position.\n         * @return Returns array.\n         */\n        fill<T>(\n            array: any[] | null | undefined,\n            value: T\n        ): T[];\n\n        /**\n         * @see _.fill\n         */\n        fill<T>(\n            array: List<any> | null | undefined,\n            value: T\n        ): List<T>;\n\n        /**\n         * @see _.fill\n         */\n        fill<T, U>(\n            array: U[] | null | undefined,\n            value: T,\n            start?: number,\n            end?: number\n        ): Array<T | U>;\n\n        /**\n         * @see _.fill\n         */\n        fill<T, U>(\n            array: List<U> | null | undefined,\n            value: T,\n            start?: number,\n            end?: number\n        ): List<T | U>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.fill\n         */\n        fill<T>(\n            this: LoDashImplicitWrapper<any[] | null | undefined>,\n            value: T\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.fill\n         */\n        fill<T>(\n            this: LoDashImplicitWrapper<List<any> | null | undefined>,\n            value: T\n        ): LoDashImplicitWrapper<List<T>>;\n\n        /**\n         * @see _.fill\n         */\n        fill<T, U>(\n            this: LoDashImplicitWrapper<U[] | null | undefined>,\n            value: T,\n            start?: number,\n            end?: number\n        ): LoDashImplicitWrapper<Array<T | U>>;\n\n        /**\n         * @see _.fill\n         */\n        fill<T, U>(\n            this: LoDashImplicitWrapper<List<U> | null | undefined>,\n            value: T,\n            start?: number,\n            end?: number\n        ): LoDashImplicitWrapper<List<T | U>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.fill\n         */\n        fill<T>(\n            this: LoDashExplicitWrapper<any[] | null | undefined>,\n            value: T\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.fill\n         */\n        fill<T>(\n            this: LoDashExplicitWrapper<List<any> | null | undefined>,\n            value: T\n        ): LoDashExplicitWrapper<List<T>>;\n\n        /**\n         * @see _.fill\n         */\n        fill<T, U>(\n            this: LoDashExplicitWrapper<U[] | null | undefined>,\n            value: T,\n            start?: number,\n            end?: number\n        ): LoDashExplicitWrapper<Array<T | U>>;\n\n        /**\n         * @see _.fill\n         */\n        fill<T, U>(\n            this: LoDashExplicitWrapper<List<U> | null | undefined>,\n            value: T,\n            start?: number,\n            end?: number\n        ): LoDashExplicitWrapper<List<T | U>>;\n    }\n\n    //_.findIndex\n    interface LoDashStatic {\n        /**\n         * This method is like _.find except that it returns the index of the first element predicate returns truthy\n         * for instead of the element itself.\n         *\n         * If a property name is provided for predicate the created _.property style callback returns the property\n         * value of the given element.\n         *\n         * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for\n         * elements that have a matching property value, else false.\n         *\n         * If an object is provided for predicate the created _.matches style callback returns true for elements that\n         * have the properties of the given object, else false.\n         *\n         * @param array The array to search.\n         * @param predicate The function invoked per iteration.\n         * @param fromIndex The index to search from.\n         * @return Returns the index of the found element, else -1.\n         */\n        findIndex<T>(\n            array: List<T> | null | undefined,\n            predicate?: ListIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.findIndex\n         */\n        findIndex<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.findIndex\n         */\n        findIndex<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): LoDashExplicitWrapper<number>;\n    }\n\n    //_.findLastIndex\n    interface LoDashStatic {\n        /**\n         * This method is like _.findIndex except that it iterates over elements of collection from right to left.\n         *\n         * If a property name is provided for predicate the created _.property style callback returns the property\n         * value of the given element.\n         *\n         * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for\n         * elements that have a matching property value, else false.\n         *\n         * If an object is provided for predicate the created _.matches style callback returns true for elements that\n         * have the properties of the given object, else false.\n         *\n         * @param array The array to search.\n         * @param predicate The function invoked per iteration.\n         * @param fromIndex The index to search from.\n         * @return Returns the index of the found element, else -1.\n         */\n        findLastIndex<T>(\n            array: List<T> | null | undefined,\n            predicate?: ListIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.findLastIndex\n         */\n        findLastIndex<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.findLastIndex\n         */\n        findLastIndex<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): LoDashExplicitWrapper<number>;\n    }\n\n    //_.first\n    interface LoDashStatic {\n        first: typeof _.head; // tslint:disable-line:no-unnecessary-qualifier\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.head\n         */\n        first<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>): T | undefined;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.head\n         */\n        first<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>): LoDashExplicitWrapper<T | undefined>;\n    }\n\n    interface RecursiveArray<T> extends Array<T|RecursiveArray<T>> {}\n    interface ListOfRecursiveArraysOrValues<T> extends List<T|RecursiveArray<T>> {}\n\n    //_.flatten\n    interface LoDashStatic {\n        /**\n         * Flattens a nested array. If isDeep is true the array is recursively flattened, otherwise itâs only\n         * flattened a single level.\n         *\n         * @param array The array to flatten.\n         * @param isDeep Specify a deep flatten.\n         * @return Returns the new flattened array.\n         */\n        flatten<T>(array: ListOfRecursiveArraysOrValues<T> | null | undefined, isDeep: boolean): T[];\n\n        /**\n         * @see _.flatten\n         */\n        flatten<T>(array: List<Many<T>> | null | undefined): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.flatten\n         */\n        flatten<T>(this: LoDashImplicitWrapper<ListOfRecursiveArraysOrValues<T> | null | undefined>, isDeep: boolean): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.flatten\n         */\n        flatten<T>(this: LoDashImplicitWrapper<List<Many<T>> | null | undefined>): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.flatten\n         */\n        flatten<T>(this: LoDashExplicitWrapper<ListOfRecursiveArraysOrValues<T> | null | undefined>, isDeep: boolean): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.flatten\n         */\n        flatten<T>(this: LoDashExplicitWrapper<List<Many<T>> | null | undefined>): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.flattenDeep\n    interface LoDashStatic {\n        /**\n         * Recursively flattens a nested array.\n         *\n         * @param array The array to recursively flatten.\n         * @return Returns the new flattened array.\n         */\n        flattenDeep<T>(array: ListOfRecursiveArraysOrValues<T> | null | undefined): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.flattenDeep\n         */\n        flattenDeep<T>(this: LoDashImplicitWrapper<ListOfRecursiveArraysOrValues<T> | null | undefined>): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.flattenDeep\n         */\n        flattenDeep<T>(this: LoDashExplicitWrapper<ListOfRecursiveArraysOrValues<T> | null | undefined>): LoDashExplicitWrapper<T[]>;\n    }\n\n    // _.flattenDepth\n    interface LoDashStatic {\n        /**\n        * Recursively flatten array up to depth times.\n        *\n        * @param array The array to recursively flatten.\n        * @param number The maximum recursion depth.\n        * @return Returns the new flattened array.\n        */\n        flattenDepth<T>(array: ListOfRecursiveArraysOrValues<T> | null | undefined, depth?: number): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.flattenDeep\n         */\n        flattenDepth<T>(this: LoDashImplicitWrapper<ListOfRecursiveArraysOrValues<T> | null | undefined>, depth?: number): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.flattenDeep\n         */\n        flattenDepth<T>(this: LoDashExplicitWrapper<ListOfRecursiveArraysOrValues<T> | null | undefined>, depth?: number): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.fromPairs\n    interface LoDashStatic {\n        /**\n         * The inverse of `_.toPairs`; this method returns an object composed\n         * from key-value `pairs`.\n         *\n         * @category Array\n         * @param pairs The key-value pairs.\n         * @returns Returns the new object.\n         * @example\n         *\n         * _.fromPairs([['fred', 30], ['barney', 40]]);\n         * // => { 'fred': 30, 'barney': 40 }\n         */\n        fromPairs<T>(\n            pairs: List<[PropertyName, T]> | null | undefined\n        ): Dictionary<T>;\n\n        /**\n         @see _.fromPairs\n         */\n        fromPairs(\n            pairs: List<any[]> | null | undefined\n        ): Dictionary<any>;\n    }\n\n    //_.fromPairs\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.fromPairs\n         */\n        fromPairs<T>(\n          this: LoDashImplicitWrapper<List<[PropertyName, T]> | null | undefined>\n        ): LoDashImplicitWrapper<Dictionary<T>>;\n\n        /**\n         @see _.fromPairs\n         */\n        fromPairs(\n            this: LoDashImplicitWrapper<List<any[]> | null | undefined>\n        ): LoDashImplicitWrapper<Dictionary<any>>;\n    }\n    //_.fromPairs\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.fromPairs\n         */\n        fromPairs<T>(\n          this: LoDashExplicitWrapper<List<[PropertyName, T]> | null | undefined>\n        ): LoDashExplicitWrapper<Dictionary<T>>;\n\n        /**\n         @see _.fromPairs\n         */\n        fromPairs(\n            this: LoDashExplicitWrapper<List<any[]> | null | undefined>\n        ): LoDashExplicitWrapper<Dictionary<any>>;\n    }\n\n    //_.head\n    interface LoDashStatic {\n        /**\n         * Gets the first element of array.\n         *\n         * @alias _.first\n         *\n         * @param array The array to query.\n         * @return Returns the first element of array.\n         */\n        head<T>(array: List<T> | null | undefined): T | undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.head\n         */\n        head<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>): T | undefined;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.head\n         */\n        head<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>): LoDashExplicitWrapper<T | undefined>;\n    }\n\n    //_.indexOf\n    interface LoDashStatic {\n        /**\n         * Gets the index at which the first occurrence of `value` is found in `array`\n         * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n         * for equality comparisons. If `fromIndex` is negative, it's used as the offset\n         * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`\n         * performs a faster binary search.\n         *\n         * @category Array\n         * @param array The array to search.\n         * @param value The value to search for.\n         * @param [fromIndex=0] The index to search from.\n         * @returns Returns the index of the matched value, else `-1`.\n         * @example\n         *\n         * _.indexOf([1, 2, 1, 2], 2);\n         * // => 1\n         *\n         * // using `fromIndex`\n         * _.indexOf([1, 2, 1, 2], 2, 2);\n         * // => 3\n         */\n        indexOf<T>(\n            array: List<T> | null | undefined,\n            value: T,\n            fromIndex?: boolean|number\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.indexOf\n         */\n        indexOf<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            value: T,\n            fromIndex?: boolean|number\n        ): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.indexOf\n         */\n        indexOf<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            value: T,\n            fromIndex?: boolean|number\n        ): LoDashExplicitWrapper<number>;\n    }\n\n    //_.sortedIndexOf\n    interface LoDashStatic {\n        /**\n         * This method is like `_.indexOf` except that it performs a binary\n         * search on a sorted `array`.\n         *\n         * @category Array\n         * @param array The array to search.\n         * @param value The value to search for.\n         * @returns Returns the index of the matched value, else `-1`.\n         * @example\n         *\n         * _.sortedIndexOf([1, 1, 2, 2], 2);\n         * // => 2\n         */\n        sortedIndexOf<T>(\n            array: List<T> | null | undefined,\n            value: T\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.sortedIndexOf\n         */\n        sortedIndexOf<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            value: T\n        ): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.sortedIndexOf\n         */\n        sortedIndexOf<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            value: T\n        ): LoDashExplicitWrapper<number>;\n    }\n\n    //_.initial\n    interface LoDashStatic {\n        /**\n         * Gets all but the last element of array.\n         *\n         * @param array The array to query.\n         * @return Returns the slice of array.\n         */\n        initial<T>(array: List<T> | null | undefined): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.initial\n         */\n        initial<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.initial\n         */\n        initial<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.intersection\n    interface LoDashStatic {\n        /**\n         * Creates an array of unique values that are included in all of the provided arrays using SameValueZero for\n         * equality comparisons.\n         *\n         * @param arrays The arrays to inspect.\n         * @return Returns the new array of shared values.\n         */\n        intersection<T>(...arrays: Array<List<T>>): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.intersection\n         */\n        intersection<T>(\n            this: LoDashImplicitWrapper<List<T>>,\n            ...arrays: Array<List<T>>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.intersection\n         */\n        intersection<T>(\n            this: LoDashExplicitWrapper<List<T>>,\n            ...arrays: Array<List<T>>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.intersectionBy\n    interface LoDashStatic {\n        /**\n         * This method is like `_.intersection` except that it accepts `iteratee`\n         * which is invoked for each element of each `arrays` to generate the criterion\n         * by which uniqueness is computed. The iteratee is invoked with one argument: (value).\n         *\n         * @category Array\n         * @param [arrays] The arrays to inspect.\n         * @param [iteratee=_.identity] The iteratee invoked per element.\n         * @returns Returns the new array of shared values.\n         * @example\n         *\n         * _.intersectionBy([2.1, 1.2], [4.3, 2.4], Math.floor);\n         * // => [2.1]\n         *\n         * // using the `_.property` iteratee shorthand\n         * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n         * // => [{ 'x': 1 }]\n         */\n        intersectionBy<T1, T2>(\n            array: List<T1> | null,\n            values: List<T2>,\n            iteratee: ValueIteratee<T1 | T2>\n        ): T1[];\n\n        /**\n         * @see _.intersectionBy\n         */\n        intersectionBy<T1, T2, T3>(\n            array: List<T1> | null,\n            values1: List<T2>,\n            values2: List<T3>,\n            iteratee: ValueIteratee<T1 | T2 | T3>\n        ): T1[];\n\n        /**\n         * @see _.intersectionBy\n         */\n        intersectionBy<T1, T2, T3, T4>(\n            array: List<T1> | null | undefined,\n            values1: List<T2>,\n            values2: List<T3>,\n            ...values: Array<List<T4> | ValueIteratee<T1 | T2 | T3 | T4>>\n        ): T1[];\n\n        /**\n         * @see _.intersectionBy\n         */\n        intersectionBy<T>(\n            array?: List<T> | null,\n            ...values: Array<List<T>>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.intersectionBy\n         */\n        intersectionBy<T1, T2>(\n            this: LoDashImplicitWrapper<List<T1> | null | undefined>,\n            values: List<T2>,\n            iteratee: ValueIteratee<T1 | T2>\n        ): LoDashImplicitWrapper<T1[]>;\n\n        /**\n         * @see _.intersectionBy\n         */\n        intersectionBy<T1, T2, T3>(\n            this: LoDashImplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            iteratee: ValueIteratee<T1 | T2 | T3>\n        ): LoDashImplicitWrapper<T1[]>;\n\n        /**\n         * @see _.intersectionBy\n         */\n        intersectionBy<T1, T2, T3, T4>(\n            this: LoDashImplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            ...values: Array<List<T4> | ValueIteratee<T1 | T2 | T3 | T4>>\n        ): LoDashImplicitWrapper<T1[]>;\n\n        /**\n         * @see _.intersectionBy\n         */\n        intersectionBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            ...values: Array<List<T>>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.intersectionBy\n         */\n        intersectionBy<T1, T2>(\n            this: LoDashExplicitWrapper<List<T1> | null | undefined>,\n            values: List<T2>,\n            iteratee: ValueIteratee<T1 | T2>\n        ): LoDashExplicitWrapper<T1[]>;\n\n        /**\n         * @see _.intersectionBy\n         */\n        intersectionBy<T1, T2, T3>(\n            this: LoDashExplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            iteratee: ValueIteratee<T1 | T2 | T3>\n        ): LoDashExplicitWrapper<T1[]>;\n\n        /**\n         * @see _.intersectionBy\n         */\n        intersectionBy<T1, T2, T3, T4>(\n            this: LoDashExplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            ...values: Array<List<T4> | ValueIteratee<T1 | T2 | T3 | T4>>\n        ): LoDashExplicitWrapper<T1[]>;\n\n        /**\n         * @see _.intersectionBy\n         */\n        intersectionBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            ...values: Array<List<T>>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.intersectionWith\n    interface LoDashStatic {\n        /**\n         * Creates an array of unique `array` values not included in the other\n         * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n         * for equality comparisons.\n         *\n         * @category Array\n         * @param [values] The arrays to inspect.\n         * @param [comparator] The comparator invoked per element.\n         * @returns Returns the new array of filtered values.\n         * @example\n         *\n         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n\n         * _.intersectionWith(objects, others, _.isEqual);\n         * // => [{ 'x': 1, 'y': 2 }]\n         */\n        intersectionWith<T1, T2>(\n            array: List<T1> | null | undefined,\n            values: List<T2>,\n            comparator: Comparator2<T1, T2>\n        ): T1[];\n\n        /**\n         * @see _.intersectionWith\n         */\n        intersectionWith<T1, T2, T3>(\n            array: List<T1> | null | undefined,\n            values1: List<T2>,\n            values2: List<T3>,\n            comparator: Comparator2<T1, T2 | T3>\n        ): T1[];\n\n        /**\n         * @see _.intersectionWith\n         */\n        intersectionWith<T1, T2, T3, T4>(\n            array: List<T1> | null | undefined,\n            values1: List<T2>,\n            values2: List<T3>,\n            ...values: Array<List<T4> | Comparator2<T1, T2 | T3 | T4>>\n        ): T1[];\n\n        /**\n         * @see _.intersectionWith\n         */\n        intersectionWith<T>(\n            array?: List<T> | null,\n            ...values: Array<List<T>>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.intersectionWith\n         */\n        intersectionWith<T1, T2>(\n            this: LoDashImplicitWrapper<List<T1> | null | undefined>,\n            values: List<T2>,\n            comparator: Comparator2<T1, T2>\n        ): LoDashImplicitWrapper<T1[]>;\n\n        /**\n         * @see _.intersectionWith\n         */\n        intersectionWith<T1, T2, T3>(\n            this: LoDashImplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            comparator: Comparator2<T1, T2 | T3>\n        ): LoDashImplicitWrapper<T1[]>;\n\n        /**\n         * @see _.intersectionWith\n         */\n        intersectionWith<T1, T2, T3, T4>(\n            this: LoDashImplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            ...values: Array<List<T4> | Comparator2<T1, T2 | T3 | T4>>,\n        ): LoDashImplicitWrapper<T1[]>;\n\n        /**\n         * @see _.intersectionWith\n         */\n        intersectionWith<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            ...values: Array<List<T>>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.intersectionWith\n         */\n        intersectionWith<T1, T2>(\n            this: LoDashExplicitWrapper<List<T1> | null | undefined>,\n            values: List<T2>,\n            comparator: Comparator2<T1, T2>\n        ): LoDashExplicitWrapper<T1[]>;\n\n        /**\n         * @see _.intersectionWith\n         */\n        intersectionWith<T1, T2, T3>(\n            this: LoDashExplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            comparator: Comparator2<T1, T2 | T3>\n        ): LoDashExplicitWrapper<T1[]>;\n\n        /**\n         * @see _.intersectionWith\n         */\n        intersectionWith<T1, T2, T3, T4>(\n            this: LoDashExplicitWrapper<List<T1> | null | undefined>,\n            values1: List<T2>,\n            values2: List<T3>,\n            ...values: Array<List<T4> | Comparator2<T1, T2 | T3 | T4>>,\n        ): LoDashExplicitWrapper<T1[]>;\n\n        /**\n         * @see _.intersectionWith\n         */\n        intersectionWith<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            ...values: Array<List<T>>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.join\n    interface LoDashStatic {\n        /**\n         * Converts all elements in `array` into a string separated by `separator`.\n         *\n         * @param array The array to convert.\n         * @param separator The element separator.\n         * @returns Returns the joined string.\n         */\n        join(\n            array: List<any> | null | undefined,\n            separator?: string\n        ): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.join\n         */\n        join(separator?: string): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.join\n         */\n        join(separator?: string): LoDashExplicitWrapper<string>;\n    }\n\n    //_.reverse\n    interface LoDashStatic {\n        /**\n         * Reverses `array` so that the first element becomes the last, the second\n         * element becomes the second to last, and so on.\n         *\n         * **Note:** This method mutates `array` and is based on\n         * [`Array#reverse`](https://mdn.io/Array/reverse).\n         *\n         * @category Array\n         * @returns Returns `array`.\n         * @example\n         *\n         * var array = [1, 2, 3];\n         *\n         * _.reverse(array);\n         * // => [3, 2, 1]\n         *\n         * console.log(array);\n         * // => [3, 2, 1]\n         */\n        reverse<TList extends List<any>>(\n            array: TList,\n        ): TList;\n    }\n\n    //_.prototype.reverse\n    interface LoDashWrapper<TValue> {\n        /**\n         * Reverses the wrapped array so the first element becomes the last, the second element becomes the second to\n         * last, and so on.\n         *\n         * Note: This method mutates the wrapped array.\n         *\n         * @return Returns the new reversed lodash wrapper instance.\n         */\n        reverse(): this;\n    }\n\n    //_.last\n    interface LoDashStatic {\n        /**\n         * Gets the last element of array.\n         *\n         * @param array The array to query.\n         * @return Returns the last element of array.\n         */\n        last<T>(array: List<T> | null | undefined): T | undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.last\n         */\n        last<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>): T | undefined;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.last\n         */\n        last<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>): LoDashExplicitWrapper<T | undefined>;\n    }\n\n    //_.lastIndexOf\n    interface LoDashStatic {\n        /**\n         * This method is like _.indexOf except that it iterates over elements of array from right to left.\n         *\n         * @param array The array to search.\n         * @param value The value to search for.\n         * @param fromIndex The index to search from or true to perform a binary search on a sorted array.\n         * @return Returns the index of the matched value, else -1.\n         */\n        lastIndexOf<T>(\n            array: List<T> | null | undefined,\n            value: T,\n            fromIndex?: true|number\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.indexOf\n         */\n        lastIndexOf<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            value: T,\n            fromIndex?: true|number\n        ): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.indexOf\n         */\n        lastIndexOf<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            value: T,\n            fromIndex?: true|number\n        ): LoDashExplicitWrapper<number>;\n    }\n\n    //_.nth\n    interface LoDashStatic {\n        /**\n         * Gets the element at index `n` of `array`. If `n` is negative, the nth element from the end is returned.\n         *\n         * @param array array The array to query.\n         * @param value The index of the element to return.\n         * @return Returns the nth element of `array`.\n         */\n        nth<T>(\n            array: List<T> | null | undefined,\n            n?: number\n        ): T | undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.nth\n         */\n        nth<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            n?: number\n        ): T | undefined;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.nth\n         */\n        nth<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            n?: number\n        ): LoDashExplicitWrapper<T | undefined>;\n    }\n\n    //_.pull\n    interface LoDashStatic {\n        /**\n         * Removes all provided values from array using SameValueZero for equality comparisons.\n         *\n         * Note: Unlike _.without, this method mutates array.\n         *\n         * @param array The array to modify.\n         * @param values The values to remove.\n         * @return Returns array.\n         */\n        pull<T>(\n            array: T[],\n            ...values: T[]\n        ): T[];\n\n        /**\n         * @see _.pull\n         */\n        pull<T>(\n            array: List<T>,\n            ...values: T[]\n        ): List<T>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.pull\n         */\n        pull<T>(\n            this: LoDashImplicitWrapper<List<T>>,\n            ...values: T[]\n        ): this;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.pull\n         */\n        pull<T>(\n            this: LoDashExplicitWrapper<List<T>>,\n            ...values: T[]\n        ): this;\n    }\n\n    //_.pullAt\n    interface LoDashStatic {\n        /**\n         * Removes elements from array corresponding to the given indexes and returns an array of the removed elements.\n         * Indexes may be specified as an array of indexes or as individual arguments.\n         *\n         * Note: Unlike _.at, this method mutates array.\n         *\n         * @param array The array to modify.\n         * @param indexes The indexes of elements to remove, specified as individual indexes or arrays of indexes.\n         * @return Returns the new array of removed elements.\n         */\n        pullAt<T>(\n            array: T[],\n            ...indexes: Array<Many<number>>\n        ): T[];\n\n        /**\n         * @see _.pullAt\n         */\n        pullAt<T>(\n            array: List<T>,\n            ...indexes: Array<Many<number>>\n        ): List<T>;\n    }\n\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.pullAt\n         */\n        pullAt(...indexes: Array<Many<number>>): this;\n    }\n\n    //_.pullAll\n    interface LoDashStatic {\n        /**\n         * This method is like `_.pull` except that it accepts an array of values to remove.\n         *\n         * **Note:** Unlike `_.difference`, this method mutates `array`.\n         *\n         * @category Array\n         * @param array The array to modify.\n         * @param values The values to remove.\n         * @returns Returns `array`.\n         * @example\n         *\n         * var array = [1, 2, 3, 1, 2, 3];\n         *\n         * _.pull(array, [2, 3]);\n         * console.log(array);\n         * // => [1, 1]\n         */\n        pullAll<T>(\n            array: T[],\n            values?: List<T>,\n        ): T[];\n\n        /**\n         * @see _.pullAll\n         */\n        pullAll<T>(\n            array: List<T>,\n            values?: List<T>,\n        ): List<T>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.pullAll\n         */\n        pullAll<T>(\n            this: LoDashImplicitWrapper<List<T>>,\n            values?: List<T>\n        ): this;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.pullAll\n         */\n        pullAll<T>(\n            this: LoDashExplicitWrapper<List<T>>,\n            values?: List<T>\n        ): this;\n    }\n\n    //_.pullAllBy\n    interface LoDashStatic {\n        /**\n         * This method is like `_.pullAll` except that it accepts `iteratee` which is\n         * invoked for each element of `array` and `values` to to generate the criterion\n         * by which uniqueness is computed. The iteratee is invoked with one argument: (value).\n         *\n         * **Note:** Unlike `_.differenceBy`, this method mutates `array`.\n         *\n         * @category Array\n         * @param array The array to modify.\n         * @param values The values to remove.\n         * @param [iteratee=_.identity] The iteratee invoked per element.\n         * @returns Returns `array`.\n         * @example\n         *\n         * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\n         *\n         * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');\n         * console.log(array);\n         * // => [{ 'x': 2 }]\n         */\n        pullAllBy<T>(\n            array: T[],\n            values?: List<T>,\n            iteratee?: ValueIteratee<T>\n        ): T[];\n\n        /**\n         * @see _.pullAllBy\n         */\n        pullAllBy<T>(\n            array: List<T>,\n            values?: List<T>,\n            iteratee?: ValueIteratee<T>\n        ): List<T>;\n\n        /**\n         * @see _.pullAllBy\n         */\n        pullAllBy<T1, T2>(\n            array: T1[],\n            values: List<T2>,\n            iteratee: ValueIteratee<T1 | T2>\n        ): T1[];\n\n        /**\n         * @see _.pullAllBy\n         */\n        pullAllBy<T1, T2>(\n            array: List<T1>,\n            values: List<T2>,\n            iteratee: ValueIteratee<T1 | T2>\n        ): List<T1>;\n    }\n\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.pullAllBy\n         */\n        pullAllBy<T>(\n            this: LoDashWrapper<List<T>>,\n            values?: List<T>,\n            iteratee?: ValueIteratee<T>\n        ): this;\n\n        /**\n         * @see _.pullAllBy\n         */\n        pullAllBy<T1, T2>(\n            this: LoDashWrapper<List<T1>>,\n            values: List<T2>,\n            iteratee: ValueIteratee<T1 | T2>\n        ): this;\n    }\n\n    //_.pullAllWith\n    interface LoDashStatic {\n        /**\n         * This method is like `_.pullAll` except that it accepts `comparator` which is\n         * invoked to compare elements of array to values. The comparator is invoked with\n         * two arguments: (arrVal, othVal).\n         *\n         * **Note:** Unlike `_.differenceWith`, this method mutates `array`.\n         *\n         * @category Array\n         * @param array The array to modify.\n         * @param values The values to remove.\n         * @param [iteratee=_.identity] The iteratee invoked per element.\n         * @returns Returns `array`.\n         * @example\n         *\n         * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];\n         *\n         * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);\n         * console.log(array);\n         * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]\n         */\n        pullAllWith<T>(\n            array: T[],\n            values?: List<T>,\n            comparator?: Comparator<T>\n        ): T[];\n\n        /**\n         * @see _.pullAllWith\n         */\n        pullAllWith<T>(\n            array: List<T>,\n            values?: List<T>,\n            comparator?: Comparator<T>\n        ): List<T>;\n\n        /**\n         * @see _.pullAllWith\n         */\n        pullAllWith<T1, T2>(\n            array: T1[],\n            values: List<T2>,\n            comparator: Comparator2<T1, T2>\n        ): T1[];\n\n        /**\n         * @see _.pullAllWith\n         */\n        pullAllWith<T1, T2>(\n            array: List<T1>,\n            values: List<T2>,\n            comparator: Comparator2<T1, T2>\n        ): List<T1>;\n    }\n\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.pullAllWith\n         */\n        pullAllWith<T>(\n            this: LoDashWrapper<List<T>>,\n            values?: List<T>,\n            comparator?: Comparator<T>\n        ): this;\n\n        /**\n         * @see _.pullAllWith\n         */\n        pullAllWith<T1, T2>(\n            this: LoDashWrapper<List<T1>>,\n            values: List<T2>,\n            comparator: Comparator2<T1, T2>\n        ): this;\n    }\n\n    //_.remove\n    interface LoDashStatic {\n        /**\n         * Removes all elements from array that predicate returns truthy for and returns an array of the removed\n         * elements. The predicate is bound to thisArg and invoked with three arguments: (value, index, array).\n         *\n         * If a property name is provided for predicate the created _.property style callback returns the property\n         * value of the given element.\n         *\n         * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for\n         * elements that have a matching property value, else false.\n         *\n         * If an object is provided for predicate the created _.matches style callback returns true for elements that\n         * have the properties of the given object, else false.\n         *\n         * Note: Unlike _.filter, this method mutates array.\n         *\n         * @param array The array to modify.\n         * @param predicate The function invoked per iteration.\n         * @param thisArg The this binding of predicate.\n         * @return Returns the new array of removed elements.\n         */\n        remove<T>(\n            array: List<T>,\n            predicate?: ListIteratee<T>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.remove\n         */\n        remove<T>(\n            this: LoDashImplicitWrapper<List<T>>,\n            predicate?: ListIteratee<T>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.remove\n         */\n        remove<T>(\n            this: LoDashExplicitWrapper<List<T>>,\n            predicate?: ListIteratee<T>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.tail\n    interface LoDashStatic {\n        /**\n         * Gets all but the first element of array.\n         *\n         * @param array The array to query.\n         * @return Returns the slice of array.\n         */\n        tail<T>(array: List<T> | null | undefined): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.tail\n         */\n        tail<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.tail\n         */\n        tail<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.slice\n    interface LoDashStatic {\n        /**\n         * Creates a slice of array from start up to, but not including, end.\n         *\n         * @param array The array to slice.\n         * @param start The start position.\n         * @param end The end position.\n         * @return Returns the slice of array.\n         */\n        slice<T>(\n            array: List<T> | null | undefined,\n            start?: number,\n            end?: number\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.slice\n         */\n        slice<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            start?: number,\n            end?: number\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.slice\n         */\n        slice<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            start?: number,\n            end?: number\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.sortedIndex\n    interface LoDashStatic {\n        /**\n         * Uses a binary search to determine the lowest index at which `value` should\n         * be inserted into `array` in order to maintain its sort order.\n         *\n         * @category Array\n         * @param array The sorted array to inspect.\n         * @param value The value to evaluate.\n         * @returns Returns the index at which `value` should be inserted into `array`.\n         * @example\n         *\n         * _.sortedIndex([30, 50], 40);\n         * // => 1\n         *\n         * _.sortedIndex([4, 5], 4);\n         * // => 0\n         */\n        sortedIndex<T>(\n            array: List<T> | null | undefined,\n            value: T\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.sortedIndex\n         */\n        sortedIndex<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            value: T\n        ): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.sortedIndex\n         */\n        sortedIndex<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            value: T\n        ): LoDashExplicitWrapper<number>;\n    }\n\n    // _.sortedIndexBy\n    interface LoDashStatic {\n        /**\n         * This method is like `_.sortedIndex` except that it accepts `iteratee`\n         * which is invoked for `value` and each element of `array` to compute their\n         * sort ranking. The iteratee is invoked with one argument: (value).\n         *\n         * @category Array\n         * @param array The sorted array to inspect.\n         * @param value The value to evaluate.\n         * @param [iteratee=_.identity] The iteratee invoked per element.\n         * @returns Returns the index at which `value` should be inserted into `array`.\n         * @example\n         *\n         * var dict = { 'thirty': 30, 'forty': 40, 'fifty': 50 };\n         *\n         * _.sortedIndexBy(['thirty', 'fifty'], 'forty', _.propertyOf(dict));\n         * // => 1\n         *\n         * // using the `_.property` iteratee shorthand\n         * _.sortedIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');\n         * // => 0\n         */\n        sortedIndexBy<T>(\n            array: List<T> | null | undefined,\n            value: T,\n            iteratee?: ValueIteratee<T>\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.sortedIndexBy\n         */\n        sortedIndexBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            value: T,\n            iteratee?: ValueIteratee<T>\n        ): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.sortedIndexBy\n         */\n        sortedIndexBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            value: T,\n            iteratee?: ValueIteratee<T>\n        ): LoDashExplicitWrapper<number>;\n    }\n\n    //_.sortedLastIndex\n    interface LoDashStatic {\n        /**\n         * This method is like `_.sortedIndex` except that it returns the highest\n         * index at which `value` should be inserted into `array` in order to\n         * maintain its sort order.\n         *\n         * @category Array\n         * @param array The sorted array to inspect.\n         * @param value The value to evaluate.\n         * @returns Returns the index at which `value` should be inserted into `array`.\n         * @example\n         *\n         * _.sortedLastIndex([4, 5], 4);\n         * // => 1\n         */\n        sortedLastIndex<T>(\n            array: List<T> | null | undefined,\n            value: T\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.sortedLastIndex\n         */\n        sortedLastIndex<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            value: T\n        ): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.sortedLastIndex\n         */\n        sortedLastIndex<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            value: T\n        ): LoDashExplicitWrapper<number>;\n    }\n\n    //_.sortedLastIndexBy\n    interface LoDashStatic {\n        /**\n         * This method is like `_.sortedLastIndex` except that it accepts `iteratee`\n         * which is invoked for `value` and each element of `array` to compute their\n         * sort ranking. The iteratee is invoked with one argument: (value).\n         *\n         * @category Array\n         * @param array The sorted array to inspect.\n         * @param value The value to evaluate.\n         * @param [iteratee=_.identity] The iteratee invoked per element.\n         * @returns Returns the index at which `value` should be inserted into `array`.\n         * @example\n         *\n         * // using the `_.property` iteratee shorthand\n         * _.sortedLastIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');\n         * // => 1\n         */\n        sortedLastIndexBy<T>(\n            array: List<T> | null | undefined,\n            value: T,\n            iteratee: ValueIteratee<T>\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.sortedLastIndexBy\n         */\n        sortedLastIndexBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            value: T,\n            iteratee: ValueIteratee<T>\n        ): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.sortedLastIndexBy\n         */\n        sortedLastIndexBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            value: T,\n            iteratee: ValueIteratee<T>\n        ): LoDashExplicitWrapper<number>;\n    }\n\n    //_.sortedLastIndexOf\n    interface LoDashStatic {\n        /**\n         * This method is like `_.lastIndexOf` except that it performs a binary\n         * search on a sorted `array`.\n         *\n         * @category Array\n         * @param array The array to search.\n         * @param value The value to search for.\n         * @returns Returns the index of the matched value, else `-1`.\n         * @example\n         *\n         * _.sortedLastIndexOf([1, 1, 2, 2], 2);\n         * // => 3\n         */\n        sortedLastIndexOf<T>(\n            array: List<T> | null | undefined,\n            value: T\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.sortedLastIndexOf\n         */\n        sortedLastIndexOf<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            value: T\n        ): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.sortedLastIndexOf\n         */\n        sortedLastIndexOf<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            value: T\n        ): LoDashExplicitWrapper<number>;\n    }\n\n    //_.take\n    interface LoDashStatic {\n        /**\n         * Creates a slice of array with n elements taken from the beginning.\n         *\n         * @param array The array to query.\n         * @param n The number of elements to take.\n         * @return Returns the slice of array.\n         */\n        take<T>(\n            array: List<T> | null | undefined,\n            n?: number\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.take\n         */\n        take<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            n?: number\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.take\n         */\n        take<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            n?: number\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.takeRight\n    interface LoDashStatic {\n        /**\n         * Creates a slice of array with n elements taken from the end.\n         *\n         * @param array The array to query.\n         * @param n The number of elements to take.\n         * @return Returns the slice of array.\n         */\n        takeRight<T>(\n            array: List<T> | null | undefined,\n            n?: number\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.takeRight\n         */\n        takeRight<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            n?: number\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.takeRight\n         */\n        takeRight<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            n?: number\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.takeRightWhile\n    interface LoDashStatic {\n        /**\n         * Creates a slice of array with elements taken from the end. Elements are taken until predicate returns\n         * falsey. The predicate is bound to thisArg and invoked with three arguments: (value, index, array).\n         *\n         * If a property name is provided for predicate the created _.property style callback returns the property\n         * value of the given element.\n         *\n         * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for\n         * elements that have a matching property value, else false.\n         *\n         * If an object is provided for predicate the created _.matches style callback returns true for elements that\n         * have the properties of the given object, else false.\n         *\n         * @param array The array to query.\n         * @param predicate The function invoked per iteration.\n         * @param thisArg The this binding of predicate.\n         * @return Returns the slice of array.\n         */\n        takeRightWhile<T>(\n            array: List<T> | null | undefined,\n            predicate?: ListIteratee<T>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.takeRightWhile\n         */\n        takeRightWhile<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIteratee<T>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.takeRightWhile\n         */\n        takeRightWhile<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIteratee<T>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.takeWhile\n    interface LoDashStatic {\n        /**\n         * Creates a slice of array with elements taken from the beginning. Elements are taken until predicate returns\n         * falsey. The predicate is bound to thisArg and invoked with three arguments: (value, index, array).\n         *\n         * If a property name is provided for predicate the created _.property style callback returns the property\n         * value of the given element.\n         *\n         * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for\n         * elements that have a matching property value, else false.\n         *\n         * If an object is provided for predicate the created _.matches style callback returns true for elements that\n         * have the properties of the given object, else false.\n         *\n         * @param array The array to query.\n         * @param predicate The function invoked per iteration.\n         * @param thisArg The this binding of predicate.\n         * @return Returns the slice of array.\n         */\n        takeWhile<T>(\n            array: List<T> | null | undefined,\n            predicate?: ListIteratee<T>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.takeWhile\n         */\n        takeWhile<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIteratee<T>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.takeWhile\n         */\n        takeWhile<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIteratee<T>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.union\n    interface LoDashStatic {\n        /**\n         * Creates an array of unique values, in order, from all of the provided arrays using SameValueZero for\n         * equality comparisons.\n         *\n         * @param arrays The arrays to inspect.\n         * @return Returns the new array of combined values.\n         */\n        union<T>(...arrays: Array<List<T> | null | undefined>): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.union\n         */\n        union<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            ...arrays: Array<List<T> | null | undefined>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.union\n         */\n        union<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            ...arrays: Array<List<T> | null | undefined>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.unionBy\n    interface LoDashStatic {\n        /**\n         * This method is like `_.union` except that it accepts `iteratee` which is\n         * invoked for each element of each `arrays` to generate the criterion by which\n         * uniqueness is computed. The iteratee is invoked with one argument: (value).\n         *\n         * @param arrays The arrays to inspect.\n         * @param iteratee The iteratee invoked per element.\n         * @return Returns the new array of combined values.\n         */\n        unionBy<T>(\n            arrays: List<T> | null | undefined,\n            iteratee?: ValueIteratee<T>\n        ): T[];\n\n        /**\n         * @see _.unionBy\n         */\n        unionBy<T>(\n            arrays1: List<T> | null | undefined,\n            arrays2: List<T> | null | undefined,\n            iteratee?: ValueIteratee<T>\n        ): T[];\n\n        /**\n         * @see _.unionBy\n         */\n        unionBy<T>(\n            arrays1: List<T> | null | undefined,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            iteratee?: ValueIteratee<T>\n        ): T[];\n\n        /**\n         * @see _.unionBy\n         */\n        unionBy<T>(\n            arrays1: List<T> | null | undefined,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            arrays4: List<T> | null | undefined,\n            iteratee?: ValueIteratee<T>\n        ): T[];\n\n        /**\n         * @see _.unionBy\n         */\n        unionBy<T>(\n            arrays1: List<T> | null | undefined,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            arrays4: List<T> | null | undefined,\n            arrays5: List<T> | null | undefined,\n            ...iteratee: Array<ValueIteratee<T> | List<T> | null | undefined>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.unionBy\n         */\n        unionBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ValueIteratee<T>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.unionBy\n         */\n        unionBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            iteratee?: ValueIteratee<T>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.unionBy\n         */\n        unionBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            iteratee?: ValueIteratee<T>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.unionBy\n         */\n        unionBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            arrays4: List<T> | null | undefined,\n            iteratee?: ValueIteratee<T>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.unionBy\n         */\n        unionBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            arrays4: List<T> | null | undefined,\n            arrays5: List<T> | null | undefined,\n            ...iteratee: Array<ValueIteratee<T> | List<T> | null | undefined>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.unionBy\n         */\n        unionBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ValueIteratee<T>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.unionBy\n         */\n        unionBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            iteratee?: ValueIteratee<T>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.unionBy\n         */\n        unionBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            iteratee?: ValueIteratee<T>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.unionBy\n         */\n        unionBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            arrays4: List<T> | null | undefined,\n            iteratee?: ValueIteratee<T>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.unionBy\n         */\n        unionBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            arrays4: List<T> | null | undefined,\n            arrays5: List<T> | null | undefined,\n            ...iteratee: Array<ValueIteratee<T> | List<T> | null | undefined>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.unionWith\n    interface LoDashStatic {\n        /**\n         * This method is like `_.union` except that it accepts `comparator` which\n         * is invoked to compare elements of `arrays`. The comparator is invoked\n         * with two arguments: (arrVal, othVal).\n         *\n         * @category Array\n         * @param [arrays] The arrays to inspect.\n         * @param [comparator] The comparator invoked per element.\n         * @returns Returns the new array of combined values.\n         * @example\n         *\n         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n         *\n         * _.unionWith(objects, others, _.isEqual);\n         * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n         */\n        unionWith<T>(\n            arrays: List<T> | null | undefined,\n            comparator?: Comparator<T>\n        ): T[];\n\n        /**\n         * @see _.unionBy\n         */\n        unionWith<T>(\n            arrays: List<T> | null | undefined,\n            arrays2: List<T> | null | undefined,\n            comparator?: Comparator<T>\n        ): T[];\n\n        /**\n         * @see _.unionWith\n         */\n        unionWith<T>(\n            arrays: List<T> | null | undefined,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            ...comparator: Array<Comparator<T> | List<T> | null | undefined>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.unionWith\n         */\n        unionWith<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            comparator?: Comparator<T>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.unionWith\n         */\n        unionWith<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            comparator?: Comparator<T>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.unionWith\n         */\n        unionWith<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            ...comparator: Array<Comparator<T> | List<T> | null | undefined>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.unionWith\n         */\n        unionWith<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            comparator?: Comparator<T>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.unionWith\n         */\n        unionWith<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            comparator?: Comparator<T>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.unionWith\n         */\n        unionWith<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            ...comparator: Array<Comparator<T> | List<T> | null | undefined>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.uniq\n    interface LoDashStatic {\n        /**\n         * Creates a duplicate-free version of an array, using\n         * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n         * for equality comparisons, in which only the first occurrence of each element\n         * is kept.\n         *\n         * @category Array\n         * @param array The array to inspect.\n         * @returns Returns the new duplicate free array.\n         * @example\n         *\n         * _.uniq([2, 1, 2]);\n         * // => [2, 1]\n         */\n        uniq<T>(\n            array: List<T> | null | undefined\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.uniq\n         */\n        uniq<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.uniq\n         */\n        uniq<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.uniqBy\n    interface LoDashStatic {\n        /**\n         * This method is like `_.uniq` except that it accepts `iteratee` which is\n         * invoked for each element in `array` to generate the criterion by which\n         * uniqueness is computed. The iteratee is invoked with one argument: (value).\n         *\n         * @category Array\n         * @param array The array to inspect.\n         * @param [iteratee=_.identity] The iteratee invoked per element.\n         * @returns Returns the new duplicate free array.\n         * @example\n         *\n         * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n         * // => [2.1, 1.2]\n         *\n         * // using the `_.property` iteratee shorthand\n         * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n         * // => [{ 'x': 1 }, { 'x': 2 }]\n         */\n        uniqBy(\n            array: string | null | undefined,\n            iteratee: StringIterator<NotVoid>\n        ): string[];\n\n        /**\n         * @see _.uniqBy\n         */\n        uniqBy<T>(\n            array: List<T> | null | undefined,\n            iteratee: ListIteratee<T>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.uniqBy\n         */\n        uniqBy(\n            this: LoDashImplicitWrapper<string | null | undefined>,\n            iteratee: StringIterator<NotVoid>\n        ): LoDashImplicitWrapper<string[]>;\n\n        /**\n         * @see _.uniqBy\n         */\n        uniqBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee: ListIteratee<T>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.uniqBy\n         */\n        uniqBy(\n            this: LoDashExplicitWrapper<string | null | undefined>,\n            iteratee: StringIterator<NotVoid>\n        ): LoDashExplicitWrapper<string[]>;\n\n        /**\n         * @see _.uniqBy\n         */\n        uniqBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee: ListIteratee<T>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.uniqWith\n    interface LoDashStatic {\n        /**\n         * This method is like `_.uniq` except that it accepts `comparator` which\n         * is invoked to compare elements of `array`. The comparator is invoked with\n         * two arguments: (arrVal, othVal).\n         *\n         * @category Array\n         * @param array The array to inspect.\n         * @param [comparator] The comparator invoked per element.\n         * @returns Returns the new duplicate free array.\n         * @example\n         *\n         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 },  { 'x': 1, 'y': 2 }];\n         *\n         * _.uniqWith(objects, _.isEqual);\n         * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]\n         */\n        uniqWith<T>(\n            array: List<T> | null | undefined,\n            comparator?: Comparator<T>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.uniqWith\n         */\n        uniqWith<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            comparator?: Comparator<T>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.uniqWith\n         */\n        uniqWith<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            comparator?: Comparator<T>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.sortedUniq\n    interface LoDashStatic {\n        /**\n         * This method is like `_.uniq` except that it's designed and optimized\n         * for sorted arrays.\n         *\n         * @category Array\n         * @param array The array to inspect.\n         * @returns Returns the new duplicate free array.\n         * @example\n         *\n         * _.sortedUniq([1, 1, 2]);\n         * // => [1, 2]\n         */\n        sortedUniq<T>(\n            array: List<T> | null | undefined\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.sortedUniq\n         */\n        sortedUniq<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.sortedUniq\n         */\n        sortedUniq<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.sortedUniqBy\n    interface LoDashStatic {\n        /**\n         * This method is like `_.uniqBy` except that it's designed and optimized\n         * for sorted arrays.\n         *\n         * @category Array\n         * @param array The array to inspect.\n         * @param [iteratee] The iteratee invoked per element.\n         * @returns Returns the new duplicate free array.\n         * @example\n         *\n         * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);\n         * // => [1.1, 2.2]\n         */\n        sortedUniqBy(\n            array: string | null | undefined,\n            iteratee: StringIterator<NotVoid>\n        ): string[];\n\n        /**\n         * @see _.sortedUniqBy\n         */\n        sortedUniqBy<T>(\n            array: List<T> | null | undefined,\n            iteratee: ListIteratee<T>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.sortedUniqBy\n         */\n        sortedUniqBy(\n            this: LoDashImplicitWrapper<string | null | undefined>,\n            iteratee: StringIterator<NotVoid>\n        ): LoDashImplicitWrapper<string[]>;\n\n        /**\n         * @see _.sortedUniqBy\n         */\n        sortedUniqBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee: ListIteratee<T>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.sortedUniqBy\n         */\n        sortedUniqBy(\n            this: LoDashExplicitWrapper<string | null | undefined>,\n            iteratee: StringIterator<NotVoid>\n        ): LoDashExplicitWrapper<string[]>;\n\n        /**\n         * @see _.sortedUniqBy\n         */\n        sortedUniqBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee: ListIteratee<T>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.unzip\n    interface LoDashStatic {\n        /**\n         * This method is like _.zip except that it accepts an array of grouped elements and creates an array\n         * regrouping the elements to their pre-zip configuration.\n         *\n         * @param array The array of grouped elements to process.\n         * @return Returns the new array of regrouped elements.\n         */\n        unzip<T>(array: T[][] | List<List<T>> | null | undefined): T[][];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.unzip\n         */\n        unzip<T>(this: LoDashImplicitWrapper<T[][] | List<List<T>> | null | undefined>): LoDashImplicitWrapper<T[][]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.unzip\n         */\n        unzip<T>(this: LoDashExplicitWrapper<T[][] | List<List<T>> | null | undefined>): LoDashExplicitWrapper<T[][]>;\n    }\n\n    //_.unzipWith\n    interface LoDashStatic {\n        /**\n         * This method is like _.unzip except that it accepts an iteratee to specify how regrouped values should be\n         * combined. The iteratee is bound to thisArg and invoked with four arguments: (accumulator, value, index,\n         * group).\n         *\n         * @param array The array of grouped elements to process.\n         * @param iteratee The function to combine regrouped values.\n         * @param thisArg The this binding of iteratee.\n         * @return Returns the new array of regrouped elements.\n         */\n        unzipWith<T, TResult>(\n            array: List<List<T>> | null | undefined,\n            iteratee: (...values: T[]) => TResult\n        ): TResult[];\n\n        /**\n         * @see _.unzipWith\n         */\n        unzipWith<T>(\n            array: List<List<T>> | null | undefined\n        ): T[][];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.unzipWith\n         */\n        unzipWith<T, TResult>(\n            this: LoDashImplicitWrapper<List<List<T>> | null | undefined>,\n            iteratee: (...values: T[]) => TResult\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.unzipWith\n         */\n        unzipWith<T>(\n            this: LoDashImplicitWrapper<List<List<T>> | null | undefined>\n        ): LoDashImplicitWrapper<T[][]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.unzipWith\n         */\n        unzipWith<T, TResult>(\n            this: LoDashExplicitWrapper<List<List<T>> | null | undefined>,\n            iteratee: (...values: T[]) => TResult\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.unzipWith\n         */\n        unzipWith<T>(\n            this: LoDashExplicitWrapper<List<List<T>> | null | undefined>\n        ): LoDashExplicitWrapper<T[][]>;\n    }\n\n    //_.without\n    interface LoDashStatic {\n        /**\n         * Creates an array excluding all provided values using SameValueZero for equality comparisons.\n         *\n         * @param array The array to filter.\n         * @param values The values to exclude.\n         * @return Returns the new array of filtered values.\n         */\n        without<T>(\n            array: List<T> | null | undefined,\n            ...values: T[]\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.without\n         */\n        without<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            ...values: T[]\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.without\n         */\n        without<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            ...values: T[]\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.xor\n    interface LoDashStatic {\n        /**\n         * Creates an array of unique values that is the symmetric difference of the provided arrays.\n         *\n         * @param arrays The arrays to inspect.\n         * @return Returns the new array of values.\n         */\n        xor<T>(...arrays: Array<List<T> | null | undefined>): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.xor\n         */\n        xor<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            ...arrays: Array<List<T> | null | undefined>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.xor\n         */\n        xor<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            ...arrays: Array<List<T> | null | undefined>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.xorBy\n    interface LoDashStatic {\n        /**\n         * This method is like `_.xor` except that it accepts `iteratee` which is\n         * invoked for each element of each `arrays` to generate the criterion by which\n         * uniqueness is computed. The iteratee is invoked with one argument: (value).\n         *\n         * @category Array\n         * @param [arrays] The arrays to inspect.\n         * @param [iteratee=_.identity] The iteratee invoked per element.\n         * @returns Returns the new array of values.\n         * @example\n         *\n         * _.xorBy([2.1, 1.2], [4.3, 2.4], Math.floor);\n         * // => [1.2, 4.3]\n         *\n         * // using the `_.property` iteratee shorthand\n         * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n         * // => [{ 'x': 2 }]\n         */\n        xorBy<T>(\n            arrays: List<T> | null | undefined,\n            iteratee?: ValueIteratee<T>\n        ): T[];\n\n        /**\n         * @see _.xorBy\n         */\n        xorBy<T>(\n            arrays: List<T> | null | undefined,\n            arrays2: List<T> | null | undefined,\n            iteratee?: ValueIteratee<T>\n        ): T[];\n\n        /**\n         * @see _.xorBy\n         */\n        xorBy<T>(\n            arrays: List<T> | null | undefined,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            ...iteratee: Array<ValueIteratee<T> | List<T> | null | undefined>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.xor\n         */\n        xorBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ValueIteratee<T>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.xorBy\n         */\n        xorBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            iteratee?: ValueIteratee<T>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.xorBy\n         */\n        xorBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            ...iteratee: Array<ValueIteratee<T> | List<T> | null | undefined>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.xorBy\n         */\n        xorBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ValueIteratee<T>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.xorBy\n         */\n        xorBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            iteratee?: ValueIteratee<T>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.xorBy\n         */\n        xorBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            ...iteratee: Array<ValueIteratee<T> | List<T> | null | undefined>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.xorWith\n    interface LoDashStatic {\n        /**\n         * This method is like `_.xor` except that it accepts `comparator` which is\n         * invoked to compare elements of `arrays`. The comparator is invoked with\n         * two arguments: (arrVal, othVal).\n         *\n         * @category Array\n         * @param [arrays] The arrays to inspect.\n         * @param [comparator] The comparator invoked per element.\n         * @returns Returns the new array of values.\n         * @example\n         *\n         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n         *\n         * _.xorWith(objects, others, _.isEqual);\n         * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n         */\n        xorWith<T>(\n            arrays: List<T> | null | undefined,\n            comparator?: Comparator<T>\n        ): T[];\n\n        /**\n         * @see _.xorWith\n         */\n        xorWith<T>(\n            arrays: List<T> | null | undefined,\n            arrays2: List<T> | null | undefined,\n            comparator?: Comparator<T>\n        ): T[];\n\n        /**\n         * @see _.xorWith\n         */\n        xorWith<T>(\n            arrays: List<T> | null | undefined,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            ...comparator: Array<Comparator<T> | List<T> | null | undefined>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.xorWith\n         */\n        xorWith<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            comparator?: Comparator<T>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.xorWith\n         */\n        xorWith<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            comparator?: Comparator<T>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.xorWith\n         */\n        xorWith<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            ...comparator: Array<Comparator<T> | List<T> | null | undefined>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.xorWith\n         */\n        xorWith<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            comparator?: Comparator<T>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.xorWith\n         */\n        xorWith<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            comparator?: Comparator<T>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.xorWith\n         */\n        xorWith<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            ...comparator: Array<Comparator<T> | List<T> | null | undefined>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.zip\n    interface LoDashStatic {\n        /**\n         * Creates an array of grouped elements, the first of which contains the first elements of the given arrays,\n         * the second of which contains the second elements of the given arrays, and so on.\n         *\n         * @param arrays The arrays to process.\n         * @return Returns the new array of grouped elements.\n         */\n        zip<T>(...arrays: Array<List<T> | null | undefined>): T[][];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.zip\n         */\n        zip<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            ...arrays: Array<List<T> | null | undefined>\n        ): LoDashImplicitWrapper<T[][]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.zip\n         */\n        zip<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            ...arrays: Array<List<T> | null | undefined>\n        ): LoDashExplicitWrapper<T[][]>;\n    }\n\n    //_.zipObject\n    interface LoDashStatic {\n        /**\n         * This method is like _.fromPairs except that it accepts two arrays, one of property\n         * identifiers and one of corresponding values.\n         *\n         * @param props The property names.\n         * @param values The property values.\n         * @return Returns the new object.\n         */\n        zipObject<T>(\n            props: List<PropertyName>,\n            values: List<T>\n        ): Dictionary<T>;\n\n        /**\n         * @see _.zipObject\n         */\n        zipObject(\n            props?: List<PropertyName>\n        ): Dictionary<undefined>;\n\n        /**\n         * This method is like _.zipObject except that it supports property paths.\n         *\n         * @param paths The property names.\n         * @param values The property values.\n         * @return Returns the new object.\n         */\n        zipObjectDeep(\n            paths?: List<PropertyPath>,\n            values?: List<any>\n        ): object;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.zipObject\n         */\n        zipObject<T>(\n            this: LoDashImplicitWrapper<List<PropertyName>>,\n            values: List<T>\n        ): LoDashImplicitWrapper<Dictionary<T>>;\n\n        /**\n         * @see _.zipObject\n         */\n        zipObject(\n            this: LoDashImplicitWrapper<List<PropertyName>>\n        ): LoDashImplicitWrapper<Dictionary<undefined>>;\n\n        /**\n         * @see _.zipObjectDeep\n         */\n        zipObjectDeep(\n            this: LoDashImplicitWrapper<List<PropertyPath>>,\n            values?: List<any>\n        ): LoDashImplicitWrapper<object>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.zipObject\n         */\n        zipObject<T>(\n            this: LoDashExplicitWrapper<List<PropertyName>>,\n            values: List<T>\n        ): LoDashExplicitWrapper<Dictionary<T>>;\n\n        /**\n         * @see _.zipObject\n         */\n        zipObject(\n            this: LoDashExplicitWrapper<List<PropertyName>>\n        ): LoDashExplicitWrapper<Dictionary<undefined>>;\n\n        /**\n         * @see _.zipObjectDeep\n         */\n        zipObjectDeep(\n            this: LoDashExplicitWrapper<List<PropertyPath>>,\n            values?: List<any>\n        ): LoDashExplicitWrapper<object>;\n    }\n\n    //_.zipWith\n    interface LoDashStatic {\n        /**\n         * This method is like _.zip except that it accepts an iteratee to specify how grouped values should be\n         * combined. The iteratee is bound to thisArg and invoked with four arguments: (accumulator, value, index,\n         * group).\n         * @param [arrays] The arrays to process.\n         * @param [iteratee] The function to combine grouped values.\n         * @param [thisArg] The `this` binding of `iteratee`.\n         * @return Returns the new array of grouped elements.\n         */\n        zipWith<T>(\n            ...arrays: Array<List<T> | null | undefined>\n        ): T[][];\n\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T, TResult>(\n            arrays: List<T> | null | undefined,\n            iteratee: (value1: T) => TResult\n        ): TResult[];\n\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T, TResult>(\n            arrays: List<T> | null | undefined,\n            arrays2: List<T> | null | undefined,\n            iteratee: (value1: T, value2: T) => TResult\n        ): TResult[];\n\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T, TResult>(\n            arrays: List<T> | null | undefined,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            iteratee: (value1: T, value2: T, value3: T) => TResult\n        ): TResult[];\n\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T, TResult>(\n            arrays: List<T> | null | undefined,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            arrays4: List<T> | null | undefined,\n            iteratee: (value1: T, value2: T, value3: T, value4: T) => TResult\n        ): TResult[];\n\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T, TResult>(\n            arrays: List<T> | null | undefined,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            arrays4: List<T> | null | undefined,\n            arrays5: List<T> | null | undefined,\n            iteratee: (value1: T, value2: T, value3: T, value4: T, value5: T) => TResult\n        ): TResult[];\n\n        zipWith<T, TResult>(\n            ...iteratee: Array<((...group: T[]) => TResult) | List<T> | null | undefined>\n        ): TResult[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            ...arrays: Array<List<T> | null | undefined>\n        ): LoDashImplicitWrapper<T[][]>;\n\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T, TResult>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee: (value1: T) => TResult\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T, TResult>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            iteratee: (value1: T, value2: T) => TResult\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T, TResult>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            iteratee: (value1: T, value2: T, value3: T) => TResult\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T, TResult>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            arrays4: List<T> | null | undefined,\n            iteratee: (value1: T, value2: T, value3: T, value4: T) => TResult\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T, TResult>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            arrays4: List<T> | null | undefined,\n            arrays5: List<T> | null | undefined,\n            ...iteratee: Array<((...group: T[]) => TResult) | List<T> | null | undefined>\n        ): LoDashImplicitWrapper<TResult[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            ...arrays: Array<List<T> | null | undefined>\n        ): LoDashExplicitWrapper<T[][]>;\n\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T, TResult>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee: (value1: T) => TResult\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T, TResult>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            iteratee: (value1: T, value2: T) => TResult\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T, TResult>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            iteratee: (value1: T, value2: T, value3: T) => TResult\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T, TResult>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            arrays4: List<T> | null | undefined,\n            iteratee: (value1: T, value2: T, value3: T, value4: T) => TResult\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.zipWith\n         */\n        zipWith<T, TResult>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            arrays2: List<T> | null | undefined,\n            arrays3: List<T> | null | undefined,\n            arrays4: List<T> | null | undefined,\n            arrays5: List<T> | null | undefined,\n            ...iteratee: Array<((...group: T[]) => TResult) | List<T> | null | undefined>\n        ): LoDashExplicitWrapper<TResult[]>;\n    }\n\n    /*********\n     * Chain *\n     *********/\n\n    //_.chain\n    interface LoDashStatic {\n        /**\n         * Creates a lodash object that wraps value with explicit method chaining enabled.\n         *\n         * @param value The value to wrap.\n         * @return Returns the new lodash wrapper instance.\n         */\n        chain<T>(value: T): LoDashExplicitWrapper<T>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.chain\n         */\n        chain(): LoDashExplicitWrapper<TValue>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.chain\n         */\n        chain(): this;\n    }\n\n    //_.tap\n    interface LoDashStatic {\n        /**\n         * This method invokes interceptor and returns value. The interceptor is bound to thisArg and invoked with one\n         * argument; (value). The purpose of this method is to \"tap into\" a method chain in order to perform operations\n         * on intermediate results within the chain.\n         *\n         * @param value The value to provide to interceptor.\n         * @param interceptor The function to invoke.\n         * @parem thisArg The this binding of interceptor.\n         * @return Returns value.\n         **/\n        tap<T>(\n            value: T,\n            interceptor: (value: T) => void\n        ): T;\n    }\n\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.tap\n         */\n        tap(\n            interceptor: (value: TValue) => void\n        ): this;\n    }\n\n    //_.thru\n    interface LoDashStatic {\n        /**\n         * This method is like _.tap except that it returns the result of interceptor.\n         *\n         * @param value The value to provide to interceptor.\n         * @param interceptor The function to invoke.\n         * @param thisArg The this binding of interceptor.\n         * @return Returns the result of interceptor.\n         */\n        thru<T, TResult>(\n            value: T,\n            interceptor: (value: T) => TResult\n        ): TResult;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.thru\n         */\n        thru<TResult>(interceptor: (value: TValue) => TResult): LoDashImplicitWrapper<TResult>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.thru\n         */\n        thru<TResult>(interceptor: (value: TValue) => TResult): LoDashExplicitWrapper<TResult>;\n    }\n\n    //_.prototype.commit\n    interface LoDashWrapper<TValue> {\n        /**\n         * Executes the chained sequence and returns the wrapped result.\n         *\n         * @return Returns the new lodash wrapper instance.\n         */\n        commit(): this;\n    }\n\n    //_.prototype.plant\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * Creates a clone of the chained sequence planting value as the wrapped value.\n         * @param value The value to plant as the wrapped value.\n         * @return Returns the new lodash wrapper instance.\n         */\n        plant<T>(value: T): LoDashImplicitWrapper<T>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.plant\n         */\n        plant<T>(value: T): LoDashExplicitWrapper<T>;\n    }\n\n    //_.prototype.toJSON\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.value\n         */\n        toJSON(): TValue;\n    }\n\n    //_.prototype.toString\n    interface LoDashWrapper<TValue> {\n        /**\n         * Produces the result of coercing the unwrapped value to a string.\n         *\n         * @return Returns the coerced string value.\n         */\n        toString(): string;\n    }\n\n    //_.prototype.value\n    interface LoDashWrapper<TValue> {\n        /**\n         * Executes the chained sequence to extract the unwrapped value.\n         *\n         * @alias _.toJSON, _.valueOf\n         *\n         * @return Returns the resolved unwrapped value.\n         */\n        value(): TValue;\n    }\n\n    //_.valueOf\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.value\n         */\n        valueOf(): TValue;\n    }\n\n    /**************\n     * Collection *\n     **************/\n\n    //_.at\n    interface LoDashStatic {\n        /**\n         * Creates an array of elements corresponding to the given keys, or indexes, of collection. Keys may be\n         * specified as individual arguments or as arrays of keys.\n         *\n         * @param object The object to iterate over.\n         * @param props The property names or indexes of elements to pick, specified individually or in arrays.\n         * @return Returns the new array of picked elements.\n         */\n        at<T>(\n            object: List<T> | Dictionary<T> | null | undefined,\n            ...props: PropertyPath[]\n        ): T[];\n\n        /**\n         * @see _.at\n         */\n        at<T extends object>(\n            object: T | null | undefined,\n            ...props: Array<Many<keyof T>>\n        ): Array<T[keyof T]>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.at\n         */\n        at<T>(\n            this: LoDashImplicitWrapper<List<T> | Dictionary<T> | null | undefined>,\n            ...props: PropertyPath[]\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.at\n         */\n        at<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            ...props: Array<Many<keyof T>>\n        ): LoDashImplicitWrapper<Array<T[keyof T]>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.at\n         */\n        at<T>(\n            this: LoDashExplicitWrapper<List<T> | Dictionary<T> | null | undefined>,\n            ...props: PropertyPath[]\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.at\n         */\n        at<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            ...props: Array<Many<keyof T>>\n        ): LoDashExplicitWrapper<Array<T[keyof T]>>;\n    }\n\n    //_.countBy\n    interface LoDashStatic {\n        /**\n         * Creates an object composed of keys generated from the results of running each element of collection through\n         * iteratee. The corresponding value of each key is the number of times the key was returned by iteratee. The\n         * iteratee is bound to thisArg and invoked with three arguments:\n         * (value, index|key, collection).\n         *\n         * If a property name is provided for iteratee the created _.property style callback returns the property\n         * value of the given element.\n         *\n         * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for\n         * elements that have a matching property value, else false.\n         *\n         * If an object is provided for iteratee the created _.matches style callback returns true for elements that\n         * have the properties of the given object, else false.\n         *\n         * @param collection The collection to iterate over.\n         * @param iteratee The function invoked per iteration.\n         * @param thisArg The this binding of iteratee.\n         * @return Returns the composed aggregate object.\n         */\n        countBy<T>(\n            collection: string | null | undefined,\n            iteratee?: StringIterator<T>\n        ): Dictionary<number>;\n\n        /**\n         * @see _.countBy\n         */\n        countBy<T>(\n            collection: List<T> | null | undefined,\n            iteratee?: ListIteratee<T>\n        ): Dictionary<number>;\n\n        /**\n         * @see _.countBy\n         */\n        countBy<T>(\n            collection: NumericDictionary<T> | null | undefined,\n            iteratee?: NumericDictionaryIteratee<T>\n        ): Dictionary<number>;\n\n        /**\n         * @see _.countBy\n         */\n        countBy<T extends object>(\n            collection: T | null | undefined,\n            iteratee?: ObjectIteratee<T>\n        ): Dictionary<number>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.countBy\n         */\n        countBy<T>(\n            this: LoDashImplicitWrapper<string | null | undefined>,\n            iteratee?: StringIterator<T>\n        ): LoDashImplicitWrapper<Dictionary<number>>;\n\n        /**\n         * @see _.countBy\n         */\n        countBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ListIteratee<T>\n        ): LoDashImplicitWrapper<Dictionary<number>>;\n\n        /**\n         * @see _.countBy\n         */\n        countBy<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            iteratee?: ObjectIteratee<T>\n        ): LoDashImplicitWrapper<Dictionary<number>>;\n\n        /**\n         * @see _.countBy\n         */\n        countBy<T>(\n            this: LoDashImplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratee?: NumericDictionaryIteratee<T>\n        ): LoDashImplicitWrapper<Dictionary<number>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.countBy\n         */\n        countBy<T>(\n            this: LoDashExplicitWrapper<string | null | undefined>,\n            iteratee?: StringIterator<T>\n        ): LoDashExplicitWrapper<Dictionary<number>>;\n\n        /**\n         * @see _.countBy\n         */\n        countBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ListIteratee<T>\n        ): LoDashExplicitWrapper<Dictionary<number>>;\n\n        /**\n         * @see _.countBy\n         */\n        countBy<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            iteratee?: ObjectIteratee<T>\n        ): LoDashExplicitWrapper<Dictionary<number>>;\n\n        /**\n         * @see _.countBy\n         */\n        countBy<T>(\n            this: LoDashExplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratee?: NumericDictionaryIteratee<T>\n        ): LoDashExplicitWrapper<Dictionary<number>>;\n    }\n\n    //_.each\n    interface LoDashStatic {\n        each: typeof _.forEach; // tslint:disable-line:no-unnecessary-qualifier\n    }\n\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.forEach\n         */\n        each<T>(\n            this: LoDashWrapper<T[] | null | undefined>,\n            iteratee?: ArrayIterator<T, any>\n        ): this;\n\n        /**\n         * @see _.forEach\n         */\n        each(\n            this: LoDashWrapper<string | null | undefined>,\n            iteratee?: StringIterator<any>\n        ): this;\n\n        /**\n         * @see _.forEach\n         */\n        each<T>(\n            this: LoDashWrapper<List<T> | null | undefined>,\n            iteratee?: ListIterator<T, any>\n        ): this;\n\n        /**\n         * @see _.forEach\n         */\n        each<T extends object>(\n            this: LoDashWrapper<T | null | undefined>,\n            iteratee?: ObjectIterator<T, any>\n        ): this;\n    }\n\n    //_.eachRight\n    interface LoDashStatic {\n        eachRight: typeof _.forEachRight; // tslint:disable-line:no-unnecessary-qualifier\n    }\n\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.forEachRight\n         */\n        eachRight<T>(\n            this: LoDashWrapper<T[] | null | undefined>,\n            iteratee?: ArrayIterator<T, any>\n        ): this;\n\n        /**\n         * @see _.forEachRight\n         */\n        eachRight(\n            this: LoDashWrapper<string | null | undefined>,\n            iteratee?: StringIterator<any>\n        ): this;\n\n        /**\n         * @see _.forEachRight\n         */\n        eachRight<T>(\n            this: LoDashWrapper<List<T> | null | undefined>,\n            iteratee?: ListIterator<T, any>\n        ): this;\n\n        /**\n         * @see _.forEachRight\n         */\n        eachRight<T extends object>(\n            this: LoDashWrapper<T | null | undefined>,\n            iteratee?: ObjectIterator<T, any>\n        ): this;\n    }\n\n    //_.every\n    interface LoDashStatic {\n        /**\n         * Checks if predicate returns truthy for all elements of collection. Iteration is stopped once predicate\n         * returns falsey. The predicate is invoked with three arguments: (value, index|key, collection).\n         *\n         * @param collection The collection to iterate over.\n         * @param predicate The function invoked per iteration.\n         * @return Returns true if all elements pass the predicate check, else false.\n         */\n        every<T>(\n            collection: List<T> | null | undefined,\n            predicate?: ListIterateeCustom<T, boolean>\n        ): boolean;\n\n        /**\n         * @see _.every\n         */\n        every<T>(\n            collection: NumericDictionary<T> | null | undefined,\n            predicate?: NumericDictionaryIterateeCustom<T, boolean>\n        ): boolean;\n\n        /**\n         * @see _.every\n         */\n        every<T extends object>(\n            collection: T | null | undefined,\n            predicate?: ObjectIterateeCustom<T, boolean>\n        ): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.every\n         */\n        every<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIterateeCustom<T, boolean>\n        ): boolean;\n\n        /**\n         * @see _.every\n         */\n        every<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            predicate?: ObjectIterateeCustom<T, boolean>\n        ): boolean;\n\n        /**\n         * @see _.every\n         */\n        every<T>(\n            this: LoDashImplicitWrapper<NumericDictionary<T> | null | undefined>,\n            predicate?: NumericDictionaryIterateeCustom<T, boolean>\n        ): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.every\n         */\n        every<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIterateeCustom<T, boolean>\n        ): LoDashExplicitWrapper<boolean>;\n\n        /**\n         * @see _.every\n         */\n        every<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            predicate?: ObjectIterateeCustom<T, boolean>\n        ): LoDashExplicitWrapper<boolean>;\n\n        /**\n         * @see _.every\n         */\n        every<T>(\n            this: LoDashExplicitWrapper<NumericDictionary<T> | null | undefined>,\n            predicate?: NumericDictionaryIterateeCustom<T, boolean>\n        ): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.filter\n    interface LoDashStatic {\n        /**\n         * Iterates over elements of collection, returning an array of all elements predicate returns truthy for. The\n         * predicate is bound to thisArg and invoked with three arguments: (value, index|key, collection).\n         *\n         * If a property name is provided for predicate the created _.property style callback returns the property\n         * value of the given element.\n         *\n         * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for\n         * elements that have a matching property value, else false.\n         *\n         * If an object is provided for predicate the created _.matches style callback returns true for elements that\n         * have the properties of the given object, else false.\n         *\n         * @param collection The collection to iterate over.\n         * @param predicate The function invoked per iteration.\n         * @param thisArg The this binding of predicate.\n         * @return Returns the new filtered array.\n         */\n        filter(\n            collection: string | null | undefined,\n            predicate?: StringIterator<boolean>\n        ): string[];\n\n        /**\n         * @see _.filter\n         */\n        filter<T, S extends T>(\n            collection: List<T> | null | undefined,\n            predicate: ListIteratorTypeGuard<T, S>\n        ): S[];\n\n        /**\n         * @see _.filter\n         */\n        filter<T>(\n            collection: List<T> | null | undefined,\n            predicate?: ListIterateeCustom<T, boolean>\n        ): T[];\n\n        /**\n         * @see _.filter\n         */\n        filter<T extends object, S extends T[keyof T]>(\n            collection: T | null | undefined,\n            predicate: ObjectIteratorTypeGuard<T, S>\n        ): S[];\n\n        /**\n         * @see _.filter\n         */\n        filter<T extends object>(\n            collection: T | null | undefined,\n            predicate?: ObjectIterateeCustom<T, boolean>\n        ): Array<T[keyof T]>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.filter\n         */\n        filter(\n            this: LoDashImplicitWrapper<string | null | undefined>,\n            predicate?: StringIterator<boolean>\n        ): LoDashImplicitWrapper<string[]>;\n\n        /**\n         * @see _.filter\n         */\n        filter<T, S extends T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            predicate: ListIteratorTypeGuard<T, S>\n        ): LoDashImplicitWrapper<S[]>;\n\n        /**\n         * @see _.filter\n         */\n        filter<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIterateeCustom<T, boolean>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.filter\n         */\n        filter<T extends object, S extends T[keyof T]>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            predicate: ObjectIteratorTypeGuard<T, S>\n        ): LoDashImplicitWrapper<S[]>;\n\n        /**\n         * @see _.filter\n         */\n        filter<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            predicate?: ObjectIterateeCustom<T, boolean>\n        ): LoDashImplicitWrapper<Array<T[keyof T]>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.filter\n         */\n        filter(\n            this: LoDashExplicitWrapper<string | null | undefined>,\n            predicate?: StringIterator<boolean>\n        ): LoDashExplicitWrapper<string[]>;\n\n        /**\n         * @see _.filter\n         */\n        filter<T, S extends T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            predicate: ListIteratorTypeGuard<T, S>\n        ): LoDashExplicitWrapper<S[]>;\n\n        /**\n         * @see _.filter\n         */\n        filter<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIterateeCustom<T, boolean>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.filter\n         */\n        filter<T extends object, S extends T[keyof T]>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            predicate: ObjectIteratorTypeGuard<T, S>\n        ): LoDashExplicitWrapper<S[]>;\n\n        /**\n         * @see _.filter\n         */\n        filter<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            predicate?: ObjectIterateeCustom<T, boolean>\n        ): LoDashExplicitWrapper<Array<T[keyof T]>>;\n    }\n\n    //_.find\n    interface LoDashStatic {\n        /**\n         * Iterates over elements of collection, returning the first element predicate returns truthy for.\n         * The predicate is bound to thisArg and invoked with three arguments: (value, index|key, collection).\n         *\n         * If a property name is provided for predicate the created _.property style callback returns the property\n         * value of the given element.\n         *\n         * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for\n         * elements that have a matching property value, else false.\n         *\n         * If an object is provided for predicate the created _.matches style callback returns true for elements that\n         * have the properties of the given object, else false.\n         *\n         * @param collection The collection to search.\n         * @param predicate The function invoked per iteration.\n         * @param fromIndex The index to search from.\n         * @return Returns the matched element, else undefined.\n         */\n        find<T, S extends T>(\n            collection: List<T> | null | undefined,\n            predicate: ListIteratorTypeGuard<T, S>,\n            fromIndex?: number\n        ): S|undefined;\n\n        /**\n         * @see _.find\n         */\n        find<T>(\n            collection: List<T> | null | undefined,\n            predicate?: ListIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): T|undefined;\n\n        /**\n         * @see _.find\n         */\n        find<T extends object, S extends T[keyof T]>(\n            collection: T | null | undefined,\n            predicate: ObjectIteratorTypeGuard<T, S>,\n            fromIndex?: number\n        ): S|undefined;\n\n        /**\n         * @see _.find\n         */\n        find<T extends object>(\n            collection: T | null | undefined,\n            predicate?: ObjectIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): T[keyof T]|undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.find\n         */\n        find<T, S extends T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            predicate: ListIteratorTypeGuard<T, S>,\n            fromIndex?: number\n        ): S|undefined;\n\n        /**\n         * @see _.find\n         */\n        find<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): T|undefined;\n\n        /**\n         * @see _.find\n         */\n        find<T extends object, S extends T[keyof T]>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            predicate: ObjectIteratorTypeGuard<T, S>,\n            fromIndex?: number\n        ): S|undefined;\n\n        /**\n         * @see _.find\n         */\n        find<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            predicate?: ObjectIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): T[keyof T]|undefined;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.find\n         */\n        find<T, S extends T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            predicate: ListIteratorTypeGuard<T, S>,\n            fromIndex?: number\n        ): LoDashExplicitWrapper<S|undefined>;\n\n        /**\n         * @see _.find\n         */\n        find<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): LoDashExplicitWrapper<T|undefined>;\n\n        /**\n         * @see _.find\n         */\n        find<T extends object, S extends T[keyof T]>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            predicate: ObjectIteratorTypeGuard<T, S>,\n            fromIndex?: number\n        ): LoDashExplicitWrapper<S|undefined>;\n\n        /**\n         * @see _.find\n         */\n        find<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            predicate?: ObjectIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): LoDashExplicitWrapper<T[keyof T]|undefined>;\n    }\n\n    //_.findLast\n    interface LoDashStatic {\n        /**\n        * This method is like _.find except that it iterates over elements of a collection from\n        * right to left.\n        * @param collection Searches for a value in this list.\n        * @param predicate The function called per iteration.\n        * @param fromIndex The index to search from.\n        * @return The found element, else undefined.\n        **/\n        findLast<T, S extends T>(\n            collection: List<T> | null | undefined,\n            predicate: ListIteratorTypeGuard<T, S>,\n            fromIndex?: number\n        ): S|undefined;\n\n        /**\n         * @see _.findLast\n         */\n        findLast<T>(\n            collection: List<T> | null | undefined,\n            predicate?: ListIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): T|undefined;\n\n        /**\n         * @see _.findLast\n         */\n        findLast<T extends object, S extends T[keyof T]>(\n            collection: T | null | undefined,\n            predicate: ObjectIteratorTypeGuard<T, S>,\n            fromIndex?: number\n        ): S|undefined;\n\n        /**\n         * @see _.findLast\n         */\n        findLast<T extends object>(\n            collection: T | null | undefined,\n            predicate?: ObjectIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): T[keyof T]|undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.findLast\n         */\n        findLast<T, S extends T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            predicate: ListIteratorTypeGuard<T, S>,\n            fromIndex?: number\n        ): S | undefined;\n\n        /**\n         * @see _.findLast\n         */\n        findLast<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): T | undefined;\n\n        /**\n         * @see _.findLast\n         */\n        findLast<T extends object, S extends T[keyof T]>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            predicate: ObjectIteratorTypeGuard<T, S>,\n            fromIndex?: number\n        ): S|undefined;\n\n        /**\n         * @see _.findLast\n         */\n        findLast<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            predicate?: ObjectIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): T[keyof T]|undefined;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.findLast\n         */\n        findLast<T, S extends T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            predicate: ListIteratorTypeGuard<T, S>,\n            fromIndex?: number\n        ): LoDashExplicitWrapper<S | undefined>;\n\n        /**\n         * @see _.findLast\n         */\n        findLast<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): LoDashExplicitWrapper<T | undefined>;\n\n        /**\n         * @see _.findLast\n         */\n        findLast<T extends object, S extends T[keyof T]>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            predicate: ObjectIteratorTypeGuard<T, S>,\n            fromIndex?: number\n        ): LoDashExplicitWrapper<S|undefined>;\n\n        /**\n         * @see _.findLast\n         */\n        findLast<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            predicate?: ObjectIterateeCustom<T, boolean>,\n            fromIndex?: number\n        ): LoDashExplicitWrapper<T[keyof T]|undefined>;\n    }\n\n    //_.flatMap\n    interface LoDashStatic {\n        /**\n         * Creates an array of flattened values by running each element in collection through iteratee\n         * and concating its result to the other mapped values. The iteratee is invoked with three arguments:\n         * (value, index|key, collection).\n         *\n         * @param collection The collection to iterate over.\n         * @param iteratee The function invoked per iteration.\n         * @return Returns the new flattened array.\n         */\n        flatMap<T>(\n            collection: List<Many<T>> | Dictionary<Many<T>> | NumericDictionary<Many<T>> | null | undefined\n        ): T[];\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap(\n            collection: object | null | undefined\n        ): any[];\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap<T, TResult>(\n            collection: List<T> | null | undefined,\n            iteratee: ListIterator<T, Many<TResult>>\n        ): TResult[];\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap<T, TResult>(\n            collection: NumericDictionary<T> | null | undefined,\n            iteratee: NumericDictionaryIterator<T, Many<TResult>>\n        ): TResult[];\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap<T extends object, TResult>(\n            collection: T | null | undefined,\n            iteratee: ObjectIterator<T, Many<TResult>>\n        ): TResult[];\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap(\n            collection: object | null | undefined,\n            iteratee: string\n        ): any[];\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap(\n            collection: object | null | undefined,\n            iteratee: object\n        ): boolean[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.flatMap\n         */\n        flatMap<T>(this: LoDashImplicitWrapper<List<Many<T>> | Dictionary<Many<T>> | NumericDictionary<Many<T>> | null | undefined>): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap(): LoDashImplicitWrapper<any[]>;\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap<T, TResult>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee: ListIterator<T, Many<TResult>>\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap<T extends object, TResult>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            iteratee: ObjectIterator<T, Many<TResult>>\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap<T, TResult>(\n            this: LoDashImplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratee: NumericDictionaryIterator<T, Many<TResult>>\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap(\n            iteratee: string\n        ): LoDashImplicitWrapper<any[]>;\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap(\n            iteratee: object\n        ): LoDashImplicitWrapper<boolean[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.flatMap\n         */\n        flatMap<T>(this: LoDashExplicitWrapper<List<Many<T>> | Dictionary<Many<T>> | NumericDictionary<Many<T>> | null | undefined>): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap(): LoDashExplicitWrapper<any[]>;\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap<T, TResult>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee: ListIterator<T, Many<TResult>>\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap<T, TResult>(\n            this: LoDashExplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratee: NumericDictionaryIterator<T, Many<TResult>>\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap<T extends object, TResult>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            iteratee: ObjectIterator<T, Many<TResult>>\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap(\n            iteratee: string\n        ): LoDashExplicitWrapper<any[]>;\n\n        /**\n         * @see _.flatMap\n         */\n        flatMap(\n            iteratee: object\n        ): LoDashExplicitWrapper<boolean[]>;\n    }\n\n    //_.flatMapDeep\n    interface LoDashStatic {\n        /**\n         * This method is like `_.flatMap` except that it recursively flattens the\n         * mapped results.\n         *\n         * @since 4.7.0\n         * @category Collection\n         * @param collection The collection to iterate over.\n         * @param [iteratee=_.identity] The function invoked per iteration.\n         * @returns Returns the new flattened array.\n         * @example\n         *\n         * function duplicate(n) {\n         *   return [[[n, n]]];\n         * }\n         *\n         * _.flatMapDeep([1, 2], duplicate);\n         * // => [1, 1, 2, 2]\n         */\n        flatMapDeep<T>(\n            collection: List<ListOfRecursiveArraysOrValues<T> | T> | Dictionary<ListOfRecursiveArraysOrValues<T> | T> | NumericDictionary<ListOfRecursiveArraysOrValues<T> | T> | null | undefined\n        ): T[];\n\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep<T, TResult>(\n            collection: List<T> | null | undefined,\n            iteratee: ListIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>\n        ): TResult[];\n\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep<T, TResult>(\n            collection: NumericDictionary<T> | null | undefined,\n            iteratee: NumericDictionaryIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>\n        ): TResult[];\n\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep<T extends object, TResult>(\n            collection: T | null | undefined,\n            iteratee: ObjectIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>\n        ): TResult[];\n\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep(\n            collection: object | null | undefined,\n            iteratee: string\n        ): any[];\n\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep(\n            collection: object | null | undefined,\n            iteratee: object\n        ): boolean[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep<T>(\n            this: LoDashImplicitWrapper<List<ListOfRecursiveArraysOrValues<T> | T> | Dictionary<ListOfRecursiveArraysOrValues<T> | T> | NumericDictionary<ListOfRecursiveArraysOrValues<T> | T> | null | undefined>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep<T, TResult>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee: ListIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep<T, TResult>(\n            this: LoDashImplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratee: NumericDictionaryIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep<T extends object, TResult>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            iteratee: ObjectIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep(\n            this: LoDashImplicitWrapper<object | null | undefined>,\n            iteratee: string\n        ): LoDashImplicitWrapper<any[]>;\n\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep(\n            this: LoDashImplicitWrapper<object | null | undefined>,\n            iteratee: object\n        ): LoDashImplicitWrapper<boolean[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep<T>(\n            this: LoDashExplicitWrapper<List<ListOfRecursiveArraysOrValues<T> | T> | Dictionary<ListOfRecursiveArraysOrValues<T> | T> | NumericDictionary<ListOfRecursiveArraysOrValues<T> | T> | null | undefined>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep<T, TResult>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee: ListIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep<T, TResult>(\n            this: LoDashExplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratee: NumericDictionaryIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep<T extends object, TResult>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            iteratee: ObjectIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep(\n            this: LoDashExplicitWrapper<object | null | undefined>,\n            iteratee: string\n        ): LoDashExplicitWrapper<any[]>;\n\n        /**\n         * @see _.flatMapDeep\n         */\n        flatMapDeep(\n            this: LoDashExplicitWrapper<object | null | undefined>,\n            iteratee: object\n        ): LoDashExplicitWrapper<boolean[]>;\n    }\n\n    //_.flatMapDepth\n    interface LoDashStatic {\n        /**\n         * This method is like `_.flatMap` except that it recursively flattens the\n         * mapped results up to `depth` times.\n         *\n         * @since 4.7.0\n         * @category Collection\n         * @param collection The collection to iterate over.\n         * @param [iteratee=_.identity] The function invoked per iteration.\n         * @param [depth=1] The maximum recursion depth.\n         * @returns Returns the new flattened array.\n         * @example\n         *\n         * function duplicate(n) {\n         *   return [[[n, n]]];\n         * }\n         *\n         * _.flatMapDepth([1, 2], duplicate, 2);\n         * // => [[1, 1], [2, 2]]\n         */\n        flatMapDepth<T>(\n            collection: List<ListOfRecursiveArraysOrValues<T> | T> | Dictionary<ListOfRecursiveArraysOrValues<T> | T> | NumericDictionary<ListOfRecursiveArraysOrValues<T> | T> | null | undefined\n        ): T[];\n\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth<T, TResult>(\n            collection: List<T> | null | undefined,\n            iteratee: ListIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>,\n            depth?: number\n        ): TResult[];\n\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth<T, TResult>(\n            collection: NumericDictionary<T> | null | undefined,\n            iteratee: NumericDictionaryIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>,\n            depth?: number\n        ): TResult[];\n\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth<T extends object, TResult>(\n            collection: T | null | undefined,\n            iteratee: ObjectIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>,\n            depth?: number\n        ): TResult[];\n\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth(\n            collection: object | null | undefined,\n            iteratee: string,\n            depth?: number\n        ): any[];\n\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth(\n            collection: object | null | undefined,\n            iteratee: object,\n            depth?: number\n        ): boolean[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth<T>(\n            this: LoDashImplicitWrapper<List<ListOfRecursiveArraysOrValues<T> | T> | Dictionary<ListOfRecursiveArraysOrValues<T> | T> | NumericDictionary<ListOfRecursiveArraysOrValues<T> | T> | null | undefined>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth<T, TResult>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee: ListIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>,\n            depth?: number\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth<T, TResult>(\n            this: LoDashImplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratee: NumericDictionaryIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>,\n            depth?: number\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth<T extends object, TResult>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            iteratee: ObjectIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>,\n            depth?: number\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth(\n            this: LoDashImplicitWrapper<object | null | undefined>,\n            iteratee: string,\n            depth?: number\n        ): LoDashImplicitWrapper<any[]>;\n\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth(\n            this: LoDashImplicitWrapper<object | null | undefined>,\n            iteratee: object,\n            depth?: number\n        ): LoDashImplicitWrapper<boolean[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth<T>(\n            this: LoDashExplicitWrapper<List<ListOfRecursiveArraysOrValues<T> | T> | Dictionary<ListOfRecursiveArraysOrValues<T> | T> | NumericDictionary<ListOfRecursiveArraysOrValues<T> | T> | null | undefined>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth<T, TResult>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee: ListIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>,\n            depth?: number\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth<T, TResult>(\n            this: LoDashExplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratee: NumericDictionaryIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>,\n            depth?: number\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth<T extends object, TResult>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            iteratee: ObjectIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>,\n            depth?: number\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth(\n            this: LoDashExplicitWrapper<object | null | undefined>,\n            iteratee: string,\n            depth?: number\n        ): LoDashExplicitWrapper<any[]>;\n\n        /**\n         * @see _.flatMapDepth\n         */\n        flatMapDepth(\n            this: LoDashExplicitWrapper<object | null | undefined>,\n            iteratee: object,\n            depth?: number\n        ): LoDashExplicitWrapper<boolean[]>;\n    }\n\n    //_.forEach\n    interface LoDashStatic {\n        /**\n         * Iterates over elements of collection invoking iteratee for each element. The iteratee is bound to thisArg\n         * and invoked with three arguments:\n         * (value, index|key, collection). Iteratee functions may exit iteration early by explicitly returning false.\n         *\n         * Note: As with other \"Collections\" methods, objects with a \"length\" property are iterated like arrays. To\n         * avoid this behavior _.forIn or _.forOwn may be used for object iteration.\n         *\n         * @alias _.each\n         *\n         * @param collection The collection to iterate over.\n         * @param iteratee The function invoked per iteration.\n         * @param thisArg The this binding of iteratee.\n         */\n        forEach<T>(\n            collection: T[],\n            iteratee?: ArrayIterator<T, any>\n        ): T[];\n\n        /**\n         * @see _.forEach\n         */\n        forEach(\n            collection: string,\n            iteratee?: StringIterator<any>\n        ): string;\n\n        /**\n         * @see _.forEach\n         */\n        forEach<T>(\n            collection: List<T>,\n            iteratee?: ListIterator<T, any>\n        ): List<T>;\n\n        /**\n         * @see _.forEach\n         */\n        forEach<T extends object>(\n            collection: T,\n            iteratee?: ObjectIterator<T, any>\n        ): T;\n\n        /**\n         * @see _.forEach\n         */\n        forEach<T, TArray extends T[] | null | undefined>(\n            collection: TArray & (T[] | null | undefined),\n            iteratee?: ArrayIterator<T, any>\n        ): TArray;\n\n        /**\n         * @see _.forEach\n         */\n        forEach<TString extends string | null | undefined>(\n            collection: TString,\n            iteratee?: StringIterator<any>\n        ): TString;\n\n        /**\n         * @see _.forEach\n         */\n        forEach<T, TList extends List<T> | null | undefined>(\n            collection: TList & (List<T> | null | undefined),\n            iteratee?: ListIterator<T, any>\n        ): TList;\n\n        /**\n         * @see _.forEach\n         */\n        forEach<T extends object>(\n            collection: T | null | undefined,\n            iteratee?: ObjectIterator<T, any>\n        ): T | null | undefined;\n    }\n\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.forEach\n         */\n        forEach<T>(\n            this: LoDashWrapper<T[] | null | undefined>,\n            iteratee?: ArrayIterator<T, any>\n        ): this;\n\n        /**\n         * @see _.forEach\n         */\n        forEach(\n            this: LoDashWrapper<string | null | undefined>,\n            iteratee?: StringIterator<any>\n        ): this;\n\n        /**\n         * @see _.forEach\n         */\n        forEach<T>(\n            this: LoDashWrapper<List<T> | null | undefined>,\n            iteratee?: ListIterator<T, any>\n        ): this;\n\n        /**\n         * @see _.forEach\n         */\n        forEach<T extends object>(\n            this: LoDashWrapper<T | null | undefined>,\n            iteratee?: ObjectIterator<T, any>\n        ): this;\n    }\n\n    //_.forEachRight\n    interface LoDashStatic {\n        /**\n         * This method is like _.forEach except that it iterates over elements of collection from right to left.\n         *\n         * @alias _.eachRight\n         *\n         * @param collection The collection to iterate over.\n         * @param iteratee The function called per iteration.\n         * @param thisArg The this binding of callback.\n         */\n        forEachRight<T>(\n            collection: T[],\n            iteratee?: ArrayIterator<T, any>\n        ): T[];\n\n        /**\n         * @see _.forEachRight\n         */\n        forEachRight(\n            collection: string,\n            iteratee?: StringIterator<any>\n        ): string;\n\n        /**\n         * @see _.forEachRight\n         */\n        forEachRight<T>(\n            collection: List<T>,\n            iteratee?: ListIterator<T, any>\n        ): List<T>;\n\n        /**\n         * @see _.forEachRight\n         */\n        forEachRight<T extends object>(\n            collection: T,\n            iteratee?: ObjectIterator<T, any>\n        ): T;\n\n        /**\n         * @see _.forEachRight\n         */\n        forEachRight<T, TArray extends T[] | null | undefined>(\n            collection: TArray & (T[] | null | undefined),\n            iteratee?: ArrayIterator<T, any>\n        ): TArray;\n\n        /**\n         * @see _.forEachRight\n         */\n        forEachRight<TString extends string | null | undefined>(\n            collection: TString,\n            iteratee?: StringIterator<any>\n        ): TString;\n\n        /**\n         * @see _.forEachRight\n         */\n        forEachRight<T, TList extends List<T> | null | undefined>(\n            collection: TList & (List<T> | null | undefined),\n            iteratee?: ListIterator<T, any>\n        ): TList;\n\n        /**\n         * @see _.forEachRight\n         */\n        forEachRight<T extends object>(\n            collection: T | null | undefined,\n            iteratee?: ObjectIterator<T, any>\n        ): T | null | undefined;\n    }\n\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.forEachRight\n         */\n        forEachRight<T>(\n            this: LoDashWrapper<T[] | null | undefined>,\n            iteratee?: ArrayIterator<T, any>\n        ): this;\n\n        /**\n         * @see _.forEachRight\n         */\n        forEachRight(\n            this: LoDashWrapper<string | null | undefined>,\n            iteratee?: StringIterator<any>\n        ): this;\n\n        /**\n         * @see _.forEachRight\n         */\n        forEachRight<T>(\n            this: LoDashWrapper<List<T> | null | undefined>,\n            iteratee?: ListIterator<T, any>\n        ): this;\n\n        /**\n         * @see _.forEachRight\n         */\n        forEachRight<T extends object>(\n            this: LoDashWrapper<T | null | undefined>,\n            iteratee?: ObjectIterator<T, any>\n        ): this;\n    }\n\n    //_.groupBy\n    interface LoDashStatic {\n        /**\n         * Creates an object composed of keys generated from the results of running each element of collection through\n         * iteratee. The corresponding value of each key is an array of the elements responsible for generating the\n         * key. The iteratee is bound to thisArg and invoked with three arguments:\n         * (value, index|key, collection).\n         *\n         * If a property name is provided for iteratee the created _.property style callback returns the property\n         * value of the given element.\n         *\n         * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for\n         * elements that have a matching property value, else false.\n         *\n         * If an object is provided for iteratee the created _.matches style callback returns true for elements that\n         * have the properties of the given object, else false.\n         *\n         * @param collection The collection to iterate over.\n         * @param iteratee The function invoked per iteration.\n         * @param thisArg The this binding of iteratee.\n         * @return Returns the composed aggregate object.\n         */\n        groupBy(\n            collection: string | null | undefined,\n            iteratee?: StringIterator<NotVoid>\n        ): Dictionary<string[]>;\n\n        /**\n         * @see _.groupBy\n         */\n        groupBy<T>(\n            collection: List<T> | null | undefined,\n            iteratee?: ListIteratee<T>\n        ): Dictionary<T[]>;\n\n        /**\n         * @see _.groupBy\n         */\n        groupBy<T>(\n            collection: NumericDictionary<T> | null | undefined,\n            iteratee?: NumericDictionaryIteratee<T>\n        ): Dictionary<T[]>;\n\n        /**\n         * @see _.groupBy\n         */\n        groupBy<T extends object>(\n            collection: T | null | undefined,\n            iteratee?: ObjectIteratee<T>\n        ): Dictionary<Array<T[keyof T]>>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.groupBy\n         */\n        groupBy(\n            this: LoDashImplicitWrapper<string | null | undefined>,\n            iteratee?: StringIterator<NotVoid>\n        ): LoDashImplicitWrapper<Dictionary<string[]>>;\n\n        /**\n         * @see _.groupBy\n         */\n        groupBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ListIteratee<T>\n        ): LoDashImplicitWrapper<Dictionary<T[]>>;\n\n        /**\n         * @see _.groupBy\n         */\n        groupBy<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            iteratee?: ObjectIteratee<T>\n        ): LoDashImplicitWrapper<Dictionary<Array<T[keyof T]>>>;\n\n        /**\n         * @see _.groupBy\n         */\n        groupBy<T>(\n            this: LoDashImplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratee?: NumericDictionaryIteratee<T>\n        ): LoDashImplicitWrapper<Dictionary<T[]>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.groupBy\n         */\n        groupBy(\n            this: LoDashExplicitWrapper<string | null | undefined>,\n            iteratee?: StringIterator<NotVoid>\n        ): LoDashExplicitWrapper<Dictionary<string[]>>;\n\n        /**\n         * @see _.groupBy\n         */\n        groupBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ListIteratee<T>\n        ): LoDashExplicitWrapper<Dictionary<T[]>>;\n\n        /**\n         * @see _.groupBy\n         */\n        groupBy<T>(\n            this: LoDashExplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratee?: NumericDictionaryIteratee<T>\n        ): LoDashExplicitWrapper<Dictionary<T[]>>;\n\n        /**\n         * @see _.groupBy\n         */\n        groupBy<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            iteratee?: ObjectIteratee<T>\n        ): LoDashExplicitWrapper<Dictionary<Array<T[keyof T]>>>;\n    }\n\n    //_.includes\n    interface LoDashStatic {\n        /**\n         * Checks if target is in collection using SameValueZero for equality comparisons. If fromIndex is negative,\n         * itâs used as the offset from the end of collection.\n         *\n         * @param collection The collection to search.\n         * @param target The value to search for.\n         * @param fromIndex The index to search from.\n         * @return True if the target element is found, else false.\n         */\n        includes<T>(\n            collection: List<T>|Dictionary<T> | null | undefined,\n            target: T,\n            fromIndex?: number\n        ): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.includes\n         */\n        includes<T>(\n            this: LoDashImplicitWrapper<List<T> | Dictionary<T> | null | undefined>,\n            target: T,\n            fromIndex?: number\n        ): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.includes\n         */\n        includes<T>(\n            this: LoDashExplicitWrapper<List<T> | Dictionary<T> | null | undefined>,\n            target: T,\n            fromIndex?: number\n        ): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.keyBy\n    interface LoDashStatic {\n        /**\n         * Creates an object composed of keys generated from the results of running each element of collection through\n         * iteratee. The corresponding value of each key is the last element responsible for generating the key. The\n         * iteratee function is bound to thisArg and invoked with three arguments:\n         * (value, index|key, collection).\n         *\n         * If a property name is provided for iteratee the created _.property style callback returns the property\n         * value of the given element.\n         *\n         * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for\n         * elements that have a matching property value, else false.\n         *\n         * If an object is provided for iteratee the created _.matches style callback returns true for elements that\n         * have the properties of the given object, else false.\n         *\n         * @param collection The collection to iterate over.\n         * @param iteratee The function invoked per iteration.\n         * @param thisArg The this binding of iteratee.\n         * @return Returns the composed aggregate object.\n         */\n        keyBy(\n            collection: string | null | undefined,\n            iteratee?: StringIterator<PropertyName>\n        ): Dictionary<string>;\n\n        /**\n         * @see _.keyBy\n         */\n        keyBy<T>(\n            collection: List<T> | null | undefined,\n            iteratee?: ListIterateeCustom<T, PropertyName>\n        ): Dictionary<T>;\n\n        /**\n         * @see _.keyBy\n         */\n        keyBy<T extends object>(\n            collection: T | null | undefined,\n            iteratee?: ObjectIterateeCustom<T, PropertyName>\n        ): Dictionary<T[keyof T]>;\n\n        /**\n         * @see _.keyBy\n         */\n        keyBy<T>(\n            collection: NumericDictionary<T> | null | undefined,\n            iteratee?: NumericDictionaryIterateeCustom<T, PropertyName>\n        ): Dictionary<T>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.keyBy\n         */\n        keyBy(\n            this: LoDashImplicitWrapper<string | null | undefined>,\n            iteratee?: StringIterator<PropertyName>\n        ): LoDashImplicitWrapper<Dictionary<string>>;\n\n        /**\n         * @see _.keyBy\n         */\n        keyBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ListIterateeCustom<T, PropertyName>\n        ): LoDashImplicitWrapper<Dictionary<T>>;\n\n        /**\n         * @see _.keyBy\n         */\n        keyBy<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            iteratee?: ObjectIterateeCustom<T, PropertyName>\n        ): LoDashImplicitWrapper<Dictionary<T[keyof T]>>;\n\n        /**\n         * @see _.keyBy\n         */\n        keyBy<T>(\n            this: LoDashImplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratee?: NumericDictionaryIterateeCustom<T, PropertyName>\n        ): LoDashImplicitWrapper<Dictionary<T>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.keyBy\n         */\n        keyBy(\n            this: LoDashExplicitWrapper<string | null | undefined>,\n            iteratee?: StringIterator<PropertyName>\n        ): LoDashExplicitWrapper<Dictionary<string>>;\n\n        /**\n         * @see _.keyBy\n         */\n        keyBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ListIterateeCustom<T, PropertyName>\n        ): LoDashExplicitWrapper<Dictionary<T>>;\n\n        /**\n         * @see _.keyBy\n         */\n        keyBy<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            iteratee?: ObjectIterateeCustom<T, PropertyName>\n        ): LoDashExplicitWrapper<Dictionary<T[keyof T]>>;\n\n        /**\n         * @see _.keyBy\n         */\n        keyBy<T>(\n            this: LoDashExplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratee?: NumericDictionaryIterateeCustom<T, PropertyName>\n        ): LoDashExplicitWrapper<Dictionary<T>>;\n    }\n\n    //_.invoke\n    interface LoDashStatic {\n        /**\n        * Invokes the method at path of object.\n        * @param object The object to query.\n        * @param path The path of the method to invoke.\n        * @param args The arguments to invoke the method with.\n        **/\n        invoke(\n            object: any,\n            path: PropertyPath,\n            ...args: any[]): any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n        * @see _.invoke\n        **/\n        invoke(\n            path: PropertyPath,\n            ...args: any[]): any;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n        * @see _.invoke\n        **/\n        invoke(\n            path: PropertyPath,\n            ...args: any[]): LoDashExplicitWrapper<any>;\n    }\n\n    //_.invokeMap\n    interface LoDashStatic {\n        /**\n        * Invokes the method named by methodName on each element in the collection returning\n        * an array of the results of each invoked method. Additional arguments will be provided\n        * to each invoked method. If methodName is a function it will be invoked for, and this\n        * bound to, each element in the collection.\n        * @param collection The collection to iterate over.\n        * @param methodName The name of the method to invoke.\n        * @param args Arguments to invoke the method with.\n        **/\n        invokeMap(\n            collection: object | null | undefined,\n            methodName: string,\n            ...args: any[]): any[];\n\n        /**\n        * @see _.invokeMap\n        **/\n        invokeMap<TResult>(\n            collection: object | null | undefined,\n            method: (...args: any[]) => TResult,\n            ...args: any[]): TResult[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n        * @see _.invokeMap\n        **/\n        invokeMap(\n            methodName: string,\n            ...args: any[]): LoDashImplicitWrapper<any[]>;\n\n        /**\n        * @see _.invokeMap\n        **/\n        invokeMap<TResult>(\n            method: (...args: any[]) => TResult,\n            ...args: any[]): LoDashImplicitWrapper<TResult[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n        * @see _.invokeMap\n        **/\n        invokeMap(\n            methodName: string,\n            ...args: any[]): LoDashExplicitWrapper<any[]>;\n\n        /**\n        * @see _.invokeMap\n        **/\n        invokeMap<TResult>(\n            method: (...args: any[]) => TResult,\n            ...args: any[]): LoDashExplicitWrapper<TResult[]>;\n    }\n\n    //_.map\n    interface LoDashStatic {\n        /**\n         * Creates an array of values by running each element in collection through iteratee. The iteratee is bound to\n         * thisArg and invoked with three arguments: (value, index|key, collection).\n         *\n         * If a property name is provided for iteratee the created _.property style callback returns the property value\n         * of the given element.\n         *\n         * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for\n         * elements that have a matching property value, else false.\n         *\n         * If an object is provided for iteratee the created _.matches style callback returns true for elements that\n         * have the properties of the given object, else false.\n         *\n         * Many lodash methods are guarded to work as iteratees for methods like _.every, _.filter, _.map, _.mapValues,\n         * _.reject, and _.some.\n         *\n         * The guarded methods are:\n         * ary, callback, chunk, clone, create, curry, curryRight, drop, dropRight, every, fill, flatten, invert, max,\n         * min, parseInt, slice, sortBy, take, takeRight, template, trim, trimLeft, trimRight, trunc, random, range,\n         * sample, some, sum, uniq, and words\n         *\n         * @param collection The collection to iterate over.\n         * @param iteratee The function invoked per iteration.\n         * @param thisArg The this binding of iteratee.\n         * @return Returns the new mapped array.\n         */\n        map<T, TResult>(\n            collection: List<T> | null | undefined,\n            iteratee: ListIterator<T, TResult>\n        ): TResult[];\n\n        /**\n         * @see _.map\n         */\n        map<T>(collection: List<T> | Dictionary<T> | null | undefined): T[];\n\n        /**\n         * @see _.map\n         */\n        map<T, TResult>(\n            collection: Dictionary<T> | null | undefined,\n            iteratee: DictionaryIterator<T, TResult>\n        ): TResult[];\n\n        /** @see _.map */\n        map<T, K extends keyof T>(\n            collection: List<T> | Dictionary<T> | null | undefined,\n            iteratee: K\n        ): Array<T[K]>;\n\n        /** @see _.map */\n        map<T, TResult>(\n            collection: NumericDictionary<T> | null | undefined,\n            iteratee?: NumericDictionaryIterator<T, TResult>\n        ): TResult[];\n\n        /**\n         * @see _.map\n         */\n        map<T, TResult>(\n            collection: List<T>|Dictionary<T>|NumericDictionary<T> | null | undefined,\n            iteratee?: string\n        ): TResult[];\n\n        /**\n         * @see _.map\n         */\n        map<T>(\n            collection: List<T>|Dictionary<T>|NumericDictionary<T> | null | undefined,\n            iteratee?: object\n        ): boolean[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.map\n         */\n        map<T, TResult>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee: ListIterator<T, TResult>\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.map\n         */\n        map<T>(this: LoDashImplicitWrapper<List<T> | Dictionary<T> | null | undefined>): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.map\n         */\n        map<T, TResult>(\n            this: LoDashImplicitWrapper<Dictionary<T> | null | undefined>,\n            iteratee: DictionaryIterator<T, TResult>\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /** @see _.map */\n        map<T, K extends keyof T>(\n            this: LoDashImplicitWrapper<List<T> | Dictionary<T> | null | undefined>,\n            iteratee: K\n        ): LoDashImplicitWrapper<Array<T[K]>>;\n\n        /** @see _.map */\n        map<T, TResult>(\n            this: LoDashImplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratee?: NumericDictionaryIterator<T, TResult>\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.map\n         */\n        map<T, TResult>(\n            this: LoDashImplicitWrapper<List<T> | Dictionary<T> | NumericDictionary<T> | null | undefined>,\n            iteratee?: string\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.map\n         */\n        map<T>(\n            this: LoDashImplicitWrapper<List<T> | Dictionary<T> | NumericDictionary<T> | null | undefined>,\n            iteratee?: object\n        ): LoDashImplicitWrapper<boolean[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.map\n         */\n        map<T, TResult>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee: ListIterator<T, TResult>\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.map\n         */\n        map<T>(this: LoDashExplicitWrapper<List<T> | Dictionary<T> | null | undefined>): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.map\n         */\n        map<T, TResult>(\n            this: LoDashExplicitWrapper<Dictionary<T> | null | undefined>,\n            iteratee: DictionaryIterator<T, TResult>\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /** @see _.map */\n        map<T, K extends keyof T>(\n            this: LoDashExplicitWrapper<List<T> | Dictionary<T> | null | undefined>,\n            iteratee: K\n        ): LoDashExplicitWrapper<Array<T[K]>>;\n\n        /**\n         * @see _.map\n         */\n        map<T, TResult>(\n            this: LoDashExplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratee?: NumericDictionaryIterator<T, TResult>\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.map\n         */\n        map<T, TResult>(\n            this: LoDashExplicitWrapper<List<T> | Dictionary<T> | NumericDictionary<T> | null | undefined>,\n            iteratee?: string\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.map\n         */\n        map<T>(\n            this: LoDashExplicitWrapper<List<T> | Dictionary<T> | NumericDictionary<T> | null | undefined>,\n            iteratee?: object\n        ): LoDashExplicitWrapper<boolean[]>;\n    }\n\n    //_.partition\n    interface LoDashStatic {\n        /**\n        * Creates an array of elements split into two groups, the first of which contains elements predicate returns truthy for,\n        * while the second of which contains elements predicate returns falsey for.\n        * The predicate is bound to thisArg and invoked with three arguments: (value, index|key, collection).\n        *\n        * If a property name is provided for predicate the created _.property style callback\n        * returns the property value of the given element.\n        *\n        * If a value is also provided for thisArg the created _.matchesProperty style callback\n        * returns true for elements that have a matching property value, else false.\n        *\n        * If an object is provided for predicate the created _.matches style callback returns\n        * true for elements that have the properties of the given object, else false.\n        *\n        * @param collection The collection to iterate over.\n        * @param callback The function called per iteration.\n        * @param thisArg The this binding of predicate.\n        * @return Returns the array of grouped elements.\n        **/\n        partition<T>(\n            collection: List<T> | null | undefined,\n            callback: ValueIteratee<T>\n        ): [T[], T[]];\n\n        /**\n         * @see _.partition\n         */\n        partition<T extends object>(\n            collection: T | null | undefined,\n            callback: ValueIteratee<T[keyof T]>\n        ): [Array<T[keyof T]>, Array<T[keyof T]>];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.partition\n         */\n        partition<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            callback: ValueIteratee<T>\n        ): LoDashImplicitWrapper<[T[], T[]]>;\n\n        /**\n         * @see _.partition\n         */\n        partition<T>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            callback: ValueIteratee<T[keyof T]>\n        ): LoDashImplicitWrapper<[Array<T[keyof T]>, Array<T[keyof T]>]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.partition\n         */\n        partition<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            callback: ValueIteratee<T>\n        ): LoDashExplicitWrapper<[T[], T[]]>;\n\n        /**\n         * @see _.partition\n         */\n        partition<T>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            callback: ValueIteratee<T[keyof T]>\n        ): LoDashExplicitWrapper<[Array<T[keyof T]>, Array<T[keyof T]>]>;\n    }\n\n    //_.reduce\n    interface LoDashStatic {\n        /**\n        * Reduces a collection to a value which is the accumulated result of running each\n        * element in the collection through the callback, where each successive callback execution\n        * consumes the return value of the previous execution. If accumulator is not provided the\n        * first element of the collection will be used as the initial accumulator value. The callback\n        * is bound to thisArg and invoked with four arguments; (accumulator, value, index|key, collection).\n        * @param collection The collection to iterate over.\n        * @param callback The function called per iteration.\n        * @param accumulator Initial value of the accumulator.\n        * @return Returns the accumulated value.\n        **/\n        reduce<T, TResult>(\n            collection: T[] | null | undefined,\n            callback: MemoListIterator<T, TResult, T[]>,\n            accumulator: TResult\n        ): TResult;\n\n        /**\n        * @see _.reduce\n        **/\n        reduce<T, TResult>(\n            collection: List<T> | null | undefined,\n            callback: MemoListIterator<T, TResult, List<T>>,\n            accumulator: TResult\n        ): TResult;\n\n        /**\n        * @see _.reduce\n        **/\n        reduce<T extends object, TResult>(\n            collection: T | null | undefined,\n            callback: MemoObjectIterator<T[keyof T], TResult, T>,\n            accumulator: TResult\n        ): TResult;\n\n        /**\n        * @see _.reduce\n        **/\n        reduce<T, TResult>(\n            collection: NumericDictionary<T> | null | undefined,\n            callback: MemoListIterator<T, TResult, NumericDictionary<T>>,\n            accumulator: TResult\n        ): TResult;\n\n        /**\n        * @see _.reduce\n        **/\n        reduce<T, TResult>(\n            collection: T[] | null | undefined,\n            callback: MemoListIterator<T, TResult, T[]>\n        ): TResult | undefined;\n\n        /**\n         * @see _.reduce\n         **/\n        reduce<T, TResult>(\n            collection: List<T> | null | undefined,\n            callback: MemoListIterator<T, TResult, List<T>>\n        ): TResult | undefined;\n\n        /**\n        * @see _.reduce\n        **/\n        reduce<T extends object, TResult>(\n            collection: T | null | undefined,\n            callback: MemoObjectIterator<T[keyof T], TResult, T>\n        ): TResult | undefined;\n\n        /**\n         * @see _.reduce\n         **/\n        reduce<T, TResult>(\n            collection: NumericDictionary<T> | null | undefined,\n            callback: MemoListIterator<T, TResult, NumericDictionary<T>>\n        ): TResult | undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n         /**\n        * @see _.reduce\n        **/\n        reduce<T, TResult>(\n            this: LoDashImplicitWrapper<T[] | null | undefined>,\n            callback: MemoListIterator<T, TResult, T[]>,\n            accumulator: TResult\n        ): TResult;\n\n        /**\n         * @see _.reduce\n         **/\n        reduce<T, TResult>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            callback: MemoListIterator<T, TResult, List<T>>,\n            accumulator: TResult\n        ): TResult;\n\n        /**\n        * @see _.reduce\n        **/\n        reduce<T extends object, TResult>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            callback: MemoObjectIterator<T[keyof T], TResult, T>,\n            accumulator: TResult\n        ): TResult;\n\n        /**\n         * @see _.reduce\n         **/\n        reduce<T, TResult>(\n            this: LoDashImplicitWrapper<NumericDictionary<T> | null | undefined>,\n            callback: MemoListIterator<T, TResult, NumericDictionary<T>>,\n            accumulator: TResult\n        ): TResult;\n\n        /**\n        * @see _.reduce\n        **/\n        reduce<T, TResult>(\n            this: LoDashImplicitWrapper<T[] | null | undefined>,\n            callback: MemoListIterator<T, TResult, T[]>\n        ): TResult | undefined;\n\n        /**\n        * @see _.reduce\n        **/\n        reduce<T, TResult>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            callback: MemoListIterator<T, TResult, List<T>>\n        ): TResult | undefined;\n\n        /**\n        * @see _.reduce\n        **/\n        reduce<T extends object, TResult>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            callback: MemoObjectIterator<T[keyof T], TResult, T>\n        ): TResult | undefined;\n\n        /**\n        * @see _.reduce\n        **/\n        reduce<T, TResult>(\n            this: LoDashImplicitWrapper<NumericDictionary<T> | null | undefined>,\n            callback: MemoListIterator<T, TResult, NumericDictionary<T>>\n        ): TResult | undefined;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n        * @see _.reduce\n        **/\n        reduce<T, TResult>(\n            this: LoDashExplicitWrapper<T[] | null | undefined>,\n            callback: MemoListIterator<T, TResult, T[]>,\n            accumulator: TResult\n        ): LoDashExplicitWrapper<TResult>;\n\n        /**\n        * @see _.reduce\n        **/\n        reduce<T, TResult>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            callback: MemoListIterator<T, TResult, List<T>>,\n            accumulator: TResult\n        ): LoDashExplicitWrapper<TResult>;\n\n        /**\n        * @see _.reduce\n        **/\n        reduce<T extends object, TResult>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            callback: MemoObjectIterator<T[keyof T], TResult, T>,\n            accumulator: TResult\n        ): LoDashExplicitWrapper<TResult>;\n\n        /**\n        * @see _.reduce\n        **/\n        reduce<T, TResult>(\n            this: LoDashExplicitWrapper<NumericDictionary<T> | null | undefined>,\n            callback: MemoListIterator<T, TResult, NumericDictionary<T>>,\n            accumulator: TResult\n        ): LoDashExplicitWrapper<TResult>;\n\n        /**\n        * @see _.reduce\n        **/\n        reduce<T, TResult>(\n            this: LoDashExplicitWrapper<T[] | null | undefined>,\n            callback: MemoListIterator<T, TResult, T[]>\n        ): LoDashExplicitWrapper<TResult | undefined>;\n\n        /**\n        * @see _.reduce\n        **/\n        reduce<T, TResult>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            callback: MemoListIterator<T, TResult, List<T>>\n        ): LoDashExplicitWrapper<TResult | undefined>;\n\n        /**\n        * @see _.reduce\n        **/\n        reduce<T extends object, TResult>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            callback: MemoObjectIterator<T[keyof T], TResult, T>\n        ): LoDashExplicitWrapper<TResult | undefined>;\n\n        /**\n         * @see _.reduce\n         **/\n        reduce<T, TResult>(\n            this: LoDashExplicitWrapper<NumericDictionary<T> | null | undefined>,\n            callback: MemoListIterator<T, TResult, NumericDictionary<T>>\n        ): LoDashExplicitWrapper<TResult | undefined>;\n    }\n\n    //_.reduceRight\n    interface LoDashStatic {\n        /**\n        * This method is like _.reduce except that it iterates over elements of a collection from\n        * right to left.\n        * @param collection The collection to iterate over.\n        * @param callback The function called per iteration.\n        * @param accumulator Initial value of the accumulator.\n        * @return The accumulated value.\n        **/\n        reduceRight<T, TResult>(\n            collection: T[] | null | undefined,\n            callback: MemoListIterator<T, TResult, T[]>,\n            accumulator: TResult\n        ): TResult;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T, TResult>(\n            collection: List<T> | null | undefined,\n            callback: MemoListIterator<T, TResult, List<T>>,\n            accumulator: TResult\n        ): TResult;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T extends object, TResult>(\n            collection: T | null | undefined,\n            callback: MemoObjectIterator<T[keyof T], TResult, T>,\n            accumulator: TResult\n        ): TResult;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T, TResult>(\n            collection: NumericDictionary<T> | null | undefined,\n            callback: MemoListIterator<T, TResult, NumericDictionary<T>>,\n            accumulator: TResult\n        ): TResult;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T, TResult>(\n            collection: T[] | null | undefined,\n            callback: MemoListIterator<T, TResult, T[]>\n        ): TResult | undefined;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T, TResult>(\n            collection: List<T> | null | undefined,\n            callback: MemoListIterator<T, TResult, List<T>>\n        ): TResult | undefined;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T extends object, TResult>(\n            collection: T | null | undefined,\n            callback: MemoObjectIterator<T[keyof T], TResult, T>\n        ): TResult | undefined;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T, TResult>(\n            collection: NumericDictionary<T> | null | undefined,\n            callback: MemoListIterator<T, TResult, NumericDictionary<T>>\n        ): TResult | undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n         /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T, TResult>(\n            this: LoDashImplicitWrapper<T[] | null | undefined>,\n            callback: MemoListIterator<T, TResult, T[]>,\n            accumulator: TResult\n        ): TResult;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T, TResult>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            callback: MemoListIterator<T, TResult, List<T>>,\n            accumulator: TResult\n        ): TResult;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T extends object, TResult>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            callback: MemoObjectIterator<T[keyof T], TResult, T>,\n            accumulator: TResult\n        ): TResult;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T, TResult>(\n            this: LoDashImplicitWrapper<NumericDictionary<T> | null | undefined>,\n            callback: MemoListIterator<T, TResult, NumericDictionary<T>>,\n            accumulator: TResult\n        ): TResult;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T, TResult>(\n            this: LoDashImplicitWrapper<T[] | null | undefined>,\n            callback: MemoListIterator<T, TResult, T[]>\n        ): TResult | undefined;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T, TResult>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            callback: MemoListIterator<T, TResult, List<T>>\n        ): TResult | undefined;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T extends object, TResult>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            callback: MemoObjectIterator<T[keyof T], TResult, T>\n        ): TResult | undefined;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T, TResult>(\n            this: LoDashImplicitWrapper<NumericDictionary<T> | null | undefined>,\n            callback: MemoListIterator<T, TResult, NumericDictionary<T>>\n        ): TResult | undefined;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T, TResult>(\n            this: LoDashExplicitWrapper<T[] | null | undefined>,\n            callback: MemoListIterator<T, TResult, T[]>,\n            accumulator: TResult\n        ): LoDashExplicitWrapper<TResult>;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T, TResult>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            callback: MemoListIterator<T, TResult, List<T>>,\n            accumulator: TResult\n        ): LoDashExplicitWrapper<TResult>;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T extends object, TResult>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            callback: MemoObjectIterator<T[keyof T], TResult, T>,\n            accumulator: TResult\n        ): LoDashExplicitWrapper<TResult>;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T, TResult>(\n            this: LoDashExplicitWrapper<NumericDictionary<T> | null | undefined>,\n            callback: MemoListIterator<T, TResult, NumericDictionary<T>>,\n            accumulator: TResult\n        ): LoDashExplicitWrapper<TResult>;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T, TResult>(\n            this: LoDashExplicitWrapper<T[] | null | undefined>,\n            callback: MemoListIterator<T, TResult, T[]>\n        ): LoDashExplicitWrapper<TResult | undefined>;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T, TResult>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            callback: MemoListIterator<T, TResult, List<T>>\n        ): LoDashExplicitWrapper<TResult | undefined>;\n\n        /**\n        * @see _.reduceRight\n        **/\n        reduceRight<T extends object, TResult>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            callback: MemoObjectIterator<T[keyof T], TResult, T>\n        ): LoDashExplicitWrapper<TResult | undefined>;\n\n        /**\n         * @see _.reduceRight\n         **/\n        reduceRight<T, TResult>(\n            this: LoDashExplicitWrapper<NumericDictionary<T> | null | undefined>,\n            callback: MemoListIterator<T, TResult, NumericDictionary<T>>\n        ): LoDashExplicitWrapper<TResult | undefined>;\n    }\n\n    //_.reject\n    interface LoDashStatic {\n        /**\n         * The opposite of _.filter; this method returns the elements of collection that predicate does not return\n         * truthy for.\n         *\n         * @param collection The collection to iterate over.\n         * @param predicate The function invoked per iteration.\n         * @param thisArg The this binding of predicate.\n         * @return Returns the new filtered array.\n         */\n        reject(\n            collection: string | null | undefined,\n            predicate?: StringIterator<boolean>\n        ): string[];\n\n        /**\n         * @see _.reject\n         */\n        reject<T>(\n            collection: List<T> | null | undefined,\n            predicate?: ListIterateeCustom<T, boolean>\n        ): T[];\n\n        /**\n         * @see _.reject\n         */\n        reject<T extends object>(\n            collection: T | null | undefined,\n            predicate?: ObjectIterateeCustom<T, boolean>\n        ): Array<T[keyof T]>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.reject\n         */\n        reject(\n            this: LoDashImplicitWrapper<string | null | undefined>,\n            predicate?: StringIterator<boolean>\n        ): LoDashImplicitWrapper<string[]>;\n\n        /**\n         * @see _.reject\n         */\n        reject<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIterateeCustom<T, boolean>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.reject\n         */\n        reject<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            predicate?: ObjectIterateeCustom<T, boolean>\n        ): LoDashImplicitWrapper<Array<T[keyof T]>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.reject\n         */\n        reject(\n            this: LoDashExplicitWrapper<string | null | undefined>,\n            predicate?: StringIterator<boolean>\n        ): LoDashExplicitWrapper<string[]>;\n\n        /**\n         * @see _.reject\n         */\n        reject<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIterateeCustom<T, boolean>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.reject\n         */\n        reject<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            predicate?: ObjectIterateeCustom<T, boolean>\n        ): LoDashExplicitWrapper<Array<T[keyof T]>>;\n    }\n\n    //_.sample\n    interface LoDashStatic {\n        /**\n         * Gets a random element from collection.\n         *\n         * @param collection The collection to sample.\n         * @return Returns the random element.\n         */\n        sample<T>(\n            collection: List<T> | Dictionary<T> | NumericDictionary<T> | null | undefined\n        ): T | undefined;\n\n        /**\n         * @see _.sample\n         */\n        sample<T extends object>(\n            collection: T\n        ): T[keyof T];\n\n        /**\n         * @see _.sample\n         */\n        sample<T extends object>(\n            collection: T | null | undefined\n        ): T[keyof T] | undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.sample\n         */\n        sample<T>(\n            this: LoDashImplicitWrapper<List<T> | Dictionary<T> | NumericDictionary<T> | null | undefined>\n        ): T | undefined;\n\n        /**\n         * @see _.sample\n         */\n        sample<T extends object>(\n            this: LoDashImplicitWrapper<T>,\n        ): T[keyof T];\n\n        /**\n         * @see _.sample\n         */\n        sample<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>\n        ): T[keyof T] | undefined;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.sample\n         */\n        sample<T>(\n            this: LoDashExplicitWrapper<List<T> | Dictionary<T> | NumericDictionary<T> | null | undefined>\n        ): LoDashExplicitWrapper<T | undefined>;\n\n        /**\n         * @see _.sample\n         */\n        sample<T extends object>(\n            this: LoDashExplicitWrapper<T>,\n        ): LoDashExplicitWrapper<T[keyof T]>;\n\n        /**\n         * @see _.sample\n         */\n        sample<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>\n        ): LoDashExplicitWrapper<T[keyof T] | undefined>;\n    }\n\n    //_.sampleSize\n    interface LoDashStatic {\n        /**\n         * Gets n random elements at unique keys from collection up to the size of collection.\n         *\n         * @param collection The collection to sample.\n         * @param n The number of elements to sample.\n         * @return Returns the random elements.\n         */\n        sampleSize<T>(\n            collection: List<T>|Dictionary<T>|NumericDictionary<T> | null | undefined,\n            n?: number\n        ): T[];\n\n        /**\n         * @see _.sampleSize\n         */\n        sampleSize<T extends object>(\n            collection: T | null | undefined,\n            n?: number\n        ): Array<T[keyof T]>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.sampleSize\n         */\n        sampleSize<T>(\n            this: LoDashImplicitWrapper<List<T>|Dictionary<T>|NumericDictionary<T> | null | undefined>,\n            n?: number\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.sampleSize\n         */\n        sampleSize<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            n?: number\n        ): LoDashImplicitWrapper<Array<T[keyof T]>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.sampleSize\n         */\n        sampleSize<T>(\n            this: LoDashExplicitWrapper<List<T>|Dictionary<T>|NumericDictionary<T> | null | undefined>,\n            n?: number\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.sampleSize\n         */\n        sampleSize<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            n?: number\n        ): LoDashExplicitWrapper<Array<T[keyof T]>>;\n    }\n\n    //_.shuffle\n    interface LoDashStatic {\n        /**\n         * Creates an array of shuffled values, using a version of the Fisher-Yates shuffle.\n         *\n         * @param collection The collection to shuffle.\n         * @return Returns the new shuffled array.\n         */\n        shuffle<T>(collection: List<T> | null | undefined): T[];\n\n        /**\n         * @see _.shuffle\n         */\n        shuffle<T extends object>(collection: T | null | undefined): Array<T[keyof T]>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.shuffle\n         */\n        shuffle<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.shuffle\n         */\n        shuffle<T extends object>(this: LoDashImplicitWrapper<T | null | undefined>): LoDashImplicitWrapper<Array<T[keyof T]>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.shuffle\n         */\n        shuffle<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.shuffle\n         */\n        shuffle<T extends object>(this: LoDashExplicitWrapper<T | null | undefined>): LoDashExplicitWrapper<Array<T[keyof T]>>;\n    }\n\n    //_.size\n    interface LoDashStatic {\n        /**\n         * Gets the size of collection by returning its length for array-like values or the number of own enumerable\n         * properties for objects.\n         *\n         * @param collection The collection to inspect.\n         * @return Returns the size of collection.\n         */\n        size(collection: object | string | null | undefined): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.size\n         */\n        size(): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.size\n         */\n        size(): LoDashExplicitWrapper<number>;\n    }\n\n    //_.some\n    interface LoDashStatic {\n        /**\n         * Checks if predicate returns truthy for any element of collection. Iteration is stopped once predicate\n         * returns truthy. The predicate is invoked with three arguments: (value, index|key, collection).\n         *\n         * @param collection The collection to iterate over.\n         * @param predicate The function invoked per iteration.\n         * @return Returns true if any element passes the predicate check, else false.\n         */\n        some<T>(\n            collection: List<T> | null | undefined,\n            predicate?: ListIterateeCustom<T, boolean>\n        ): boolean;\n\n        /**\n         * @see _.some\n         */\n        some<T extends object>(\n            collection: T | null | undefined,\n            predicate?: ObjectIterateeCustom<T, boolean>\n        ): boolean;\n\n        /**\n         * @see _.some\n         */\n        some<T>(\n            collection: NumericDictionary<T> | null | undefined,\n            predicate?: NumericDictionaryIterateeCustom<T, boolean>\n        ): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.some\n         */\n        some<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIterateeCustom<T, boolean>\n        ): boolean;\n\n        /**\n         * @see _.some\n         */\n        some<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            predicate?: ObjectIterateeCustom<T, boolean>\n        ): boolean;\n\n        /**\n         * @see _.some\n         */\n        some<T>(\n            this: LoDashImplicitWrapper<NumericDictionary<T> | null | undefined>,\n            predicate?: NumericDictionaryIterateeCustom<T, boolean>\n        ): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.some\n         */\n        some<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            predicate?: ListIterateeCustom<T, boolean>\n        ): LoDashExplicitWrapper<boolean>;\n\n        /**\n         * @see _.some\n         */\n        some<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            predicate?: ObjectIterateeCustom<T, boolean>\n        ): LoDashExplicitWrapper<boolean>;\n\n        /**\n         * @see _.some\n         */\n        some<T>(\n            this: LoDashExplicitWrapper<NumericDictionary<T> | null | undefined>,\n            predicate?: NumericDictionaryIterateeCustom<T, boolean>\n        ): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.sortBy\n    interface LoDashStatic {\n        /**\n         * Creates an array of elements, sorted in ascending order by the results of\n         * running each element in a collection through each iteratee. This method\n         * performs a stable sort, that is, it preserves the original sort order of\n         * equal elements. The iteratees are invoked with one argument: (value).\n         *\n         * @category Collection\n         * @param collection The collection to iterate over.\n         * @param [iteratees=[_.identity]]\n         *  The iteratees to sort by, specified individually or in arrays.\n         * @returns Returns the new sorted array.\n         * @example\n         *\n         * var users = [\n         *   { 'user': 'fred',   'age': 48 },\n         *   { 'user': 'barney', 'age': 36 },\n         *   { 'user': 'fred',   'age': 42 },\n         *   { 'user': 'barney', 'age': 34 }\n         * ];\n         *\n         * _.sortBy(users, function(o) { return o.user; });\n         * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]\n         *\n         * _.sortBy(users, ['user', 'age']);\n         * // => objects for [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]\n         *\n         * _.sortBy(users, 'user', function(o) {\n         *   return Math.floor(o.age / 10);\n         * });\n         * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]\n         */\n        sortBy<T>(\n            collection: List<T> | null | undefined,\n            ...iteratees: Array<Many<ListIteratee<T>>>\n        ): T[];\n\n        /**\n         * @see _.sortBy\n         */\n        sortBy<T extends object>(\n            collection: T | null | undefined,\n            ...iteratees: Array<Many<ObjectIteratee<T>>>\n        ): Array<T[keyof T]>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.sortBy\n         */\n        sortBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            ...iteratees: Array<Many<ListIteratee<T>>>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.sortBy\n         */\n        sortBy<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            ...iteratees: Array<Many<ObjectIteratee<T>>>\n        ): LoDashImplicitWrapper<Array<T[keyof T]>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.sortBy\n         */\n        sortBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            ...iteratees: Array<Many<ListIteratee<T>>>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.sortBy\n         */\n        sortBy<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            ...iteratees: Array<Many<ObjectIteratee<T>>>\n        ): LoDashExplicitWrapper<Array<T[keyof T]>>;\n    }\n\n    //_.orderBy\n    interface LoDashStatic {\n        /**\n         * This method is like `_.sortBy` except that it allows specifying the sort\n         * orders of the iteratees to sort by. If `orders` is unspecified, all values\n         * are sorted in ascending order. Otherwise, specify an order of \"desc\" for\n         * descending or \"asc\" for ascending sort order of corresponding values.\n         *\n         * @category Collection\n         * @param collection The collection to iterate over.\n         * @param [iteratees=[_.identity]] The iteratees to sort by.\n         * @param [orders] The sort orders of `iteratees`.\n         * @param- {Object} [guard] Enables use as an iteratee for functions like `_.reduce`.\n         * @returns Returns the new sorted array.\n         * @example\n         *\n         * var users = [\n         *   { 'user': 'fred',   'age': 48 },\n         *   { 'user': 'barney', 'age': 34 },\n         *   { 'user': 'fred',   'age': 42 },\n         *   { 'user': 'barney', 'age': 36 }\n         * ];\n         *\n         * // sort by `user` in ascending order and by `age` in descending order\n         * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);\n         * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]\n         */\n        orderBy<T>(\n            collection: List<T> | null | undefined,\n            iteratees?: Many<ListIterator<T, NotVoid>>,\n            orders?: Many<boolean|string>\n        ): T[];\n\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T>(\n            collection: List<T> | null | undefined,\n            iteratees?: Many<ListIteratee<T>>,\n            orders?: Many<boolean|string>\n        ): T[];\n\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T extends object>(\n            collection: T | null | undefined,\n            iteratees?: Many<ObjectIterator<T, NotVoid>>,\n            orders?: Many<boolean|string>\n        ): Array<T[keyof T]>;\n\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T extends object>(\n            collection: T | null | undefined,\n            iteratees?: Many<ObjectIteratee<T>>,\n            orders?: Many<boolean|string>\n        ): Array<T[keyof T]>;\n\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T>(\n            collection: NumericDictionary<T> | null | undefined,\n            iteratees?: Many<NumericDictionaryIterator<T, NotVoid>>,\n            orders?: Many<boolean|string>\n        ): T[];\n\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T>(\n            collection: NumericDictionary<T> | null | undefined,\n            iteratees?: Many<NumericDictionaryIteratee<T>>,\n            orders?: Many<boolean|string>\n        ): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratees?: Many<ListIterator<T, NotVoid>>,\n            orders?: Many<boolean|string>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratees?: Many<ListIteratee<T>>,\n            orders?: Many<boolean|string>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            iteratees?: Many<ObjectIterator<T, NotVoid>>,\n            orders?: Many<boolean|string>\n        ): LoDashImplicitWrapper<Array<T[keyof T]>>;\n\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            iteratees?: Many<ObjectIteratee<T>>,\n            orders?: Many<boolean|string>\n        ): LoDashImplicitWrapper<Array<T[keyof T]>>;\n\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T>(\n            this: LoDashImplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratees?: Many<NumericDictionaryIterator<T, NotVoid>>,\n            orders?: Many<boolean|string>\n        ): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T>(\n            this: LoDashImplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratees?: Many<NumericDictionaryIteratee<T>>,\n            orders?: Many<boolean|string>\n        ): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratees?: Many<ListIterator<T, NotVoid>>,\n            orders?: Many<boolean|string>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratees?: Many<ListIteratee<T>>,\n            orders?: Many<boolean|string>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            iteratees?: Many<ObjectIterator<T, NotVoid>>,\n            orders?: Many<boolean|string>\n        ): LoDashExplicitWrapper<Array<T[keyof T]>>;\n\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            iteratees?: Many<ObjectIteratee<T>>,\n            orders?: Many<boolean|string>\n        ): LoDashExplicitWrapper<Array<T[keyof T]>>;\n\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T>(\n            this: LoDashExplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratees?: Many<NumericDictionaryIterator<T, NotVoid>>,\n            orders?: Many<boolean|string>\n        ): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.orderBy\n         */\n        orderBy<T>(\n            this: LoDashExplicitWrapper<NumericDictionary<T> | null | undefined>,\n            iteratees?: Many<NumericDictionaryIteratee<T>>,\n            orders?: Many<boolean|string>\n        ): LoDashExplicitWrapper<T[]>;\n    }\n\n    /********\n     * Date *\n     ********/\n\n    //_.now\n    interface LoDashStatic {\n        /**\n         * Gets the number of milliseconds that have elapsed since the Unix epoch (1 January 1970 00:00:00 UTC).\n         *\n         * @return The number of milliseconds.\n         */\n        now(): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.now\n         */\n        now(): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.now\n         */\n        now(): LoDashExplicitWrapper<number>;\n    }\n\n    /*************\n     * Functions *\n     *************/\n\n    //_.after\n    interface LoDashStatic {\n        /**\n         * The opposite of _.before; this method creates a function that invokes func once itâs called n or more times.\n         *\n         * @param n The number of calls before func is invoked.\n         * @param func The function to restrict.\n         * @return Returns the new restricted function.\n         */\n        after<TFunc extends (...args: any[]) => any>(\n            n: number,\n            func: TFunc\n        ): TFunc;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n        * @see _.after\n        **/\n        after<TFunc extends (...args: any[]) => any>(func: TFunc): LoDashImplicitWrapper<TFunc>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.after\n         **/\n        after<TFunc extends (...args: any[]) => any>(func: TFunc): LoDashExplicitWrapper<TFunc>;\n    }\n\n    //_.ary\n    interface LoDashStatic {\n        /**\n         * Creates a function that accepts up to n arguments ignoring any additional arguments.\n         *\n         * @param func The function to cap arguments for.\n         * @param n The arity cap.\n         * @returns Returns the new function.\n         */\n        ary(\n            func: (...args: any[]) => any,\n            n?: number\n        ): (...args: any[]) => any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.ary\n         */\n        ary(n?: number): LoDashImplicitWrapper<(...args: any[]) => any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.ary\n         */\n        ary(n?: number): LoDashExplicitWrapper<(...args: any[]) => any>;\n    }\n\n    //_.before\n    interface LoDashStatic {\n        /**\n         * Creates a function that invokes func, with the this binding and arguments of the created function, while\n         * itâs called less than n times. Subsequent calls to the created function return the result of the last func\n         * invocation.\n         *\n         * @param n The number of calls at which func is no longer invoked.\n         * @param func The function to restrict.\n         * @return Returns the new restricted function.\n         */\n        before<TFunc extends (...args: any[]) => any>(\n            n: number,\n            func: TFunc\n        ): TFunc;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.before\n         **/\n        before<TFunc extends (...args: any[]) => any>(func: TFunc): LoDashImplicitWrapper<TFunc>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.before\n         **/\n        before<TFunc extends (...args: any[]) => any>(func: TFunc): LoDashExplicitWrapper<TFunc>;\n    }\n\n    //_.bind\n    interface FunctionBind {\n        placeholder: any;\n\n        (\n            func: (...args: any[]) => any,\n            thisArg: any,\n            ...partials: any[]\n        ): (...args: any[]) => any;\n    }\n\n    interface LoDashStatic {\n        /**\n         * Creates a function that invokes func with the this binding of thisArg and prepends any additional _.bind\n         * arguments to those provided to the bound function.\n         *\n         * The _.bind.placeholder value, which defaults to _ in monolithic builds, may be used as a placeholder for\n         * partially applied arguments.\n         *\n         * Note: Unlike native Function#bind this method does not set the \"length\" property of bound functions.\n         *\n         * @param func The function to bind.\n         * @param thisArg The this binding of func.\n         * @param partials The arguments to be partially applied.\n         * @return Returns the new bound function.\n         */\n        bind: FunctionBind;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.bind\n         */\n        bind(\n            thisArg: any,\n            ...partials: any[]\n        ): LoDashImplicitWrapper<(...args: any[]) => any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.bind\n         */\n        bind(\n            thisArg: any,\n            ...partials: any[]\n        ): LoDashExplicitWrapper<(...args: any[]) => any>;\n    }\n\n    //_.bindAll\n    interface LoDashStatic {\n        /**\n         * Binds methods of an object to the object itself, overwriting the existing method. Method names may be\n         * specified as individual arguments or as arrays of method names. If no method names are provided all\n         * enumerable function properties, own and inherited, of object are bound.\n         *\n         * Note: This method does not set the \"length\" property of bound functions.\n         *\n         * @param object The object to bind and assign the bound methods to.\n         * @param methodNames The object method names to bind, specified as individual method names or arrays of\n         * method names.\n         * @return Returns object.\n         */\n        bindAll<T>(\n            object: T,\n            ...methodNames: Array<Many<string>>\n        ): T;\n    }\n\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.bindAll\n         */\n        bindAll(...methodNames: Array<Many<string>>): this;\n    }\n\n    //_.bindKey\n    interface FunctionBindKey {\n        placeholder: any;\n\n        (\n            object: object,\n            key: string,\n            ...partials: any[]\n        ): (...args: any[]) => any;\n    }\n\n    interface LoDashStatic {\n        /**\n         * Creates a function that invokes the method at object[key] and prepends any additional _.bindKey arguments\n         * to those provided to the bound function.\n         *\n         * This method differs from _.bind by allowing bound functions to reference methods that may be redefined\n         * or donât yet exist. See Peter Michauxâs article for more details.\n         *\n         * The _.bindKey.placeholder value, which defaults to _ in monolithic builds, may be used as a placeholder\n         * for partially applied arguments.\n         *\n         * @param object The object the method belongs to.\n         * @param key The key of the method.\n         * @param partials The arguments to be partially applied.\n         * @return Returns the new bound function.\n         */\n        bindKey: FunctionBindKey;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.bindKey\n         */\n        bindKey(\n            key: string,\n            ...partials: any[]\n        ): LoDashImplicitWrapper<(...args: any[]) => any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.bindKey\n         */\n        bindKey(\n            key: string,\n            ...partials: any[]\n        ): LoDashExplicitWrapper<(...args: any[]) => any>;\n    }\n\n    //_.curry\n    interface LoDashStatic {\n        /**\n         * Creates a function that accepts one or more arguments of func that when called either invokes func returning\n         * its result, if all func arguments have been provided, or returns a function that accepts one or more of the\n         * remaining func arguments, and so on. The arity of func may be specified if func.length is not sufficient.\n         * @param func The function to curry.\n         * @param arity The arity of func.\n         * @return Returns the new curried function.\n         */\n        curry<T1, R>(func: (t1: T1) => R, arity?: number):\n            CurriedFunction1<T1, R>;\n        /**\n         * Creates a function that accepts one or more arguments of func that when called either invokes func returning\n         * its result, if all func arguments have been provided, or returns a function that accepts one or more of the\n         * remaining func arguments, and so on. The arity of func may be specified if func.length is not sufficient.\n         * @param func The function to curry.\n         * @param arity The arity of func.\n         * @return Returns the new curried function.\n         */\n        curry<T1, T2, R>(func: (t1: T1, t2: T2) => R, arity?: number):\n            CurriedFunction2<T1, T2, R>;\n        /**\n         * Creates a function that accepts one or more arguments of func that when called either invokes func returning\n         * its result, if all func arguments have been provided, or returns a function that accepts one or more of the\n         * remaining func arguments, and so on. The arity of func may be specified if func.length is not sufficient.\n         * @param func The function to curry.\n         * @param arity The arity of func.\n         * @return Returns the new curried function.\n         */\n        curry<T1, T2, T3, R>(func: (t1: T1, t2: T2, t3: T3) => R, arity?: number):\n            CurriedFunction3<T1, T2, T3, R>;\n        /**\n         * Creates a function that accepts one or more arguments of func that when called either invokes func returning\n         * its result, if all func arguments have been provided, or returns a function that accepts one or more of the\n         * remaining func arguments, and so on. The arity of func may be specified if func.length is not sufficient.\n         * @param func The function to curry.\n         * @param arity The arity of func.\n         * @return Returns the new curried function.\n         */\n        curry<T1, T2, T3, T4, R>(func: (t1: T1, t2: T2, t3: T3, t4: T4) => R, arity?: number):\n            CurriedFunction4<T1, T2, T3, T4, R>;\n        /**\n         * Creates a function that accepts one or more arguments of func that when called either invokes func returning\n         * its result, if all func arguments have been provided, or returns a function that accepts one or more of the\n         * remaining func arguments, and so on. The arity of func may be specified if func.length is not sufficient.\n         * @param func The function to curry.\n         * @param arity The arity of func.\n         * @return Returns the new curried function.\n         */\n        curry<T1, T2, T3, T4, T5, R>(func: (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5) => R, arity?: number):\n            CurriedFunction5<T1, T2, T3, T4, T5, R>;\n        /**\n         * Creates a function that accepts one or more arguments of func that when called either invokes func returning\n         * its result, if all func arguments have been provided, or returns a function that accepts one or more of the\n         * remaining func arguments, and so on. The arity of func may be specified if func.length is not sufficient.\n         * @param func The function to curry.\n         * @param arity The arity of func.\n         * @return Returns the new curried function.\n         */\n        curry(func: (...args: any[]) => any, arity?: number): (...args: any[]) => any;\n    }\n\n    interface CurriedFunction1<T1, R> {\n        (): CurriedFunction1<T1, R>;\n        (t1: T1): R;\n    }\n\n    interface CurriedFunction2<T1, T2, R> {\n        (): CurriedFunction2<T1, T2, R>;\n        (t1: T1): CurriedFunction1<T2, R>;\n        (t1: T1, t2: T2): R;\n    }\n\n    interface CurriedFunction3<T1, T2, T3, R> {\n        (): CurriedFunction3<T1, T2, T3, R>;\n        (t1: T1): CurriedFunction2<T2, T3, R>;\n        (t1: T1, t2: T2): CurriedFunction1<T3, R>;\n        (t1: T1, t2: T2, t3: T3): R;\n    }\n\n    interface CurriedFunction4<T1, T2, T3, T4, R> {\n        (): CurriedFunction4<T1, T2, T3, T4, R>;\n        (t1: T1): CurriedFunction3<T2, T3, T4, R>;\n        (t1: T1, t2: T2): CurriedFunction2<T3, T4, R>;\n        (t1: T1, t2: T2, t3: T3): CurriedFunction1<T4, R>;\n        (t1: T1, t2: T2, t3: T3, t4: T4): R;\n    }\n\n    interface CurriedFunction5<T1, T2, T3, T4, T5, R> {\n        (): CurriedFunction5<T1, T2, T3, T4, T5, R>;\n        (t1: T1): CurriedFunction4<T2, T3, T4, T5, R>;\n        (t1: T1, t2: T2): CurriedFunction3<T3, T4, T5, R>;\n        (t1: T1, t2: T2, t3: T3): CurriedFunction2<T4, T5, R>;\n        (t1: T1, t2: T2, t3: T3, t4: T4): CurriedFunction1<T5, R>;\n        (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): R;\n    }\n    interface RightCurriedFunction1<T1, R> {\n        (): RightCurriedFunction1<T1, R>;\n        (t1: T1): R;\n    }\n    interface RightCurriedFunction2<T1, T2, R> {\n        (): RightCurriedFunction2<T1, T2, R>;\n        (t2: T2): RightCurriedFunction1<T1, R>;\n        (t1: T1, t2: T2): R;\n    }\n    interface RightCurriedFunction3<T1, T2, T3, R> {\n        (): RightCurriedFunction3<T1, T2, T3, R>;\n        (t3: T3): RightCurriedFunction2<T1, T2, R>;\n        (t2: T2, t3: T3): RightCurriedFunction1<T1, R>;\n        (t1: T1, t2: T2, t3: T3): R;\n    }\n    interface RightCurriedFunction4<T1, T2, T3, T4, R> {\n        (): RightCurriedFunction4<T1, T2, T3, T4, R>;\n        (t4: T4): RightCurriedFunction3<T1, T2, T3, R>;\n        (t3: T3, t4: T4): RightCurriedFunction2<T1, T2, R>;\n        (t2: T2, t3: T3, t4: T4): RightCurriedFunction1<T1, R>;\n        (t1: T1, t2: T2, t3: T3, t4: T4): R;\n    }\n    interface RightCurriedFunction5<T1, T2, T3, T4, T5, R> {\n        (): RightCurriedFunction5<T1, T2, T3, T4, T5, R>;\n        (t5: T5): RightCurriedFunction4<T1, T2, T3, T4, R>;\n        (t4: T4, t5: T5): RightCurriedFunction3<T1, T2, T3, R>;\n        (t3: T3, t4: T4, t5: T5): RightCurriedFunction2<T1, T2, R>;\n        (t2: T2, t3: T3, t4: T4, t5: T5): RightCurriedFunction1<T1, R>;\n        (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): R;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n        * @see _.curry\n        **/\n        curry<T1, R>(this: LoDashImplicitWrapper<(t1: T1) => R>, arity?: number):\n            LoDashImplicitWrapper<CurriedFunction1<T1, R>>;\n\n        /**\n        * @see _.curry\n        **/\n        curry<T1, T2, R>(this: LoDashImplicitWrapper<(t1: T1, t2: T2) => R>, arity?: number):\n            LoDashImplicitWrapper<CurriedFunction2<T1, T2, R>>;\n\n        /**\n        * @see _.curry\n        **/\n        curry<T1, T2, T3, R>(this: LoDashImplicitWrapper<(t1: T1, t2: T2, t3: T3) => R>, arity?: number):\n            LoDashImplicitWrapper<CurriedFunction3<T1, T2, T3, R>>;\n\n        /**\n        * @see _.curry\n        **/\n        curry<T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<(t1: T1, t2: T2, t3: T3, t4: T4) => R>, arity?: number):\n            LoDashImplicitWrapper<CurriedFunction4<T1, T2, T3, T4, R>>;\n\n        /**\n        * @see _.curry\n        **/\n        curry<T1, T2, T3, T4, T5, R>(this: LoDashImplicitWrapper<(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5) => R>, arity?: number):\n            LoDashImplicitWrapper<CurriedFunction5<T1, T2, T3, T4, T5, R>>;\n\n        /**\n        * @see _.curry\n        **/\n        curry(arity?: number): LoDashImplicitWrapper<(...args: any[]) => any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n        * @see _.curry\n        **/\n        curry<T1, R>(this: LoDashExplicitWrapper<(t1: T1) => R>):\n            LoDashExplicitWrapper<CurriedFunction1<T1, R>>;\n\n        /**\n        * @see _.curry\n        **/\n        curry<T1, T2, R>(this: LoDashExplicitWrapper<(t1: T1, t2: T2) => R>):\n            LoDashExplicitWrapper<CurriedFunction2<T1, T2, R>>;\n\n        /**\n        * @see _.curry\n        **/\n        curry<T1, T2, T3, R>(this: LoDashExplicitWrapper<(t1: T1, t2: T2, t3: T3) => R>):\n            LoDashExplicitWrapper<CurriedFunction3<T1, T2, T3, R>>;\n\n        /**\n        * @see _.curry\n        **/\n        curry<T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<(t1: T1, t2: T2, t3: T3, t4: T4) => R>):\n            LoDashExplicitWrapper<CurriedFunction4<T1, T2, T3, T4, R>>;\n\n        /**\n        * @see _.curry\n        **/\n        curry<T1, T2, T3, T4, T5, R>(this: LoDashExplicitWrapper<(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5) => R>):\n            LoDashExplicitWrapper<CurriedFunction5<T1, T2, T3, T4, T5, R>>;\n\n        /**\n        * @see _.curry\n        **/\n        curry(arity?: number): LoDashExplicitWrapper<(...args: any[]) => any>;\n    }\n\n    //_.curryRight\n    interface LoDashStatic {\n        /**\n         * This method is like _.curry except that arguments are applied to func in the manner of _.partialRight\n         * instead of _.partial.\n         * @param func The function to curry.\n         * @param arity The arity of func.\n         * @return Returns the new curried function.\n         */\n        curryRight<T1, R>(func: (t1: T1) => R, arity?: number):\n            RightCurriedFunction1<T1, R>;\n        /**\n         * This method is like _.curry except that arguments are applied to func in the manner of _.partialRight\n         * instead of _.partial.\n         * @param func The function to curry.\n         * @param arity The arity of func.\n         * @return Returns the new curried function.\n         */\n        curryRight<T1, T2, R>(func: (t1: T1, t2: T2) => R, arity?: number):\n            RightCurriedFunction2<T1, T2, R>;\n        /**\n         * This method is like _.curry except that arguments are applied to func in the manner of _.partialRight\n         * instead of _.partial.\n         * @param func The function to curry.\n         * @param arity The arity of func.\n         * @return Returns the new curried function.\n         */\n        curryRight<T1, T2, T3, R>(func: (t1: T1, t2: T2, t3: T3) => R, arity?: number):\n            RightCurriedFunction3<T1, T2, T3, R>;\n        /**\n         * This method is like _.curry except that arguments are applied to func in the manner of _.partialRight\n         * instead of _.partial.\n         * @param func The function to curry.\n         * @param arity The arity of func.\n         * @return Returns the new curried function.\n         */\n        curryRight<T1, T2, T3, T4, R>(func: (t1: T1, t2: T2, t3: T3, t4: T4) => R, arity?: number):\n            RightCurriedFunction4<T1, T2, T3, T4, R>;\n        /**\n         * This method is like _.curry except that arguments are applied to func in the manner of _.partialRight\n         * instead of _.partial.\n         * @param func The function to curry.\n         * @param arity The arity of func.\n         * @return Returns the new curried function.\n         */\n        curryRight<T1, T2, T3, T4, T5, R>(func: (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5) => R, arity?: number):\n            RightCurriedFunction5<T1, T2, T3, T4, T5, R>;\n        /**\n         * This method is like _.curry except that arguments are applied to func in the manner of _.partialRight\n         * instead of _.partial.\n         * @param func The function to curry.\n         * @param arity The arity of func.\n         * @return Returns the new curried function.\n         */\n        curryRight(func: (...args: any[]) => any, arity?: number): (...args: any[]) => any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.curryRight\n         **/\n        curryRight<T1, R>(this: LoDashImplicitWrapper<(t1: T1) => R>, arity?: number):\n            LoDashImplicitWrapper<RightCurriedFunction1<T1, R>>;\n\n        /**\n         * @see _.curryRight\n         **/\n        curryRight<T1, T2, R>(this: LoDashImplicitWrapper<(t1: T1, t2: T2) => R>, arity?: number):\n            LoDashImplicitWrapper<RightCurriedFunction2<T1, T2, R>>;\n\n        /**\n         * @see _.curryRight\n         **/\n        curryRight<T1, T2, T3, R>(this: LoDashImplicitWrapper<(t1: T1, t2: T2, t3: T3) => R>, arity?: number):\n            LoDashImplicitWrapper<RightCurriedFunction3<T1, T2, T3, R>>;\n\n        /**\n         * @see _.curryRight\n         **/\n        curryRight<T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<(t1: T1, t2: T2, t3: T3, t4: T4) => R>, arity?: number):\n            LoDashImplicitWrapper<RightCurriedFunction4<T1, T2, T3, T4, R>>;\n\n        /**\n         * @see _.curryRight\n         **/\n        curryRight<T1, T2, T3, T4, T5, R>(this: LoDashImplicitWrapper<(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5) => R>, arity?: number):\n            LoDashImplicitWrapper<RightCurriedFunction5<T1, T2, T3, T4, T5, R>>;\n\n        /**\n         * @see _.curryRight\n         **/\n        curryRight(arity?: number): LoDashImplicitWrapper<(...args: any[]) => any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.curryRight\n         **/\n        curryRight<T1, R>(this: LoDashExplicitWrapper<(t1: T1) => R>, arity?: number):\n            LoDashExplicitWrapper<RightCurriedFunction1<T1, R>>;\n\n        /**\n         * @see _.curryRight\n         **/\n        curryRight<T1, T2, R>(this: LoDashExplicitWrapper<(t1: T1, t2: T2) => R>, arity?: number):\n            LoDashExplicitWrapper<RightCurriedFunction2<T1, T2, R>>;\n\n        /**\n         * @see _.curryRight\n         **/\n        curryRight<T1, T2, T3, R>(this: LoDashExplicitWrapper<(t1: T1, t2: T2, t3: T3) => R>, arity?: number):\n            LoDashExplicitWrapper<RightCurriedFunction3<T1, T2, T3, R>>;\n\n        /**\n         * @see _.curryRight\n         **/\n        curryRight<T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<(t1: T1, t2: T2, t3: T3, t4: T4) => R>, arity?: number):\n            LoDashExplicitWrapper<RightCurriedFunction4<T1, T2, T3, T4, R>>;\n\n        /**\n         * @see _.curryRight\n         **/\n        curryRight<T1, T2, T3, T4, T5, R>(this: LoDashExplicitWrapper<(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5) => R>, arity?: number):\n            LoDashExplicitWrapper<RightCurriedFunction5<T1, T2, T3, T4, T5, R>>;\n\n        /**\n         * @see _.curryRight\n         **/\n        curryRight(arity?: number): LoDashExplicitWrapper<(...args: any[]) => any>;\n    }\n\n    //_.debounce\n    interface DebounceSettings {\n        /**\n         * Specify invoking on the leading edge of the timeout.\n         */\n        leading?: boolean;\n\n        /**\n         * The maximum time func is allowed to be delayed before itâs invoked.\n         */\n        maxWait?: number;\n\n        /**\n         * Specify invoking on the trailing edge of the timeout.\n         */\n        trailing?: boolean;\n    }\n\n    interface LoDashStatic {\n        /**\n         * Creates a debounced function that delays invoking func until after wait milliseconds have elapsed since\n         * the last time the debounced function was invoked. The debounced function comes with a cancel method to\n         * cancel delayed invocations and a flush method to immediately invoke them. Provide an options object to\n         * indicate that func should be invoked on the leading and/or trailing edge of the wait timeout. Subsequent\n         * calls to the debounced function return the result of the last func invocation.\n         *\n         * Note: If leading and trailing options are true, func is invoked on the trailing edge of the timeout only\n         * if the the debounced function is invoked more than once during the wait timeout.\n         *\n         * See David Corbachoâs article for details over the differences between _.debounce and _.throttle.\n         *\n         * @param func The function to debounce.\n         * @param wait The number of milliseconds to delay.\n         * @param options The options object.\n         * @param options.leading Specify invoking on the leading edge of the timeout.\n         * @param options.maxWait The maximum time func is allowed to be delayed before itâs invoked.\n         * @param options.trailing Specify invoking on the trailing edge of the timeout.\n         * @return Returns the new debounced function.\n         */\n        debounce<T extends (...args: any[]) => any>(\n            func: T,\n            wait?: number,\n            options?: DebounceSettings\n        ): T & Cancelable;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.debounce\n         */\n        debounce(\n            wait?: number,\n            options?: DebounceSettings\n        ): LoDashImplicitWrapper<TValue & Cancelable>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.debounce\n         */\n        debounce(\n            wait?: number,\n            options?: DebounceSettings\n        ): LoDashExplicitWrapper<TValue & Cancelable>;\n    }\n\n    //_.defer\n    interface LoDashStatic {\n        /**\n         * Defers invoking the func until the current call stack has cleared. Any additional arguments are provided to\n         * func when itâs invoked.\n         *\n         * @param func The function to defer.\n         * @param args The arguments to invoke the function with.\n         * @return Returns the timer id.\n         */\n        defer(\n            func: (...args: any[]) => any,\n            ...args: any[]\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.defer\n         */\n        defer(...args: any[]): LoDashImplicitWrapper<number>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.defer\n         */\n        defer(...args: any[]): LoDashExplicitWrapper<number>;\n    }\n\n    //_.delay\n    interface LoDashStatic {\n        /**\n         * Invokes func after wait milliseconds. Any additional arguments are provided to func when itâs invoked.\n         *\n         * @param func The function to delay.\n         * @param wait The number of milliseconds to delay invocation.\n         * @param args The arguments to invoke the function with.\n         * @return Returns the timer id.\n         */\n        delay(\n            func: (...args: any[]) => any,\n            wait: number,\n            ...args: any[]\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.delay\n         */\n        delay(\n            wait: number,\n            ...args: any[]\n        ): LoDashImplicitWrapper<number>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.delay\n         */\n        delay(\n            wait: number,\n            ...args: any[]\n        ): LoDashExplicitWrapper<number>;\n    }\n\n    interface LoDashStatic {\n        /**\n         * Creates a function that invokes `func` with arguments reversed.\n         *\n         * @category Function\n         * @param func The function to flip arguments for.\n         * @returns Returns the new function.\n         * @example\n         *\n         * var flipped = _.flip(function() {\n         *   return _.toArray(arguments);\n         * });\n         *\n         * flipped('a', 'b', 'c', 'd');\n         * // => ['d', 'c', 'b', 'a']\n         */\n        flip<T extends (...args: any[]) => any>(func: T): T;\n    }\n\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.flip\n         */\n        flip(): this;\n    }\n\n    //_.flow\n    interface LoDashStatic {\n        /**\n         * Creates a function that returns the result of invoking the provided functions with the this binding of the\n         * created function, where each successive invocation is supplied the return value of the previous.\n         *\n         * @param funcs Functions to invoke.\n         * @return Returns the new function.\n         */\n        // 0-argument first function\n        flow<R1, R2>(f1: () => R1, f2: (a: R1) => R2): () => R2;\n        flow<R1, R2, R3>(f1: () => R1, f2: (a: R1) => R2, f3: (a: R2) => R3): () => R3;\n        flow<R1, R2, R3, R4>(f1: () => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): () => R4;\n        flow<R1, R2, R3, R4, R5>(f1: () => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): () => R5;\n        flow<R1, R2, R3, R4, R5, R6>(f1: () => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): () => R6;\n        flow<R1, R2, R3, R4, R5, R6, R7>(f1: () => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): () => R7;\n        flow<R1, R2, R3, R4, R5, R6, R7>(f1: () => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): () => any;\n        // 1-argument first function\n        flow<A1, R1, R2>(f1: (a1: A1) => R1, f2: (a: R1) => R2): (a1: A1) => R2;\n        flow<A1, R1, R2, R3>(f1: (a1: A1) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3): (a1: A1) => R3;\n        flow<A1, R1, R2, R3, R4>(f1: (a1: A1) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): (a1: A1) => R4;\n        flow<A1, R1, R2, R3, R4, R5>(f1: (a1: A1) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): (a1: A1) => R5;\n        flow<A1, R1, R2, R3, R4, R5, R6>(f1: (a1: A1) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): (a1: A1) => R6;\n        flow<A1, R1, R2, R3, R4, R5, R6, R7>(f1: (a1: A1) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): (a1: A1) => R7;\n        flow<A1, R1, R2, R3, R4, R5, R6, R7>(f1: (a1: A1) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): (a1: A1) => any;\n        // 2-argument first function\n        flow<A1, A2, R1, R2>(f1: (a1: A1, a2: A2) => R1, f2: (a: R1) => R2): (a1: A1, a2: A2) => R2;\n        flow<A1, A2, R1, R2, R3>(f1: (a1: A1, a2: A2) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3): (a1: A1, a2: A2) => R3;\n        flow<A1, A2, R1, R2, R3, R4>(f1: (a1: A1, a2: A2) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): (a1: A1, a2: A2) => R4;\n        flow<A1, A2, R1, R2, R3, R4, R5>(f1: (a1: A1, a2: A2) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): (a1: A1, a2: A2) => R5;\n        flow<A1, A2, R1, R2, R3, R4, R5, R6>(f1: (a1: A1, a2: A2) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): (a1: A1, a2: A2) => R6;\n        flow<A1, A2, R1, R2, R3, R4, R5, R6, R7>(f1: (a1: A1, a2: A2) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): (a1: A1, a2: A2) => R7;\n        flow<A1, A2, R1, R2, R3, R4, R5, R6, R7>(f1: (a1: A1, a2: A2) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): (a1: A1, a2: A2) => any;\n        // 3-argument first function\n        flow<A1, A2, A3, R1, R2>(f1: (a1: A1, a2: A2, a3: A3) => R1, f2: (a: R1) => R2): (a1: A1, a2: A2, a3: A3) => R2;\n        flow<A1, A2, A3, R1, R2, R3>(f1: (a1: A1, a2: A2, a3: A3) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3): (a1: A1, a2: A2, a3: A3) => R3;\n        flow<A1, A2, A3, R1, R2, R3, R4>(f1: (a1: A1, a2: A2, a3: A3) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): (a1: A1, a2: A2, a3: A3) => R4;\n        flow<A1, A2, A3, R1, R2, R3, R4, R5>(f1: (a1: A1, a2: A2, a3: A3) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): (a1: A1, a2: A2, a3: A3) => R5;\n        flow<A1, A2, A3, R1, R2, R3, R4, R5, R6>(f1: (a1: A1, a2: A2, a3: A3) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): (a1: A1, a2: A2, a3: A3) => R6;\n        flow<A1, A2, A3, R1, R2, R3, R4, R5, R6, R7>(f1: (a1: A1, a2: A2, a3: A3) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): (a1: A1, a2: A2, a3: A3) => R7;\n        flow<A1, A2, A3, R1, R2, R3, R4, R5, R6, R7>(f1: (a1: A1, a2: A2, a3: A3) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): (a1: A1, a2: A2, a3: A3) => any;\n        // 4-argument first function\n        flow<A1, A2, A3, A4, R1, R2>(f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1, f2: (a: R1) => R2): (a1: A1, a2: A2, a3: A3, a4: A4) => R2;\n        flow<A1, A2, A3, A4, R1, R2, R3>(f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3): (a1: A1, a2: A2, a3: A3, a4: A4) => R3;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4>(f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): (a1: A1, a2: A2, a3: A3, a4: A4) => R4;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5>(f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): (a1: A1, a2: A2, a3: A3, a4: A4) => R5;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6>(f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): (a1: A1, a2: A2, a3: A3, a4: A4) => R6;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6, R7>(f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): (a1: A1, a2: A2, a3: A3, a4: A4) => R7;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6, R7>(f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): (a1: A1, a2: A2, a3: A3, a4: A4) => any;\n        // any-argument first function\n        flow<A1, A2, A3, A4, R1, R2>(f1: (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1, f2: (a: R1) => R2): (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R2;\n        flow<A1, A2, A3, A4, R1, R2, R3>(f1: (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3): (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R3;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4>(f1: (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R4;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5>(f1: (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R5;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6>(f1: (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R6;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6, R7>(f1: (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R7;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6, R7>(f1: (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): (a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => any;\n        flow(funcs: Array<Many<(...args: any[]) => any>>): (...args: any[]) => any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.flow\n         */\n        // 0-argument first function\n        flow<R1, R2>(this: LoDashImplicitWrapper<() => R1>, f2: (a: R1) => R2): LoDashImplicitWrapper<() => R2>;\n        flow<R1, R2, R3>(this: LoDashImplicitWrapper<() => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3): LoDashImplicitWrapper<() => R3>;\n        flow<R1, R2, R3, R4>(this: LoDashImplicitWrapper<() => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): LoDashImplicitWrapper<() => R4>;\n        flow<R1, R2, R3, R4, R5>(this: LoDashImplicitWrapper<() => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): LoDashImplicitWrapper<() => R5>;\n        flow<R1, R2, R3, R4, R5, R6>(this: LoDashImplicitWrapper<() => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): LoDashImplicitWrapper<() => R6>;\n        flow<R1, R2, R3, R4, R5, R6, R7>(this: LoDashImplicitWrapper<() => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): LoDashImplicitWrapper<() => R7>;\n        flow<R1, R2, R3, R4, R5, R6, R7>(this: LoDashImplicitWrapper<() => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): LoDashImplicitWrapper<() => any>;\n        // 1-argument first function\n        flow<A1, R1, R2>(this: LoDashImplicitWrapper<(a1: A1) => R1>, f2: (a: R1) => R2): LoDashImplicitWrapper<(a1: A1) => R2>;\n        flow<A1, R1, R2, R3>(this: LoDashImplicitWrapper<(a1: A1) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3): LoDashImplicitWrapper<(a1: A1) => R3>;\n        flow<A1, R1, R2, R3, R4>(this: LoDashImplicitWrapper<(a1: A1) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): LoDashImplicitWrapper<(a1: A1) => R4>;\n        flow<A1, R1, R2, R3, R4, R5>(this: LoDashImplicitWrapper<(a1: A1) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): LoDashImplicitWrapper<(a1: A1) => R5>;\n        flow<A1, R1, R2, R3, R4, R5, R6>(this: LoDashImplicitWrapper<(a1: A1) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): LoDashImplicitWrapper<(a1: A1) => R6>;\n        flow<A1, R1, R2, R3, R4, R5, R6, R7>(this: LoDashImplicitWrapper<(a1: A1) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): LoDashImplicitWrapper<(a1: A1) => R7>;\n        flow<A1, R1, R2, R3, R4, R5, R6, R7>(this: LoDashImplicitWrapper<(a1: A1) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): LoDashImplicitWrapper<(a1: A1) => any>;\n        // 2-argument first function\n        flow<A1, A2, R1, R2>(this: LoDashImplicitWrapper<(a1: A1, a2: A2) => R1>, f2: (a: R1) => R2): LoDashImplicitWrapper<(a1: A1, a2: A2) => R2>;\n        flow<A1, A2, R1, R2, R3>(this: LoDashImplicitWrapper<(a1: A1, a2: A2) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3): LoDashImplicitWrapper<(a1: A1, a2: A2) => R3>;\n        flow<A1, A2, R1, R2, R3, R4>(this: LoDashImplicitWrapper<(a1: A1, a2: A2) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): LoDashImplicitWrapper<(a1: A1, a2: A2) => R4>;\n        flow<A1, A2, R1, R2, R3, R4, R5>(this: LoDashImplicitWrapper<(a1: A1, a2: A2) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): LoDashImplicitWrapper<(a1: A1, a2: A2) => R5>;\n        flow<A1, A2, R1, R2, R3, R4, R5, R6>(this: LoDashImplicitWrapper<(a1: A1, a2: A2) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): LoDashImplicitWrapper<(a1: A1, a2: A2) => R6>;\n        flow<A1, A2, R1, R2, R3, R4, R5, R6, R7>(this: LoDashImplicitWrapper<(a1: A1, a2: A2) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): LoDashImplicitWrapper<(a1: A1, a2: A2) => R7>;\n        flow<A1, A2, R1, R2, R3, R4, R5, R6, R7>(this: LoDashImplicitWrapper<(a1: A1, a2: A2) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): LoDashImplicitWrapper<(a1: A1, a2: A2) => any>;\n        // 3-argument first function\n        flow<A1, A2, A3, R1, R2>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R1>, f2: (a: R1) => R2): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R2>;\n        flow<A1, A2, A3, R1, R2, R3>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R3>;\n        flow<A1, A2, A3, R1, R2, R3, R4>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R4>;\n        flow<A1, A2, A3, R1, R2, R3, R4, R5>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R5>;\n        flow<A1, A2, A3, R1, R2, R3, R4, R5, R6>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R6>;\n        flow<A1, A2, A3, R1, R2, R3, R4, R5, R6, R7>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R7>;\n        flow<A1, A2, A3, R1, R2, R3, R4, R5, R6, R7>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => any>;\n        // 4-argument first function\n        flow<A1, A2, A3, A4, R1, R2>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R1>, f2: (a: R1) => R2): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R2>;\n        flow<A1, A2, A3, A4, R1, R2, R3>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R3>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R4>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R5>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R6>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6, R7>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R7>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6, R7>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => any>;\n        // any-argument first function\n        flow<A1, A2, A3, A4, R1, R2>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1>, f2: (a: R1) => R2): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R2>;\n        flow<A1, A2, A3, A4, R1, R2, R3>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R3>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R4>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R5>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R6>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6, R7>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R7>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6, R7>(this: LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => any>;\n        flow(this: LoDashImplicitWrapper<(...args: any[]) => any>, funcs: Array<Many<(a: any) => any>>): LoDashImplicitWrapper<(...args: any[]) => any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.flow\n         */\n        // 0-argument first function\n        flow<R1, R2>(this: LoDashExplicitWrapper<() => R1>, f2: (a: R1) => R2): LoDashExplicitWrapper<() => R2>;\n        flow<R1, R2, R3>(this: LoDashExplicitWrapper<() => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3): LoDashExplicitWrapper<() => R3>;\n        flow<R1, R2, R3, R4>(this: LoDashExplicitWrapper<() => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): LoDashExplicitWrapper<() => R4>;\n        flow<R1, R2, R3, R4, R5>(this: LoDashExplicitWrapper<() => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): LoDashExplicitWrapper<() => R5>;\n        flow<R1, R2, R3, R4, R5, R6>(this: LoDashExplicitWrapper<() => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): LoDashExplicitWrapper<() => R6>;\n        flow<R1, R2, R3, R4, R5, R6, R7>(this: LoDashExplicitWrapper<() => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): LoDashExplicitWrapper<() => R7>;\n        flow<R1, R2, R3, R4, R5, R6, R7>(this: LoDashExplicitWrapper<() => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): LoDashExplicitWrapper<() => any>;\n        // 1-argument first function\n        flow<A1, R1, R2>(this: LoDashExplicitWrapper<(a1: A1) => R1>, f2: (a: R1) => R2): LoDashExplicitWrapper<(a1: A1) => R2>;\n        flow<A1, R1, R2, R3>(this: LoDashExplicitWrapper<(a1: A1) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3): LoDashExplicitWrapper<(a1: A1) => R3>;\n        flow<A1, R1, R2, R3, R4>(this: LoDashExplicitWrapper<(a1: A1) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): LoDashExplicitWrapper<(a1: A1) => R4>;\n        flow<A1, R1, R2, R3, R4, R5>(this: LoDashExplicitWrapper<(a1: A1) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): LoDashExplicitWrapper<(a1: A1) => R5>;\n        flow<A1, R1, R2, R3, R4, R5, R6>(this: LoDashExplicitWrapper<(a1: A1) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): LoDashExplicitWrapper<(a1: A1) => R6>;\n        flow<A1, R1, R2, R3, R4, R5, R6, R7>(this: LoDashExplicitWrapper<(a1: A1) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): LoDashExplicitWrapper<(a1: A1) => R7>;\n        flow<A1, R1, R2, R3, R4, R5, R6, R7>(this: LoDashExplicitWrapper<(a1: A1) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): LoDashExplicitWrapper<(a1: A1) => any>;\n        // 2-argument first function\n        flow<A1, A2, R1, R2>(this: LoDashExplicitWrapper<(a1: A1, a2: A2) => R1>, f2: (a: R1) => R2): LoDashExplicitWrapper<(a1: A1, a2: A2) => R2>;\n        flow<A1, A2, R1, R2, R3>(this: LoDashExplicitWrapper<(a1: A1, a2: A2) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3): LoDashExplicitWrapper<(a1: A1, a2: A2) => R3>;\n        flow<A1, A2, R1, R2, R3, R4>(this: LoDashExplicitWrapper<(a1: A1, a2: A2) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): LoDashExplicitWrapper<(a1: A1, a2: A2) => R4>;\n        flow<A1, A2, R1, R2, R3, R4, R5>(this: LoDashExplicitWrapper<(a1: A1, a2: A2) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): LoDashExplicitWrapper<(a1: A1, a2: A2) => R5>;\n        flow<A1, A2, R1, R2, R3, R4, R5, R6>(this: LoDashExplicitWrapper<(a1: A1, a2: A2) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): LoDashExplicitWrapper<(a1: A1, a2: A2) => R6>;\n        flow<A1, A2, R1, R2, R3, R4, R5, R6, R7>(this: LoDashExplicitWrapper<(a1: A1, a2: A2) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): LoDashExplicitWrapper<(a1: A1, a2: A2) => R7>;\n        flow<A1, A2, R1, R2, R3, R4, R5, R6, R7>(this: LoDashExplicitWrapper<(a1: A1, a2: A2) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): LoDashExplicitWrapper<(a1: A1, a2: A2) => any>;\n        // 3-argument first function\n        flow<A1, A2, A3, R1, R2>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R1>, f2: (a: R1) => R2): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R2>;\n        flow<A1, A2, A3, R1, R2, R3>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R3>;\n        flow<A1, A2, A3, R1, R2, R3, R4>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R4>;\n        flow<A1, A2, A3, R1, R2, R3, R4, R5>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R5>;\n        flow<A1, A2, A3, R1, R2, R3, R4, R5, R6>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R6>;\n        flow<A1, A2, A3, R1, R2, R3, R4, R5, R6, R7>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R7>;\n        flow<A1, A2, A3, R1, R2, R3, R4, R5, R6, R7>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => any>;\n        // 4-argument first function\n        flow<A1, A2, A3, A4, R1, R2>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R1>, f2: (a: R1) => R2): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R2>;\n        flow<A1, A2, A3, A4, R1, R2, R3>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R3>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R4>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R5>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R6>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6, R7>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R7>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6, R7>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => any>;\n        // any-argument first function\n        flow<A1, A2, A3, A4, R1, R2>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1>, f2: (a: R1) => R2): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R2>;\n        flow<A1, A2, A3, A4, R1, R2, R3>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R3>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R4>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R5>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R6>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6, R7>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R7>;\n        flow<A1, A2, A3, A4, R1, R2, R3, R4, R5, R6, R7>(this: LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => R1>, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...funcs: Array<Many<(a: any) => any>>): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4, ...args: any[]) => any>;\n        flow(this: LoDashExplicitWrapper<(...args: any[]) => any>, funcs: Array<Many<(a: any) => any>>): LoDashExplicitWrapper<(...args: any[]) => any>;\n    }\n\n    //_.flowRight\n    interface LoDashStatic {\n        /**\n         * This method is like _.flow except that it creates a function that invokes the provided functions from right\n         * to left.\n         *\n         * @param funcs Functions to invoke.\n         * @return Returns the new function.\n         */\n        // 0-argument first function\n        flowRight<R2, R1>(f2: (a: R1) => R2, f1: () => R1): () => R2;\n        flowRight<R3, R2, R1>(f3: (a: R2) => R3, f2: (a: R1) => R2, f1: () => R1): () => R3;\n        flowRight<R4, R3, R2, R1>(f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: () => R1): () => R4;\n        flowRight<R5, R4, R3, R2, R1>(f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: () => R1): () => R5;\n        flowRight<R6, R5, R4, R3, R2, R1>(f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: () => R1): () => R6;\n        flowRight<R7, R6, R5, R4, R3, R2, R1>(f7: (a: R6) => R7, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: () => R1): () => R7;\n        // 1-argument first function\n        flowRight<A1, R2, R1>(f2: (a: R1) => R2, f1: (a1: A1) => R1): (a1: A1) => R2;\n        flowRight<A1, R3, R2, R1>(f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1) => R1): (a1: A1) => R3;\n        flowRight<A1, R4, R3, R2, R1>(f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1) => R1): (a1: A1) => R4;\n        flowRight<A1, R5, R4, R3, R2, R1>(f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1) => R1): (a1: A1) => R5;\n        flowRight<A1, R6, R5, R4, R3, R2, R1>(f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1) => R1): (a1: A1) => R6;\n        flowRight<A1, R7, R6, R5, R4, R3, R2, R1>(f7: (a: R6) => R7, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1) => R1): (a1: A1) => R7;\n        // 2-argument first function\n        flowRight<A1, A2, R2, R1>(f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): (a1: A1, a2: A2) => R2;\n        flowRight<A1, A2, R3, R2, R1>(f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): (a1: A1, a2: A2) => R3;\n        flowRight<A1, A2, R4, R3, R2, R1>(f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): (a1: A1, a2: A2) => R4;\n        flowRight<A1, A2, R5, R4, R3, R2, R1>(f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): (a1: A1, a2: A2) => R5;\n        flowRight<A1, A2, R6, R5, R4, R3, R2, R1>(f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): (a1: A1, a2: A2) => R6;\n        flowRight<A1, A2, R7, R6, R5, R4, R3, R2, R1>(f7: (a: R6) => R7, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): (a1: A1, a2: A2) => R7;\n        // 3-argument first function\n        flowRight<A1, A2, A3, R2, R1>(f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): (a1: A1, a2: A2, a3: A3) => R2;\n        flowRight<A1, A2, A3, R3, R2, R1>(f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): (a1: A1, a2: A2, a3: A3) => R3;\n        flowRight<A1, A2, A3, R4, R3, R2, R1>(f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): (a1: A1, a2: A2, a3: A3) => R4;\n        flowRight<A1, A2, A3, R5, R4, R3, R2, R1>(f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): (a1: A1, a2: A2, a3: A3) => R5;\n        flowRight<A1, A2, A3, R6, R5, R4, R3, R2, R1>(f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): (a1: A1, a2: A2, a3: A3) => R6;\n        flowRight<A1, A2, A3, R7, R6, R5, R4, R3, R2, R1>(f7: (a: R6) => R7, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): (a1: A1, a2: A2, a3: A3) => R7;\n        // 4-argument first function\n        flowRight<A1, A2, A3, A4, R2, R1>(f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): (a1: A1, a2: A2, a3: A3, a4: A4) => R2;\n        flowRight<A1, A2, A3, A4, R3, R2, R1>(f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): (a1: A1, a2: A2, a3: A3, a4: A4) => R3;\n        flowRight<A1, A2, A3, A4, R4, R3, R2, R1>(f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): (a1: A1, a2: A2, a3: A3, a4: A4) => R4;\n        flowRight<A1, A2, A3, A4, R5, R4, R3, R2, R1>(f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): (a1: A1, a2: A2, a3: A3, a4: A4) => R5;\n        flowRight<A1, A2, A3, A4, R6, R5, R4, R3, R2, R1>(f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): (a1: A1, a2: A2, a3: A3, a4: A4) => R6;\n        flowRight<A1, A2, A3, A4, R7, R6, R5, R4, R3, R2, R1>(f7: (a: R6) => R7, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): (a1: A1, a2: A2, a3: A3, a4: A4) => R7;\n        // any-argument first function\n        flowRight<R2, R1>(f2: (a: R1) => R2, f1: (...args: any[]) => R1): (...args: any[]) => R2;\n        flowRight<R3, R2, R1>(f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: any[]) => R1): (...args: any[]) => R3;\n        flowRight<R4, R3, R2, R1>(f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: any[]) => R1): (...args: any[]) => R4;\n        flowRight<R5, R4, R3, R2, R1>(f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: any[]) => R1): (...args: any[]) => R5;\n        flowRight<R6, R5, R4, R3, R2, R1>(f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: any[]) => R1): (...args: any[]) => R6;\n        flowRight<R7, R6, R5, R4, R3, R2, R1>(f7: (a: R6) => R7, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: any[]) => R1): (...args: any[]) => R7;\n        flowRight(f7: (a: any) => any, f6: (a: any) => any, f5: (a: any) => any, f4: (a: any) => any, f3: (a: any) => any, f2: (a: any) => any, f1: () => any, ...funcs: Array<Many<(...args: any[]) => any>>): (...args: any[]) => any;\n        flowRight(funcs: Array<Many<(...args: any[]) => any>>): (...args: any[]) => any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.flowRight\n         */\n        // 0-argument first function\n        flowRight<R2, R1>(this: LoDashImplicitWrapper<(a: R1) => R2>, f1: () => R1): LoDashImplicitWrapper<() => R2>;\n        flowRight<R3, R2, R1>(this: LoDashImplicitWrapper<(a: R2) => R3>, f2: (a: R1) => R2, f1: () => R1): LoDashImplicitWrapper<() => R3>;\n        flowRight<R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R3) => R4>, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: () => R1): LoDashImplicitWrapper<() => R4>;\n        flowRight<R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R4) => R5>, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: () => R1): LoDashImplicitWrapper<() => R5>;\n        flowRight<R6, R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R5) => R6>, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: () => R1): LoDashImplicitWrapper<() => R6>;\n        flowRight<R7, R6, R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R6) => R7>, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: () => R1): LoDashImplicitWrapper<() => R7>;\n        // 1-argument first function\n        flowRight<A1, R2, R1>(this: LoDashImplicitWrapper<(a: R1) => R2>, f1: (a1: A1) => R1): LoDashImplicitWrapper<(a1: A1) => R2>;\n        flowRight<A1, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R2) => R3>, f2: (a: R1) => R2, f1: (a1: A1) => R1): LoDashImplicitWrapper<(a1: A1) => R3>;\n        flowRight<A1, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R3) => R4>, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1) => R1): LoDashImplicitWrapper<(a1: A1) => R4>;\n        flowRight<A1, R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R4) => R5>, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1) => R1): LoDashImplicitWrapper<(a1: A1) => R5>;\n        flowRight<A1, R6, R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R5) => R6>, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1) => R1): LoDashImplicitWrapper<(a1: A1) => R6>;\n        flowRight<A1, R7, R6, R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R6) => R7>, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1) => R1): LoDashImplicitWrapper<(a1: A1) => R7>;\n        // 2-argument first function\n        flowRight<A1, A2, R2, R1>(this: LoDashImplicitWrapper<(a: R1) => R2>, f1: (a1: A1, a2: A2) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2) => R2>;\n        flowRight<A1, A2, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R2) => R3>, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2) => R3>;\n        flowRight<A1, A2, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R3) => R4>, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2) => R4>;\n        flowRight<A1, A2, R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R4) => R5>, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2) => R5>;\n        flowRight<A1, A2, R6, R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R5) => R6>, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2) => R6>;\n        flowRight<A1, A2, R7, R6, R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R6) => R7>, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2) => R7>;\n        // 3-argument first function\n        flowRight<A1, A2, A3, R2, R1>(this: LoDashImplicitWrapper<(a: R1) => R2>, f1: (a1: A1, a2: A2, a3: A3) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R2>;\n        flowRight<A1, A2, A3, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R2) => R3>, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R3>;\n        flowRight<A1, A2, A3, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R3) => R4>, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R4>;\n        flowRight<A1, A2, A3, R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R4) => R5>, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R5>;\n        flowRight<A1, A2, A3, R6, R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R5) => R6>, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R6>;\n        flowRight<A1, A2, A3, R7, R6, R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R6) => R7>, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3) => R7>;\n        // 4-argument first function\n        flowRight<A1, A2, A3, A4, R2, R1>(this: LoDashImplicitWrapper<(a: R1) => R2>, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R2>;\n        flowRight<A1, A2, A3, A4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R2) => R3>, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R3>;\n        flowRight<A1, A2, A3, A4, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R3) => R4>, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R4>;\n        flowRight<A1, A2, A3, A4, R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R4) => R5>, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R5>;\n        flowRight<A1, A2, A3, A4, R6, R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R5) => R6>, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R6>;\n        flowRight<A1, A2, A3, A4, R7, R6, R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R6) => R7>, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): LoDashImplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R7>;\n        // any-argument first function\n        flowRight<R2, R1>(this: LoDashImplicitWrapper<(a: R1) => R2>, f1: (...args: any[]) => R1): LoDashImplicitWrapper<(...args: any[]) => R2>;\n        flowRight<R3, R2, R1>(this: LoDashImplicitWrapper<(a: R1) => R2>, f2: (a: R1) => R2, f1: (...args: any[]) => R1): LoDashImplicitWrapper<(...args: any[]) => R3>;\n        flowRight<R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R1) => R2>, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: any[]) => R1): LoDashImplicitWrapper<(...args: any[]) => R4>;\n        flowRight<R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R1) => R2>, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: any[]) => R1): LoDashImplicitWrapper<(...args: any[]) => R5>;\n        flowRight<R6, R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R1) => R2>, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: any[]) => R1): LoDashImplicitWrapper<(...args: any[]) => R6>;\n        flowRight<R7, R6, R5, R4, R3, R2, R1>(this: LoDashImplicitWrapper<(a: R1) => R2>, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: any[]) => R1): LoDashImplicitWrapper<(...args: any[]) => R7>;\n        flowRight(this: LoDashImplicitWrapper<(a: any) => any>, f6: (a: any) => any, f5: (a: any) => any, f4: (a: any) => any, f3: (a: any) => any, f2: (a: any) => any, f1: () => any, ...funcs: Array<Many<(...args: any[]) => any>>): LoDashImplicitWrapper<(...args: any[]) => any>;\n        flowRight(this: LoDashImplicitWrapper<(a: any) => any>, funcs: Array<Many<(...args: any[]) => any>>): LoDashImplicitWrapper<(...args: any[]) => any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.flowRight\n         */\n        // 0-argument first function\n        flowRight<R2, R1>(this: LoDashExplicitWrapper<(a: R1) => R2>, f1: () => R1): LoDashExplicitWrapper<() => R2>;\n        flowRight<R3, R2, R1>(this: LoDashExplicitWrapper<(a: R2) => R3>, f2: (a: R1) => R2, f1: () => R1): LoDashExplicitWrapper<() => R3>;\n        flowRight<R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R3) => R4>, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: () => R1): LoDashExplicitWrapper<() => R4>;\n        flowRight<R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R4) => R5>, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: () => R1): LoDashExplicitWrapper<() => R5>;\n        flowRight<R6, R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R5) => R6>, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: () => R1): LoDashExplicitWrapper<() => R6>;\n        flowRight<R7, R6, R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R6) => R7>, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: () => R1): LoDashExplicitWrapper<() => R7>;\n        // 1-argument first function\n        flowRight<A1, R2, R1>(this: LoDashExplicitWrapper<(a: R1) => R2>, f1: (a1: A1) => R1): LoDashExplicitWrapper<(a1: A1) => R2>;\n        flowRight<A1, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R2) => R3>, f2: (a: R1) => R2, f1: (a1: A1) => R1): LoDashExplicitWrapper<(a1: A1) => R3>;\n        flowRight<A1, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R3) => R4>, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1) => R1): LoDashExplicitWrapper<(a1: A1) => R4>;\n        flowRight<A1, R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R4) => R5>, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1) => R1): LoDashExplicitWrapper<(a1: A1) => R5>;\n        flowRight<A1, R6, R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R5) => R6>, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1) => R1): LoDashExplicitWrapper<(a1: A1) => R6>;\n        flowRight<A1, R7, R6, R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R6) => R7>, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1) => R1): LoDashExplicitWrapper<(a1: A1) => R7>;\n        // 2-argument first function\n        flowRight<A1, A2, R2, R1>(this: LoDashExplicitWrapper<(a: R1) => R2>, f1: (a1: A1, a2: A2) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2) => R2>;\n        flowRight<A1, A2, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R2) => R3>, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2) => R3>;\n        flowRight<A1, A2, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R3) => R4>, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2) => R4>;\n        flowRight<A1, A2, R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R4) => R5>, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2) => R5>;\n        flowRight<A1, A2, R6, R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R5) => R6>, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2) => R6>;\n        flowRight<A1, A2, R7, R6, R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R6) => R7>, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2) => R7>;\n        // 3-argument first function\n        flowRight<A1, A2, A3, R2, R1>(this: LoDashExplicitWrapper<(a: R1) => R2>, f1: (a1: A1, a2: A2, a3: A3) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R2>;\n        flowRight<A1, A2, A3, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R2) => R3>, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R3>;\n        flowRight<A1, A2, A3, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R3) => R4>, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R4>;\n        flowRight<A1, A2, A3, R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R4) => R5>, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R5>;\n        flowRight<A1, A2, A3, R6, R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R5) => R6>, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R6>;\n        flowRight<A1, A2, A3, R7, R6, R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R6) => R7>, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3) => R7>;\n        // 4-argument first function\n        flowRight<A1, A2, A3, A4, R2, R1>(this: LoDashExplicitWrapper<(a: R1) => R2>, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R2>;\n        flowRight<A1, A2, A3, A4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R2) => R3>, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R3>;\n        flowRight<A1, A2, A3, A4, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R3) => R4>, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R4>;\n        flowRight<A1, A2, A3, A4, R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R4) => R5>, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R5>;\n        flowRight<A1, A2, A3, A4, R6, R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R5) => R6>, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R6>;\n        flowRight<A1, A2, A3, A4, R7, R6, R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R6) => R7>, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (a1: A1, a2: A2, a3: A3, a4: A4) => R1): LoDashExplicitWrapper<(a1: A1, a2: A2, a3: A3, a4: A4) => R7>;\n        // any-argument first function\n        flowRight<R2, R1>(this: LoDashExplicitWrapper<(a: R1) => R2>, f1: (...args: any[]) => R1): LoDashExplicitWrapper<(...args: any[]) => R2>;\n        flowRight<R3, R2, R1>(this: LoDashExplicitWrapper<(a: R1) => R2>, f2: (a: R1) => R2, f1: (...args: any[]) => R1): LoDashExplicitWrapper<(...args: any[]) => R3>;\n        flowRight<R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R1) => R2>, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: any[]) => R1): LoDashExplicitWrapper<(...args: any[]) => R4>;\n        flowRight<R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R1) => R2>, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: any[]) => R1): LoDashExplicitWrapper<(...args: any[]) => R5>;\n        flowRight<R6, R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R1) => R2>, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: any[]) => R1): LoDashExplicitWrapper<(...args: any[]) => R6>;\n        flowRight<R7, R6, R5, R4, R3, R2, R1>(this: LoDashExplicitWrapper<(a: R1) => R2>, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: any[]) => R1): LoDashExplicitWrapper<(...args: any[]) => R7>;\n        flowRight(this: LoDashExplicitWrapper<(a: any) => any>, f6: (a: any) => any, f5: (a: any) => any, f4: (a: any) => any, f3: (a: any) => any, f2: (a: any) => any, f1: () => any, ...funcs: Array<Many<(...args: any[]) => any>>): LoDashExplicitWrapper<(...args: any[]) => any>;\n        flowRight(this: LoDashExplicitWrapper<(a: any) => any>, funcs: Array<Many<(...args: any[]) => any>>): LoDashExplicitWrapper<(...args: any[]) => any>;\n    }\n\n    //_.memoize\n    interface MemoizedFunction {\n        cache: MapCache;\n    }\n\n    interface LoDashStatic {\n        /**\n         * Creates a function that memoizes the result of func. If resolver is provided it determines the cache key for\n         * storing the result based on the arguments provided to the memoized function. By default, the first argument\n         * provided to the memoized function is coerced to a string and used as the cache key. The func is invoked with\n         * the this binding of the memoized function.\n         *\n         * @param func The function to have its output memoized.\n         * @param resolver The function to resolve the cache key.\n         * @return Returns the new memoizing function.\n         */\n        memoize: {\n            <T extends (...args: any[]) => any>(func: T, resolver?: (...args: any[]) => any): T & MemoizedFunction;\n            Cache: MapCacheConstructor;\n        };\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.memoize\n         */\n        memoize(resolver?: (...args: any[]) => any): LoDashImplicitWrapper<TValue & MemoizedFunction>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.memoize\n         */\n        memoize(resolver?: (...args: any[]) => any): LoDashExplicitWrapper<TValue & MemoizedFunction>;\n    }\n\n    //_.overArgs (was _.modArgs)\n    interface LoDashStatic {\n        /**\n         * Creates a function that runs each argument through a corresponding transform function.\n         *\n         * @param func The function to wrap.\n         * @param transforms The functions to transform arguments, specified as individual functions or arrays\n         * of functions.\n         * @return Returns the new function.\n         */\n        overArgs(\n            func: (...args: any[]) => any,\n            ...transforms: Array<Many<(...args: any[]) => any>>\n        ): (...args: any[]) => any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.overArgs\n         */\n        overArgs(...transforms: Array<Many<(...args: any[]) => any>>): LoDashImplicitWrapper<(...args: any[]) => any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.overArgs\n         */\n        overArgs(...transforms: Array<Many<(...args: any[]) => any>>): LoDashExplicitWrapper<(...args: any[]) => any>;\n    }\n\n    //_.negate\n    interface LoDashStatic {\n        /**\n         * Creates a function that negates the result of the predicate func. The func predicate is invoked with\n         * the this binding and arguments of the created function.\n         *\n         * @param predicate The predicate to negate.\n         * @return Returns the new function.\n         */\n        negate<T extends (...args: any[]) => any>(predicate: T): T;\n    }\n\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.negate\n         */\n        negate(): this;\n    }\n\n    //_.once\n    interface LoDashStatic {\n        /**\n         * Creates a function that is restricted to invoking func once. Repeat calls to the function return the value\n         * of the first call. The func is invoked with the this binding and arguments of the created function.\n         *\n         * @param func The function to restrict.\n         * @return Returns the new restricted function.\n         */\n        once<T extends (...args: any[]) => any>(func: T): T;\n    }\n\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.once\n         */\n        once(): this;\n    }\n\n    //_.partial\n    interface LoDashStatic {\n        /**\n        * Creates a function that, when called, invokes func with any additional partial arguments\n        * prepended to those provided to the new function. This method is similar to _.bind except\n        * it does not alter the this binding.\n        * @param func The function to partially apply arguments to.\n        * @param args Arguments to be partially applied.\n        * @return The new partially applied function.\n        **/\n        partial: Partial;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.partial\n         */\n        partial: ImplicitPartial;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.partial\n         */\n        partial: ExplicitPartial;\n    }\n\n    type PH = LoDashStatic;\n\n    type Function0<R> = () => R;\n    type Function1<T1, R> = (t1: T1) => R;\n    type Function2<T1, T2, R> = (t1: T1, t2: T2) => R;\n    type Function3<T1, T2, T3, R> = (t1: T1, t2: T2, t3: T3) => R;\n    type Function4<T1, T2, T3, T4, R> = (t1: T1, t2: T2, t3: T3, t4: T4) => R;\n\n    interface Partial {\n        // arity 0\n        <R>(func: Function0<R>): Function0<R>;\n        // arity 1\n        <T1, R>(func: Function1<T1, R>): Function1<T1, R>;\n        <T1, R>(func: Function1<T1, R>, arg1: T1): Function0<R>;\n        // arity 2\n        <T1, T2, R>(func: Function2<T1, T2, R>):                      Function2<T1, T2, R>;\n        <T1, T2, R>(func: Function2<T1, T2, R>, arg1: T1):            Function1<    T2, R>;\n        <T1, T2, R>(func: Function2<T1, T2, R>, plc1: PH, arg2: T2):  Function1<T1,     R>;\n        <T1, T2, R>(func: Function2<T1, T2, R>, arg1: T1, arg2: T2):  Function0<        R>;\n        // arity 3\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>):                                Function3<T1, T2, T3, R>;\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg1: T1):                      Function2<    T2, T3, R>;\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, plc1: PH, arg2: T2):            Function2<T1,     T3, R>;\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg1: T1, arg2: T2):            Function1<        T3, R>;\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, plc1: PH, plc2: PH, arg3: T3):  Function2<T1, T2,     R>;\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg1: T1, plc2: PH, arg3: T3):  Function1<    T2,     R>;\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, plc1: PH, arg2: T2, arg3: T3):  Function1<T1,         R>;\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3):  Function0<            R>;\n        // arity 4\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>):                                          Function4<T1, T2, T3, T4, R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1):                                Function3<    T2, T3, T4, R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, plc1: PH, arg2: T2):                      Function3<T1,     T3, T4, R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2):                      Function2<        T3, T4, R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, plc1: PH, plc2: PH, arg3: T3):            Function3<T1, T2,     T4, R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: PH, arg3: T3):            Function2<    T2,     T4, R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, plc1: PH, arg2: T2, arg3: T3):            Function2<T1,         T4, R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3):            Function1<            T4, R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, plc1: PH, plc2: PH, plc3: PH, arg4: T4):  Function3<T1, T2, T3,     R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: PH, plc3: PH, arg4: T4):  Function2<    T2, T3,     R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, plc1: PH, arg2: T2, plc3: PH, arg4: T4):  Function2<T1,     T3,     R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, plc3: PH, arg4: T4):  Function1<        T3,     R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, plc1: PH, plc2: PH, arg3: T3, arg4: T4):  Function2<T1, T2,         R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: PH, arg3: T3, arg4: T4):  Function1<    T2,         R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, plc1: PH, arg2: T2, arg3: T3, arg4: T4):  Function1<T1,             R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4):  Function0<                R>;\n        // catch-all\n        (func: (...args: any[]) => any, ...args: any[]): (...args: any[]) => any;\n    }\n\n    interface ImplicitPartial {\n        // arity 0\n        <R>(this: LoDashImplicitWrapper<Function0<R>>): LoDashImplicitWrapper<Function0<R>>;\n        // arity 1\n        <T1, R>(this: LoDashImplicitWrapper<Function1<T1, R>>): LoDashImplicitWrapper<Function1<T1, R>>;\n        <T1, R>(this: LoDashImplicitWrapper<Function1<T1, R>>, arg1: T1): LoDashImplicitWrapper<Function0<R>>;\n        // arity 2\n        <T1, T2, R>(this: LoDashImplicitWrapper<Function2<T1, T2, R>>):                      LoDashImplicitWrapper<Function2<T1, T2, R>>;\n        <T1, T2, R>(this: LoDashImplicitWrapper<Function2<T1, T2, R>>, arg1: T1):            LoDashImplicitWrapper<Function1<    T2, R>>;\n        <T1, T2, R>(this: LoDashImplicitWrapper<Function2<T1, T2, R>>, plc1: PH, arg2: T2):  LoDashImplicitWrapper<Function1<T1,     R>>;\n        <T1, T2, R>(this: LoDashImplicitWrapper<Function2<T1, T2, R>>, arg1: T1, arg2: T2):  LoDashImplicitWrapper<Function0<        R>>;\n        // arity 3\n        <T1, T2, T3, R>(this: LoDashImplicitWrapper<Function3<T1, T2, T3, R>>):                                LoDashImplicitWrapper<Function3<T1, T2, T3, R>>;\n        <T1, T2, T3, R>(this: LoDashImplicitWrapper<Function3<T1, T2, T3, R>>, arg1: T1):                      LoDashImplicitWrapper<Function2<    T2, T3, R>>;\n        <T1, T2, T3, R>(this: LoDashImplicitWrapper<Function3<T1, T2, T3, R>>, plc1: PH, arg2: T2):            LoDashImplicitWrapper<Function2<T1,     T3, R>>;\n        <T1, T2, T3, R>(this: LoDashImplicitWrapper<Function3<T1, T2, T3, R>>, arg1: T1, arg2: T2):            LoDashImplicitWrapper<Function1<        T3, R>>;\n        <T1, T2, T3, R>(this: LoDashImplicitWrapper<Function3<T1, T2, T3, R>>, plc1: PH, plc2: PH, arg3: T3):  LoDashImplicitWrapper<Function2<T1, T2,     R>>;\n        <T1, T2, T3, R>(this: LoDashImplicitWrapper<Function3<T1, T2, T3, R>>, arg1: T1, plc2: PH, arg3: T3):  LoDashImplicitWrapper<Function1<    T2,     R>>;\n        <T1, T2, T3, R>(this: LoDashImplicitWrapper<Function3<T1, T2, T3, R>>, plc1: PH, arg2: T2, arg3: T3):  LoDashImplicitWrapper<Function1<T1,         R>>;\n        <T1, T2, T3, R>(this: LoDashImplicitWrapper<Function3<T1, T2, T3, R>>, arg1: T1, arg2: T2, arg3: T3):  LoDashImplicitWrapper<Function0<            R>>;\n        // arity 4\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>):                                          LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1):                                LoDashImplicitWrapper<Function3<    T2, T3, T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, plc1: PH, arg2: T2):                      LoDashImplicitWrapper<Function3<T1,     T3, T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, arg2: T2):                      LoDashImplicitWrapper<Function2<        T3, T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, plc1: PH, plc2: PH, arg3: T3):            LoDashImplicitWrapper<Function3<T1, T2,     T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, plc2: PH, arg3: T3):            LoDashImplicitWrapper<Function2<    T2,     T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, plc1: PH, arg2: T2, arg3: T3):            LoDashImplicitWrapper<Function2<T1,         T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, arg2: T2, arg3: T3):            LoDashImplicitWrapper<Function1<            T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, plc1: PH, plc2: PH, plc3: PH, arg4: T4):  LoDashImplicitWrapper<Function3<T1, T2, T3,     R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, plc2: PH, plc3: PH, arg4: T4):  LoDashImplicitWrapper<Function2<    T2, T3,     R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, plc1: PH, arg2: T2, plc3: PH, arg4: T4):  LoDashImplicitWrapper<Function2<T1,     T3,     R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, arg2: T2, plc3: PH, arg4: T4):  LoDashImplicitWrapper<Function1<        T3,     R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, plc1: PH, plc2: PH, arg3: T3, arg4: T4):  LoDashImplicitWrapper<Function2<T1, T2,         R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, plc2: PH, arg3: T3, arg4: T4):  LoDashImplicitWrapper<Function1<    T2,         R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, plc1: PH, arg2: T2, arg3: T3, arg4: T4):  LoDashImplicitWrapper<Function1<T1,             R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, arg2: T2, arg3: T3, arg4: T4):  LoDashImplicitWrapper<Function0<                R>>;\n        // catch-all\n        (...args: any[]): LoDashImplicitWrapper<(...args: any[]) => any>;\n    }\n\n    interface ExplicitPartial {\n        // arity 0\n        <R>(this: LoDashExplicitWrapper<Function0<R>>): LoDashExplicitWrapper<Function0<R>>;\n        // arity 1\n        <T1, R>(this: LoDashExplicitWrapper<Function1<T1, R>>): LoDashExplicitWrapper<Function1<T1, R>>;\n        <T1, R>(this: LoDashExplicitWrapper<Function1<T1, R>>, arg1: T1): LoDashExplicitWrapper<Function0<R>>;\n        // arity 2\n        <T1, T2, R>(this: LoDashExplicitWrapper<Function2<T1, T2, R>>):                      LoDashExplicitWrapper<Function2<T1, T2, R>>;\n        <T1, T2, R>(this: LoDashExplicitWrapper<Function2<T1, T2, R>>, arg1: T1):            LoDashExplicitWrapper<Function1<    T2, R>>;\n        <T1, T2, R>(this: LoDashExplicitWrapper<Function2<T1, T2, R>>, plc1: PH, arg2: T2):  LoDashExplicitWrapper<Function1<T1,     R>>;\n        <T1, T2, R>(this: LoDashExplicitWrapper<Function2<T1, T2, R>>, arg1: T1, arg2: T2):  LoDashExplicitWrapper<Function0<        R>>;\n        // arity 3\n        <T1, T2, T3, R>(this: LoDashExplicitWrapper<Function3<T1, T2, T3, R>>):                                LoDashExplicitWrapper<Function3<T1, T2, T3, R>>;\n        <T1, T2, T3, R>(this: LoDashExplicitWrapper<Function3<T1, T2, T3, R>>, arg1: T1):                      LoDashExplicitWrapper<Function2<    T2, T3, R>>;\n        <T1, T2, T3, R>(this: LoDashExplicitWrapper<Function3<T1, T2, T3, R>>, plc1: PH, arg2: T2):            LoDashExplicitWrapper<Function2<T1,     T3, R>>;\n        <T1, T2, T3, R>(this: LoDashExplicitWrapper<Function3<T1, T2, T3, R>>, arg1: T1, arg2: T2):            LoDashExplicitWrapper<Function1<        T3, R>>;\n        <T1, T2, T3, R>(this: LoDashExplicitWrapper<Function3<T1, T2, T3, R>>, plc1: PH, plc2: PH, arg3: T3):  LoDashExplicitWrapper<Function2<T1, T2,     R>>;\n        <T1, T2, T3, R>(this: LoDashExplicitWrapper<Function3<T1, T2, T3, R>>, arg1: T1, plc2: PH, arg3: T3):  LoDashExplicitWrapper<Function1<    T2,     R>>;\n        <T1, T2, T3, R>(this: LoDashExplicitWrapper<Function3<T1, T2, T3, R>>, plc1: PH, arg2: T2, arg3: T3):  LoDashExplicitWrapper<Function1<T1,         R>>;\n        <T1, T2, T3, R>(this: LoDashExplicitWrapper<Function3<T1, T2, T3, R>>, arg1: T1, arg2: T2, arg3: T3):  LoDashExplicitWrapper<Function0<            R>>;\n        // arity 4\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>):                                          LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1):                                LoDashExplicitWrapper<Function3<    T2, T3, T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, plc1: PH, arg2: T2):                      LoDashExplicitWrapper<Function3<T1,     T3, T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, arg2: T2):                      LoDashExplicitWrapper<Function2<        T3, T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, plc1: PH, plc2: PH, arg3: T3):            LoDashExplicitWrapper<Function3<T1, T2,     T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, plc2: PH, arg3: T3):            LoDashExplicitWrapper<Function2<    T2,     T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, plc1: PH, arg2: T2, arg3: T3):            LoDashExplicitWrapper<Function2<T1,         T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, arg2: T2, arg3: T3):            LoDashExplicitWrapper<Function1<            T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, plc1: PH, plc2: PH, plc3: PH, arg4: T4):  LoDashExplicitWrapper<Function3<T1, T2, T3,     R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, plc2: PH, plc3: PH, arg4: T4):  LoDashExplicitWrapper<Function2<    T2, T3,     R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, plc1: PH, arg2: T2, plc3: PH, arg4: T4):  LoDashExplicitWrapper<Function2<T1,     T3,     R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, arg2: T2, plc3: PH, arg4: T4):  LoDashExplicitWrapper<Function1<        T3,     R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, plc1: PH, plc2: PH, arg3: T3, arg4: T4):  LoDashExplicitWrapper<Function2<T1, T2,         R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, plc2: PH, arg3: T3, arg4: T4):  LoDashExplicitWrapper<Function1<    T2,         R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, plc1: PH, arg2: T2, arg3: T3, arg4: T4):  LoDashExplicitWrapper<Function1<T1,             R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, arg2: T2, arg3: T3, arg4: T4):  LoDashExplicitWrapper<Function0<                R>>;\n        // catch-all\n        (...args: any[]): LoDashExplicitWrapper<(...args: any[]) => any>;\n    }\n\n    //_.partialRight\n    interface LoDashStatic {\n        /**\n        * This method is like _.partial except that partial arguments are appended to those provided\n        * to the new function.\n        * @param func The function to partially apply arguments to.\n        * @param args Arguments to be partially applied.\n        * @return The new partially applied function.\n        **/\n        partialRight: PartialRight;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.partialRight\n         */\n        partialRight: ImplicitPartialRight;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.partialRight\n         */\n        partialRight: ExplicitPartialRight;\n    }\n\n    interface PartialRight {\n        // arity 0\n        <R>(func: Function0<R>): Function0<R>;\n        // arity 1\n        <T1, R>(func: Function1<T1, R>): Function1<T1, R>;\n        <T1, R>(func: Function1<T1, R>, arg1: T1): Function0<R>;\n        // arity 2\n        <T1, T2, R>(func: Function2<T1, T2, R>):                      Function2<T1, T2, R>;\n        <T1, T2, R>(func: Function2<T1, T2, R>, arg1: T1, plc2: PH):  Function1<    T2, R>;\n        <T1, T2, R>(func: Function2<T1, T2, R>,           arg2: T2):  Function1<T1,     R>;\n        <T1, T2, R>(func: Function2<T1, T2, R>, arg1: T1, arg2: T2):  Function0<        R>;\n        // arity 3\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>):                                Function3<T1, T2, T3, R>;\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg1: T1, plc2: PH, plc3: PH):  Function2<    T2, T3, R>;\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>,           arg2: T2, plc3: PH):  Function2<T1,     T3, R>;\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg1: T1, arg2: T2, plc3: PH):  Function1<        T3, R>;\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>,                     arg3: T3):  Function2<T1, T2,     R>;\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg1: T1, plc2: PH, arg3: T3):  Function1<    T2,     R>;\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>,           arg2: T2, arg3: T3):  Function1<T1,         R>;\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3):  Function0<            R>;\n        // arity 4\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>):                                          Function4<T1, T2, T3, T4, R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: PH, plc3: PH, plc4: PH):  Function3<    T2, T3, T4, R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>,           arg2: T2, plc3: PH, plc4: PH):  Function3<T1,     T3, T4, R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, plc3: PH, plc4: PH):  Function2<        T3, T4, R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>,                     arg3: T3, plc4: PH):  Function3<T1, T2,     T4, R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: PH, arg3: T3, plc4: PH):  Function2<    T2,     T4, R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>,           arg2: T2, arg3: T3, plc4: PH):  Function2<T1,         T4, R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, plc4: PH):  Function1<            T4, R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>,                               arg4: T4):  Function3<T1, T2, T3,     R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: PH, plc3: PH, arg4: T4):  Function2<    T2, T3,     R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>,           arg2: T2, plc3: PH, arg4: T4):  Function2<T1,     T3,     R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, plc3: PH, arg4: T4):  Function1<        T3,     R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>,                     arg3: T3, arg4: T4):  Function2<T1, T2,         R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: PH, arg3: T3, arg4: T4):  Function1<    T2,         R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>,           arg2: T2, arg3: T3, arg4: T4):  Function1<T1,             R>;\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4):  Function0<                R>;\n        // catch-all\n        (func: (...args: any[]) => any, ...args: any[]): (...args: any[]) => any;\n    }\n\n    interface ImplicitPartialRight {\n        // arity 0\n        <R>(this: LoDashImplicitWrapper<Function0<R>>): LoDashImplicitWrapper<Function0<R>>;\n        // arity 1\n        <T1, R>(this: LoDashImplicitWrapper<Function1<T1, R>>): LoDashImplicitWrapper<Function1<T1, R>>;\n        <T1, R>(this: LoDashImplicitWrapper<Function1<T1, R>>, arg1: T1): LoDashImplicitWrapper<Function0<R>>;\n        // arity 2\n        <T1, T2, R>(this: LoDashImplicitWrapper<Function2<T1, T2, R>>):                      LoDashImplicitWrapper<Function2<T1, T2, R>>;\n        <T1, T2, R>(this: LoDashImplicitWrapper<Function2<T1, T2, R>>, arg1: T1, plc2: PH):  LoDashImplicitWrapper<Function1<    T2, R>>;\n        <T1, T2, R>(this: LoDashImplicitWrapper<Function2<T1, T2, R>>,           arg2: T2):  LoDashImplicitWrapper<Function1<T1,     R>>;\n        <T1, T2, R>(this: LoDashImplicitWrapper<Function2<T1, T2, R>>, arg1: T1, arg2: T2):  LoDashImplicitWrapper<Function0<        R>>;\n        // arity 3\n        <T1, T2, T3, R>(this: LoDashImplicitWrapper<Function3<T1, T2, T3, R>>):                                LoDashImplicitWrapper<Function3<T1, T2, T3, R>>;\n        <T1, T2, T3, R>(this: LoDashImplicitWrapper<Function3<T1, T2, T3, R>>, arg1: T1, plc2: PH, plc3: PH):  LoDashImplicitWrapper<Function2<    T2, T3, R>>;\n        <T1, T2, T3, R>(this: LoDashImplicitWrapper<Function3<T1, T2, T3, R>>,           arg2: T2, plc3: PH):  LoDashImplicitWrapper<Function2<T1,     T3, R>>;\n        <T1, T2, T3, R>(this: LoDashImplicitWrapper<Function3<T1, T2, T3, R>>, arg1: T1, arg2: T2, plc3: PH):  LoDashImplicitWrapper<Function1<        T3, R>>;\n        <T1, T2, T3, R>(this: LoDashImplicitWrapper<Function3<T1, T2, T3, R>>,                     arg3: T3):  LoDashImplicitWrapper<Function2<T1, T2,     R>>;\n        <T1, T2, T3, R>(this: LoDashImplicitWrapper<Function3<T1, T2, T3, R>>, arg1: T1, plc2: PH, arg3: T3):  LoDashImplicitWrapper<Function1<    T2,     R>>;\n        <T1, T2, T3, R>(this: LoDashImplicitWrapper<Function3<T1, T2, T3, R>>,           arg2: T2, arg3: T3):  LoDashImplicitWrapper<Function1<T1,         R>>;\n        <T1, T2, T3, R>(this: LoDashImplicitWrapper<Function3<T1, T2, T3, R>>, arg1: T1, arg2: T2, arg3: T3):  LoDashImplicitWrapper<Function0<            R>>;\n        // arity 4\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>):                                          LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, plc2: PH, plc3: PH, plc4: PH):  LoDashImplicitWrapper<Function3<    T2, T3, T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>,           arg2: T2, plc3: PH, plc4: PH):  LoDashImplicitWrapper<Function3<T1,     T3, T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, arg2: T2, plc3: PH, plc4: PH):  LoDashImplicitWrapper<Function2<        T3, T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>,                     arg3: T3, plc4: PH):  LoDashImplicitWrapper<Function3<T1, T2,     T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, plc2: PH, arg3: T3, plc4: PH):  LoDashImplicitWrapper<Function2<    T2,     T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>,           arg2: T2, arg3: T3, plc4: PH):  LoDashImplicitWrapper<Function2<T1,         T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, arg2: T2, arg3: T3, plc4: PH):  LoDashImplicitWrapper<Function1<            T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>,                               arg4: T4):  LoDashImplicitWrapper<Function3<T1, T2, T3,     R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, plc2: PH, plc3: PH, arg4: T4):  LoDashImplicitWrapper<Function2<    T2, T3,     R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>,           arg2: T2, plc3: PH, arg4: T4):  LoDashImplicitWrapper<Function2<T1,     T3,     R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, arg2: T2, plc3: PH, arg4: T4):  LoDashImplicitWrapper<Function1<        T3,     R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>,                     arg3: T3, arg4: T4):  LoDashImplicitWrapper<Function2<T1, T2,         R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, plc2: PH, arg3: T3, arg4: T4):  LoDashImplicitWrapper<Function1<    T2,         R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>,           arg2: T2, arg3: T3, arg4: T4):  LoDashImplicitWrapper<Function1<T1,             R>>;\n        <T1, T2, T3, T4, R>(this: LoDashImplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, arg2: T2, arg3: T3, arg4: T4):  LoDashImplicitWrapper<Function0<                R>>;\n        // catch-all\n        (...args: any[]): LoDashImplicitWrapper<(...args: any[]) => any>;\n    }\n\n    interface ExplicitPartialRight {\n        // arity 0\n        <R>(this: LoDashExplicitWrapper<Function0<R>>): LoDashExplicitWrapper<Function0<R>>;\n        // arity 1\n        <T1, R>(this: LoDashExplicitWrapper<Function1<T1, R>>): LoDashExplicitWrapper<Function1<T1, R>>;\n        <T1, R>(this: LoDashExplicitWrapper<Function1<T1, R>>, arg1: T1): LoDashExplicitWrapper<Function0<R>>;\n        // arity 2\n        <T1, T2, R>(this: LoDashExplicitWrapper<Function2<T1, T2, R>>):                      LoDashExplicitWrapper<Function2<T1, T2, R>>;\n        <T1, T2, R>(this: LoDashExplicitWrapper<Function2<T1, T2, R>>, arg1: T1, plc2: PH):  LoDashExplicitWrapper<Function1<    T2, R>>;\n        <T1, T2, R>(this: LoDashExplicitWrapper<Function2<T1, T2, R>>,           arg2: T2):  LoDashExplicitWrapper<Function1<T1,     R>>;\n        <T1, T2, R>(this: LoDashExplicitWrapper<Function2<T1, T2, R>>, arg1: T1, arg2: T2):  LoDashExplicitWrapper<Function0<        R>>;\n        // arity 3\n        <T1, T2, T3, R>(this: LoDashExplicitWrapper<Function3<T1, T2, T3, R>>):                                LoDashExplicitWrapper<Function3<T1, T2, T3, R>>;\n        <T1, T2, T3, R>(this: LoDashExplicitWrapper<Function3<T1, T2, T3, R>>, arg1: T1, plc2: PH, plc3: PH):  LoDashExplicitWrapper<Function2<    T2, T3, R>>;\n        <T1, T2, T3, R>(this: LoDashExplicitWrapper<Function3<T1, T2, T3, R>>,           arg2: T2, plc3: PH):  LoDashExplicitWrapper<Function2<T1,     T3, R>>;\n        <T1, T2, T3, R>(this: LoDashExplicitWrapper<Function3<T1, T2, T3, R>>, arg1: T1, arg2: T2, plc3: PH):  LoDashExplicitWrapper<Function1<        T3, R>>;\n        <T1, T2, T3, R>(this: LoDashExplicitWrapper<Function3<T1, T2, T3, R>>,                     arg3: T3):  LoDashExplicitWrapper<Function2<T1, T2,     R>>;\n        <T1, T2, T3, R>(this: LoDashExplicitWrapper<Function3<T1, T2, T3, R>>, arg1: T1, plc2: PH, arg3: T3):  LoDashExplicitWrapper<Function1<    T2,     R>>;\n        <T1, T2, T3, R>(this: LoDashExplicitWrapper<Function3<T1, T2, T3, R>>,           arg2: T2, arg3: T3):  LoDashExplicitWrapper<Function1<T1,         R>>;\n        <T1, T2, T3, R>(this: LoDashExplicitWrapper<Function3<T1, T2, T3, R>>, arg1: T1, arg2: T2, arg3: T3):  LoDashExplicitWrapper<Function0<            R>>;\n        // arity 4\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>):                                          LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, plc2: PH, plc3: PH, plc4: PH):  LoDashExplicitWrapper<Function3<    T2, T3, T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>,           arg2: T2, plc3: PH, plc4: PH):  LoDashExplicitWrapper<Function3<T1,     T3, T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, arg2: T2, plc3: PH, plc4: PH):  LoDashExplicitWrapper<Function2<        T3, T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>,                     arg3: T3, plc4: PH):  LoDashExplicitWrapper<Function3<T1, T2,     T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, plc2: PH, arg3: T3, plc4: PH):  LoDashExplicitWrapper<Function2<    T2,     T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>,           arg2: T2, arg3: T3, plc4: PH):  LoDashExplicitWrapper<Function2<T1,         T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, arg2: T2, arg3: T3, plc4: PH):  LoDashExplicitWrapper<Function1<            T4, R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>,                               arg4: T4):  LoDashExplicitWrapper<Function3<T1, T2, T3,     R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, plc2: PH, plc3: PH, arg4: T4):  LoDashExplicitWrapper<Function2<    T2, T3,     R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>,           arg2: T2, plc3: PH, arg4: T4):  LoDashExplicitWrapper<Function2<T1,     T3,     R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, arg2: T2, plc3: PH, arg4: T4):  LoDashExplicitWrapper<Function1<        T3,     R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>,                     arg3: T3, arg4: T4):  LoDashExplicitWrapper<Function2<T1, T2,         R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, plc2: PH, arg3: T3, arg4: T4):  LoDashExplicitWrapper<Function1<    T2,         R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>,           arg2: T2, arg3: T3, arg4: T4):  LoDashExplicitWrapper<Function1<T1,             R>>;\n        <T1, T2, T3, T4, R>(this: LoDashExplicitWrapper<Function4<T1, T2, T3, T4, R>>, arg1: T1, arg2: T2, arg3: T3, arg4: T4):  LoDashExplicitWrapper<Function0<                R>>;\n        // catch-all\n        (...args: any[]): LoDashExplicitWrapper<(...args: any[]) => any>;\n    }\n\n    //_.rearg\n    interface LoDashStatic {\n        /**\n         * Creates a function that invokes func with arguments arranged according to the specified indexes where the\n         * argument value at the first index is provided as the first argument, the argument value at the second index\n         * is provided as the second argument, and so on.\n         * @param func The function to rearrange arguments for.\n         * @param indexes The arranged argument indexes, specified as individual indexes or arrays of indexes.\n         * @return Returns the new function.\n         */\n        rearg(func: (...args: any[]) => any, ...indexes: Array<Many<number>>): (...args: any[]) => any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.rearg\n         */\n        rearg(...indexes: Array<Many<number>>): LoDashImplicitWrapper<(...args: any[]) => any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.rearg\n         */\n        rearg(...indexes: Array<Many<number>>): LoDashExplicitWrapper<(...args: any[]) => any>;\n    }\n\n    //_.rest\n    interface LoDashStatic {\n        /**\n         * Creates a function that invokes func with the this binding of the created function and arguments from start\n         * and beyond provided as an array.\n         *\n         * Note: This method is based on the rest parameter.\n         *\n         * @param func The function to apply a rest parameter to.\n         * @param start The start position of the rest parameter.\n         * @return Returns the new function.\n         */\n        rest(\n            func: (...args: any[]) => any,\n            start?: number\n        ): (...args: any[]) => any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.rest\n         */\n        rest(start?: number): LoDashImplicitWrapper<(...args: any[]) => any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.rest\n         */\n        rest(start?: number): LoDashExplicitWrapper<(...args: any[]) => any>;\n    }\n\n    //_.spread\n    interface LoDashStatic {\n        /**\n         * Creates a function that invokes func with the this binding of the created function and an array of arguments\n         * much like Function#apply.\n         *\n         * Note: This method is based on the spread operator.\n         *\n         * @param func The function to spread arguments over.\n         * @return Returns the new function.\n         */\n        spread<TResult>(func: (...args: any[]) => TResult): (...args: any[]) => TResult;\n\n        /**\n         * @see _.spread\n         */\n        spread<TResult>(func: (...args: any[]) => TResult, start: number): (...args: any[]) => TResult;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.spread\n         */\n        spread<TResult>(this: LoDashImplicitWrapper<(...args: any[]) => TResult>): LoDashImplicitWrapper<(...args: any[]) => TResult>;\n\n        /**\n         * @see _.spread\n         */\n        spread<TResult>(this: LoDashImplicitWrapper<(...args: any[]) => TResult>, start: number): LoDashImplicitWrapper<(...args: any[]) => TResult>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.spread\n         */\n        spread<TResult>(this: LoDashExplicitWrapper<(...args: any[]) => TResult>): LoDashExplicitWrapper<(...args: any[]) => TResult>;\n\n        /**\n         * @see _.spread\n         */\n        spread<TResult>(this: LoDashExplicitWrapper<(...args: any[]) => TResult>, start: number): LoDashExplicitWrapper<(...args: any[]) => TResult>;\n    }\n\n    //_.throttle\n    interface ThrottleSettings {\n        /**\n         * If you'd like to disable the leading-edge call, pass this as false.\n         */\n        leading?: boolean;\n\n        /**\n         * If you'd like to disable the execution on the trailing-edge, pass false.\n         */\n        trailing?: boolean;\n    }\n\n    interface LoDashStatic {\n        /**\n         * Creates a throttled function that only invokes func at most once per every wait milliseconds. The throttled\n         * function comes with a cancel method to cancel delayed invocations and a flush method to immediately invoke\n         * them. Provide an options object to indicate that func should be invoked on the leading and/or trailing edge\n         * of the wait timeout. Subsequent calls to the throttled function return the result of the last func call.\n         *\n         * Note: If leading and trailing options are true, func is invoked on the trailing edge of the timeout only if\n         * the the throttled function is invoked more than once during the wait timeout.\n         *\n         * @param func The function to throttle.\n         * @param wait The number of milliseconds to throttle invocations to.\n         * @param options The options object.\n         * @param options.leading Specify invoking on the leading edge of the timeout.\n         * @param options.trailing Specify invoking on the trailing edge of the timeout.\n         * @return Returns the new throttled function.\n         */\n        throttle<T extends (...args: any[]) => any>(\n            func: T,\n            wait?: number,\n            options?: ThrottleSettings\n        ): T & Cancelable;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.throttle\n         */\n        throttle(\n            wait?: number,\n            options?: ThrottleSettings\n        ): LoDashImplicitWrapper<TValue & Cancelable>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.throttle\n         */\n        throttle(\n            wait?: number,\n            options?: ThrottleSettings\n        ): LoDashExplicitWrapper<TValue & Cancelable>;\n    }\n\n    //_.unary\n    interface LoDashStatic {\n        /**\n         * Creates a function that accepts up to one argument, ignoring any\n         * additional arguments.\n         *\n         * @category Function\n         * @param func The function to cap arguments for.\n         * @returns Returns the new function.\n         * @example\n         *\n         * _.map(['6', '8', '10'], _.unary(parseInt));\n         * // => [6, 8, 10]\n         */\n        unary<T, TResult>(func: (arg1: T, ...args: any[]) => TResult): (arg1: T) => TResult;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.unary\n         */\n        unary<T, TResult>(this: LoDashImplicitWrapper<(arg1: T, ...args: any[]) => TResult>): LoDashImplicitWrapper<(arg1: T) => TResult>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.unary\n         */\n        unary<T, TResult>(this: LoDashExplicitWrapper<(arg1: T, ...args: any[]) => TResult>): LoDashExplicitWrapper<(arg1: T) => TResult>;\n    }\n\n    //_.wrap\n    interface LoDashStatic {\n        /**\n         * Creates a function that provides value to the wrapper function as its first argument. Any additional\n         * arguments provided to the function are appended to those provided to the wrapper function. The wrapper is\n         * invoked with the this binding of the created function.\n         *\n         * @param value The value to wrap.\n         * @param wrapper The wrapper function.\n         * @return Returns the new function.\n         */\n        wrap<T, TArgs, TResult>(\n            value: T,\n            wrapper: (value: T, ...args: TArgs[]) => TResult\n        ): (...args: TArgs[]) => TResult;\n\n        /**\n         * @see _.wrap\n         */\n        wrap<T, TResult>(\n            value: T,\n            wrapper: (value: T, ...args: any[]) => TResult\n        ): (...args: any[]) => TResult;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.wrap\n         */\n        wrap<TArgs, TResult>(\n            wrapper: (value: TValue, ...args: TArgs[]) => TResult\n        ): LoDashImplicitWrapper<(...args: TArgs[]) => TResult>;\n\n        /**\n         * @see _.wrap\n         */\n        wrap<TResult>(\n            wrapper: (value: TValue, ...args: any[]) => TResult\n        ): LoDashImplicitWrapper<(...args: any[]) => TResult>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.wrap\n         */\n        /**\n         * @see _.wrap\n         */\n        wrap<TArgs, TResult>(\n            wrapper: (value: TValue, ...args: TArgs[]) => TResult\n        ): LoDashExplicitWrapper<(...args: TArgs[]) => TResult>;\n\n        /**\n         * @see _.wrap\n         */\n        wrap<TResult>(\n            wrapper: (value: TValue, ...args: any[]) => TResult\n        ): LoDashExplicitWrapper<(...args: any[]) => TResult>;\n    }\n\n    /********\n     * Lang *\n     ********/\n\n    //_.castArray\n    interface LoDashStatic {\n        /**\n         * Casts value as an array if itâs not one.\n         *\n         * @param value The value to inspect.\n         * @return Returns the cast array.\n         */\n        castArray<T>(value?: Many<T>): T[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.castArray\n         */\n        castArray<T>(this: LoDashImplicitWrapper<Many<T>>): LoDashImplicitWrapper<T[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.castArray\n         */\n        castArray<T>(this: LoDashExplicitWrapper<Many<T>>): LoDashExplicitWrapper<T[]>;\n    }\n\n    //_.clone\n    interface LoDashStatic {\n        /**\n         * Creates a shallow clone of value.\n         *\n         * Note: This method is loosely based on the structured clone algorithm and supports cloning arrays,\n         * array buffers, booleans, date objects, maps, numbers, Object objects, regexes, sets, strings, symbols,\n         * and typed arrays. The own enumerable properties of arguments objects are cloned as plain objects. An empty\n         * object is returned for uncloneable values such as error objects, functions, DOM nodes, and WeakMaps.\n         *\n         * @param value The value to clone.\n         * @return Returns the cloned value.\n         */\n        clone<T>(value: T): T;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.clone\n         */\n        clone(): TValue;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.clone\n         */\n        clone(): this;\n    }\n\n    //_.cloneDeep\n    interface LoDashStatic {\n        /**\n         * This method is like _.clone except that it recursively clones value.\n         *\n         * @param value The value to recursively clone.\n         * @return Returns the deep cloned value.\n         */\n        cloneDeep<T>(value: T): T;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.cloneDeep\n         */\n        cloneDeep(): TValue;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.cloneDeep\n         */\n        cloneDeep(): this;\n    }\n\n    //_.cloneDeepWith\n    type CloneDeepWithCustomizer<TObject> = (value: any, key: number | string | undefined, object: TObject | undefined, stack: any) => any;\n\n    interface LoDashStatic {\n        /**\n         * This method is like _.cloneWith except that it recursively clones value.\n         *\n         * @param value The value to recursively clone.\n         * @param customizer The function to customize cloning.\n         * @return Returns the deep cloned value.\n         */\n        cloneDeepWith<T>(\n            value: T,\n            customizer: CloneDeepWithCustomizer<T>\n        ): any;\n\n        /**\n         * @see _.cloneDeepWith\n         */\n        cloneDeepWith<T>(value: T): T;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.cloneDeepWith\n         */\n        cloneDeepWith(\n            customizer: CloneDeepWithCustomizer<TValue>\n        ): any;\n\n        /**\n         * @see _.cloneDeepWith\n         */\n        cloneDeepWith(): TValue;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.cloneDeepWith\n         */\n        cloneDeepWith(\n            customizer: CloneDeepWithCustomizer<TValue>\n        ): LoDashExplicitWrapper<any>;\n\n        /**\n         * @see _.cloneDeepWith\n         */\n        cloneDeepWith(): this;\n    }\n\n    //_.cloneWith\n    type CloneWithCustomizer<TValue, TResult> = (value: TValue, key: number | string | undefined, object: any, stack: any) => TResult;\n\n    interface LoDashStatic {\n        /**\n         * This method is like _.clone except that it accepts customizer which is invoked to produce the cloned value.\n         * If customizer returns undefined cloning is handled by the method instead.\n         *\n         * @param value The value to clone.\n         * @param customizer The function to customize cloning.\n         * @return Returns the cloned value.\n         */\n        cloneWith<T, TResult extends object | string | number | boolean | null>(\n            value: T,\n            customizer: CloneWithCustomizer<T, TResult>\n        ): TResult;\n\n        /**\n         * @see _.cloneWith\n         */\n        cloneWith<T, TResult>(\n            value: T,\n            customizer: CloneWithCustomizer<T, TResult | undefined>\n        ): TResult | T;\n\n        /**\n         * @see _.cloneWith\n         */\n        cloneWith<T>(value: T): T;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.cloneWith\n         */\n        cloneWith<TResult extends object | string | number | boolean | null>(\n            customizer: CloneWithCustomizer<TValue, TResult>\n        ): TResult;\n\n        /**\n         * @see _.cloneWith\n         */\n        cloneWith<TResult>(\n            customizer: CloneWithCustomizer<TValue, TResult | undefined>\n        ): TResult | TValue;\n\n        /**\n         * @see _.cloneWith\n         */\n        cloneWith(): TValue;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.cloneWith\n         */\n        cloneWith<TResult extends object | string | number | boolean | null>(\n            customizer: CloneWithCustomizer<TValue, TResult>\n        ): LoDashExplicitWrapper<TResult>;\n\n        /**\n         * @see _.cloneWith\n         */\n        cloneWith<TResult>(\n            customizer: CloneWithCustomizer<TValue, TResult | undefined>\n        ): LoDashExplicitWrapper<TResult | TValue>;\n\n        /**\n         * @see _.cloneWith\n         */\n        cloneWith(): this;\n    }\n\n    /**\n     * An object containing predicate functions for each property of T\n     */\n    type ConformsPredicateObject<T> = {\n        [P in keyof T]?: (val: T[P]) => boolean;\n    };\n\n    //_.conforms\n    interface LoDashStatic {\n        /**\n         * Creates a function that invokes the predicate properties of `source` with the corresponding\n         * property values of a given object, returning true if all predicates return truthy, else false.\n         */\n        conforms<T>(source: ConformsPredicateObject<T>): (value: T) => boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.conforms\n         */\n        conforms<T>(this: LoDashImplicitWrapper<ConformsPredicateObject<T>>): LoDashImplicitWrapper<(value: T) => boolean>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.conforms\n         */\n        conforms<T>(this: LoDashExplicitWrapper<ConformsPredicateObject<T>>): LoDashExplicitWrapper<(value: T) => boolean>;\n    }\n\n    //_.conformsTo\n    interface LoDashStatic {\n        /**\n         * Checks if object conforms to source by invoking the predicate properties of source with the\n         * corresponding property values of object.\n         *\n         * Note: This method is equivalent to _.conforms when source is partially applied.\n         */\n        conformsTo<T>(object: T, source: ConformsPredicateObject<T>): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.conformsTo\n         */\n        conformsTo<T>(this: LoDashImplicitWrapper<T>, source: ConformsPredicateObject<T>): boolean;\n        // Note: we can't use TValue here,  because it generates a typescript error when strictFunctionTypes is enabled.\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.conformsTo\n         */\n        conformsTo<T>(this: LoDashImplicitWrapper<T>, source: ConformsPredicateObject<T>): LoDashExplicitWrapper<boolean>;\n        // Note: we can't use TValue here,  because it generates a typescript error when strictFunctionTypes is enabled.\n    }\n\n    type CondPair<T, R> = [(val: T) => boolean, (val: T) => R]\n\n    //_.cond\n    interface LoDashStatic {\n        /**\n         * Creates a function that iterates over `pairs` and invokes the corresponding\n         * function of the first predicate to return truthy. The predicate-function\n         * pairs are invoked with the `this` binding and arguments of the created\n         * function.\n         *\n         * @since 4.0.0\n         * @category Util\n         * @param pairs The predicate-function pairs.\n         * @returns Returns the new composite function.\n         * @example\n         *\n         * var func = _.cond([\n         *   [_.matches({ 'a': 1 }),           _.constant('matches A')],\n         *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],\n         *   [_.stubTrue,                      _.constant('no match')]\n         * ]);\n         *\n         * func({ 'a': 1, 'b': 2 });\n         * // => 'matches A'\n         *\n         * func({ 'a': 0, 'b': 1 });\n         * // => 'matches B'\n         *\n         * func({ 'a': '1', 'b': '2' });\n         * // => 'no match'\n         */\n        cond<T, R>(pairs: CondPair<T, R>[]): (Target: T) => R;\n    }\n\n    //_.eq\n    interface LoDashStatic {\n        /**\n         * Performs a [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n         * comparison between two values to determine if they are equivalent.\n         *\n         * @category Lang\n         * @param value The value to compare.\n         * @param other The other value to compare.\n         * @returns Returns `true` if the values are equivalent, else `false`.\n         * @example\n         *\n         * var object = { 'user': 'fred' };\n         * var other = { 'user': 'fred' };\n         *\n         * _.eq(object, object);\n         * // => true\n         *\n         * _.eq(object, other);\n         * // => false\n         *\n         * _.eq('a', 'a');\n         * // => true\n         *\n         * _.eq('a', Object('a'));\n         * // => false\n         *\n         * _.eq(NaN, NaN);\n         * // => true\n         */\n        eq(\n            value: any,\n            other: any\n        ): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.eq\n         */\n        eq(\n            other: any\n        ): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.eq\n         */\n        eq(\n            other: any\n        ): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.gt\n    interface LoDashStatic {\n        /**\n         * Checks if value is greater than other.\n         *\n         * @param value The value to compare.\n         * @param other The other value to compare.\n         * @return Returns true if value is greater than other, else false.\n         */\n        gt(\n            value: any,\n            other: any\n        ): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.gt\n         */\n        gt(other: any): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.gt\n         */\n        gt(other: any): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.gte\n    interface LoDashStatic {\n        /**\n         * Checks if value is greater than or equal to other.\n         *\n         * @param value The value to compare.\n         * @param other The other value to compare.\n         * @return Returns true if value is greater than or equal to other, else false.\n         */\n        gte(\n            value: any,\n            other: any\n        ): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.gte\n         */\n        gte(other: any): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.gte\n         */\n        gte(other: any): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isArguments\n    interface LoDashStatic {\n        /**\n         * Checks if value is classified as an arguments object.\n         *\n         * @param value The value to check.\n         * @return Returns true if value is correctly classified, else false.\n         */\n        isArguments(value?: any): value is IArguments;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isArguments\n         */\n        isArguments(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isArguments\n         */\n        isArguments(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isArray\n    interface LoDashStatic {\n        /**\n         * Checks if value is classified as an Array object.\n         * @param value The value to check.\n         *\n         * @return Returns true if value is correctly classified, else false.\n         */\n        isArray(value?: any): value is any[];\n\n        /**\n         * DEPRECATED\n         */\n        isArray<T>(value?: any): value is any[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isArray\n         */\n        isArray(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isArray\n         */\n        isArray(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isArrayBuffer\n    interface LoDashStatic {\n        /**\n         * Checks if value is classified as an ArrayBuffer object.\n         *\n         * @param value The value to check.\n         * @return Returns true if value is correctly classified, else false.\n         */\n        isArrayBuffer(value?: any): value is ArrayBuffer;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isArrayBuffer\n         */\n        isArrayBuffer(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isArrayBuffer\n         */\n        isArrayBuffer(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isArrayLike\n    interface LoDashStatic {\n        /**\n         * Checks if `value` is array-like. A value is considered array-like if it's\n         * not a function and has a `value.length` that's an integer greater than or\n         * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n         *\n         * @category Lang\n         * @param value The value to check.\n         * @returns Returns `true` if `value` is array-like, else `false`.\n         * @example\n         *\n         * _.isArrayLike([1, 2, 3]);\n         * // => true\n         *\n         * _.isArrayLike(document.body.children);\n         * // => true\n         *\n         * _.isArrayLike('abc');\n         * // => true\n         *\n         * _.isArrayLike(_.noop);\n         * // => false\n         */\n        isArrayLike<T>(value: T & string & number): boolean; // should only match if T = any\n\n        /**\n         * @see _.isArrayLike\n         */\n        isArrayLike(value: ((...args: any[]) => any) | Function | null | undefined): value is never;\n\n        /**\n         * @see _.isArrayLike\n         */\n        isArrayLike(value: any): value is { length: number };\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isArrayLike\n         */\n        isArrayLike(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isArrayLike\n         */\n        isArrayLike(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isArrayLikeObject\n    interface LoDashStatic {\n        /**\n         * This method is like `_.isArrayLike` except that it also checks if `value`\n         * is an object.\n         *\n         * @category Lang\n         * @param value The value to check.\n         * @returns Returns `true` if `value` is an array-like object, else `false`.\n         * @example\n         *\n         * _.isArrayLikeObject([1, 2, 3]);\n         * // => true\n         *\n         * _.isArrayLikeObject(document.body.children);\n         * // => true\n         *\n         * _.isArrayLikeObject('abc');\n         * // => false\n         *\n         * _.isArrayLikeObject(_.noop);\n         * // => false\n         */\n        isArrayLikeObject<T>(value: T & string & number): boolean; // should only match if T = any\n\n        /**\n         * @see _.isArrayLike\n         */\n        isArrayLikeObject(value: ((...args: any[]) => any) | Function | string | boolean | number | null | undefined): value is never;\n\n        /**\n         * @see _.isArrayLike\n         */\n        isArrayLikeObject<T extends object>(value: T | string | boolean | number | null | undefined): value is T & { length: number };\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isArrayLikeObject\n         */\n        isArrayLikeObject(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isArrayLikeObject\n         */\n        isArrayLikeObject(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isBoolean\n    interface LoDashStatic {\n        /**\n         * Checks if value is classified as a boolean primitive or object.\n         *\n         * @param value The value to check.\n         * @return Returns true if value is correctly classified, else false.\n         */\n        isBoolean(value?: any): value is boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isBoolean\n         */\n        isBoolean(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isBoolean\n         */\n        isBoolean(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isBuffer\n    interface LoDashStatic {\n        /**\n         * Checks if value is a buffer.\n         *\n         * @param value The value to check.\n         * @return Returns true if value is a buffer, else false.\n         */\n        isBuffer(value?: any): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isBuffer\n         */\n        isBuffer(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isBuffer\n         */\n        isBuffer(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isDate\n    interface LoDashStatic {\n        /**\n         * Checks if value is classified as a Date object.\n         * @param value The value to check.\n         *\n         * @return Returns true if value is correctly classified, else false.\n         */\n        isDate(value?: any): value is Date;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isDate\n         */\n        isDate(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isDate\n         */\n        isDate(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isElement\n    interface LoDashStatic {\n        /**\n         * Checks if value is a DOM element.\n         *\n         * @param value The value to check.\n         * @return Returns true if value is a DOM element, else false.\n         */\n        isElement(value?: any): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isElement\n         */\n        isElement(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isElement\n         */\n        isElement(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isEmpty\n    interface LoDashStatic {\n        /**\n         * Checks if value is empty. A value is considered empty unless itâs an arguments object, array, string, or\n         * jQuery-like collection with a length greater than 0 or an object with own enumerable properties.\n         *\n         * @param value The value to inspect.\n         * @return Returns true if value is empty, else false.\n         */\n        isEmpty(value?: any): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isEmpty\n         */\n        isEmpty(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isEmpty\n         */\n        isEmpty(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isEqual\n    interface LoDashStatic {\n        /**\n         * Performs a deep comparison between two values to determine if they are\n         * equivalent.\n         *\n         * **Note:** This method supports comparing arrays, array buffers, booleans,\n         * date objects, error objects, maps, numbers, `Object` objects, regexes,\n         * sets, strings, symbols, and typed arrays. `Object` objects are compared\n         * by their own, not inherited, enumerable properties. Functions and DOM\n         * nodes are **not** supported.\n         *\n         * @category Lang\n         * @param value The value to compare.\n         * @param other The other value to compare.\n         * @returns Returns `true` if the values are equivalent, else `false`.\n         * @example\n         *\n         * var object = { 'user': 'fred' };\n         * var other = { 'user': 'fred' };\n         *\n         * _.isEqual(object, other);\n         * // => true\n         *\n         * object === other;\n         * // => false\n         */\n        isEqual(\n            value: any,\n            other: any\n        ): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isEqual\n         */\n        isEqual(\n            other: any\n        ): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isEqual\n         */\n        isEqual(\n            other: any\n        ): LoDashExplicitWrapper<boolean>;\n    }\n\n    // _.isEqualWith\n    type IsEqualCustomizer = (value: any, other: any, indexOrKey: PropertyName | undefined, parent: any, otherParent: any, stack: any) => boolean|undefined;\n\n    interface LoDashStatic {\n        /**\n         * This method is like `_.isEqual` except that it accepts `customizer` which is\n         * invoked to compare values. If `customizer` returns `undefined` comparisons are\n         * handled by the method instead. The `customizer` is invoked with up to seven arguments:\n         * (objValue, othValue [, index|key, object, other, stack]).\n         *\n         * @category Lang\n         * @param value The value to compare.\n         * @param other The other value to compare.\n         * @param [customizer] The function to customize comparisons.\n         * @returns Returns `true` if the values are equivalent, else `false`.\n         * @example\n         *\n         * function isGreeting(value) {\n         *   return /^h(?:i|ello)$/.test(value);\n         * }\n         *\n         * function customizer(objValue, othValue) {\n         *   if (isGreeting(objValue) && isGreeting(othValue)) {\n         *     return true;\n         *   }\n         * }\n         *\n         * var array = ['hello', 'goodbye'];\n         * var other = ['hi', 'goodbye'];\n         *\n         * _.isEqualWith(array, other, customizer);\n         * // => true\n         */\n        isEqualWith(\n            value: any,\n            other: any,\n            customizer?: IsEqualCustomizer\n        ): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isEqualWith\n         */\n        isEqualWith(\n            other: any,\n            customizer?: IsEqualCustomizer\n        ): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isEqualWith\n         */\n        isEqualWith(\n            other: any,\n            customizer?: IsEqualCustomizer\n        ): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isError\n    interface LoDashStatic {\n        /**\n         * Checks if value is an Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, or URIError\n         * object.\n         *\n         * @param value The value to check.\n         * @return Returns true if value is an error object, else false.\n         */\n        isError(value: any): value is Error;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isError\n         */\n        isError(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isError\n         */\n        isError(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isFinite\n    interface LoDashStatic {\n        /**\n         * Checks if value is a finite primitive number.\n         *\n         * Note: This method is based on Number.isFinite.\n         *\n         * @param value The value to check.\n         * @return Returns true if value is a finite number, else false.\n         */\n        isFinite(value?: any): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isFinite\n         */\n        isFinite(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isFinite\n         */\n        isFinite(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isFunction\n    interface LoDashStatic {\n        /**\n         * Checks if value is a callable function.\n         *\n         * @param value The value to check.\n         * @return Returns true if value is correctly classified, else false.\n         */\n        isFunction(value: any): value is (...args: any[]) => any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isFunction\n         */\n        isFunction(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isFunction\n         */\n        isFunction(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isInteger\n    interface LoDashStatic {\n        /**\n         * Checks if `value` is an integer.\n         *\n         * **Note:** This method is based on [`Number.isInteger`](https://mdn.io/Number/isInteger).\n         *\n         * @category Lang\n         * @param value The value to check.\n         * @returns Returns `true` if `value` is an integer, else `false`.\n         * @example\n         *\n         * _.isInteger(3);\n         * // => true\n         *\n         * _.isInteger(Number.MIN_VALUE);\n         * // => false\n         *\n         * _.isInteger(Infinity);\n         * // => false\n         *\n         * _.isInteger('3');\n         * // => false\n         */\n        isInteger(value?: any): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isInteger\n         */\n        isInteger(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isInteger\n         */\n        isInteger(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isLength\n    interface LoDashStatic {\n        /**\n         * Checks if `value` is a valid array-like length.\n         *\n         * **Note:** This function is loosely based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\n         *\n         * @category Lang\n         * @param value The value to check.\n         * @returns Returns `true` if `value` is a valid length, else `false`.\n         * @example\n         *\n         * _.isLength(3);\n         * // => true\n         *\n         * _.isLength(Number.MIN_VALUE);\n         * // => false\n         *\n         * _.isLength(Infinity);\n         * // => false\n         *\n         * _.isLength('3');\n         * // => false\n         */\n        isLength(value?: any): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isLength\n         */\n        isLength(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isLength\n         */\n        isLength(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isMap\n    interface LoDashStatic {\n        /**\n         * Checks if value is classified as a Map object.\n         *\n         * @param value The value to check.\n         * @returns Returns true if value is correctly classified, else false.\n         */\n        isMap(value?: any): value is Map<any, any>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isMap\n         */\n        isMap(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isMap\n         */\n        isMap(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isMatch\n    type isMatchCustomizer = (value: any, other: any, indexOrKey?: PropertyName) => boolean;\n\n    interface LoDashStatic {\n        /**\n         * Performs a deep comparison between `object` and `source` to determine if\n         * `object` contains equivalent property values.\n         *\n         * **Note:** This method supports comparing the same values as `_.isEqual`.\n         *\n         * @category Lang\n         * @param object The object to inspect.\n         * @param source The object of property values to match.\n         * @returns Returns `true` if `object` is a match, else `false`.\n         * @example\n         *\n         * var object = { 'user': 'fred', 'age': 40 };\n         *\n         * _.isMatch(object, { 'age': 40 });\n         * // => true\n         *\n         * _.isMatch(object, { 'age': 36 });\n         * // => false\n         */\n        isMatch(object: object, source: object): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isMatch\n         */\n        isMatch(source: object): boolean;\n    }\n\n    //_.isMatchWith\n    type isMatchWithCustomizer = (value: any, other: any, indexOrKey: PropertyName) => boolean;\n\n    interface LoDashStatic {\n        /**\n         * This method is like `_.isMatch` except that it accepts `customizer` which\n         * is invoked to compare values. If `customizer` returns `undefined` comparisons\n         * are handled by the method instead. The `customizer` is invoked with three\n         * arguments: (objValue, srcValue, index|key, object, source).\n         *\n         * @category Lang\n         * @param object The object to inspect.\n         * @param source The object of property values to match.\n         * @param [customizer] The function to customize comparisons.\n         * @returns Returns `true` if `object` is a match, else `false`.\n         * @example\n         *\n         * function isGreeting(value) {\n         *   return /^h(?:i|ello)$/.test(value);\n         * }\n         *\n         * function customizer(objValue, srcValue) {\n         *   if (isGreeting(objValue) && isGreeting(srcValue)) {\n         *     return true;\n         *   }\n         * }\n         *\n         * var object = { 'greeting': 'hello' };\n         * var source = { 'greeting': 'hi' };\n         *\n         * _.isMatchWith(object, source, customizer);\n         * // => true\n         */\n        isMatchWith(object: object, source: object, customizer: isMatchWithCustomizer): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isMatchWith\n         */\n        isMatchWith(source: object, customizer: isMatchWithCustomizer): boolean;\n    }\n\n    //_.isNaN\n    interface LoDashStatic {\n        /**\n         * Checks if value is NaN.\n         *\n         * Note: This method is not the same as isNaN which returns true for undefined and other non-numeric values.\n         *\n         * @param value The value to check.\n         * @return Returns true if value is NaN, else false.\n         */\n        isNaN(value?: any): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isNaN\n         */\n        isNaN(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isNaN\n         */\n        isNaN(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isNative\n    interface LoDashStatic {\n        /**\n         * Checks if value is a native function.\n         * @param value The value to check.\n         *\n         * @retrun Returns true if value is a native function, else false.\n         */\n        isNative(value: any): value is ((...args: any[]) => any) | Function;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * see _.isNative\n         */\n        isNative(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * see _.isNative\n         */\n        isNative(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isNil\n    interface LoDashStatic {\n        /**\n         * Checks if `value` is `null` or `undefined`.\n         *\n         * @category Lang\n         * @param value The value to check.\n         * @returns Returns `true` if `value` is nullish, else `false`.\n         * @example\n         *\n         * _.isNil(null);\n         * // => true\n         *\n         * _.isNil(void 0);\n         * // => true\n         *\n         * _.isNil(NaN);\n         * // => false\n         */\n        isNil(value: any): value is null | undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * see _.isNil\n         */\n        isNil(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * see _.isNil\n         */\n        isNil(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isNull\n    interface LoDashStatic {\n        /**\n         * Checks if value is null.\n         *\n         * @param value The value to check.\n         * @return Returns true if value is null, else false.\n         */\n        isNull(value: any): value is null;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * see _.isNull\n         */\n        isNull(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * see _.isNull\n         */\n        isNull(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isNumber\n    interface LoDashStatic {\n        /**\n         * Checks if value is classified as a Number primitive or object.\n         *\n         * Note: To exclude Infinity, -Infinity, and NaN, which are classified as numbers, use the _.isFinite method.\n         *\n         * @param value The value to check.\n         * @return Returns true if value is correctly classified, else false.\n         */\n        isNumber(value?: any): value is number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * see _.isNumber\n         */\n        isNumber(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * see _.isNumber\n         */\n        isNumber(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isObject\n    interface LoDashStatic {\n        /**\n         * Checks if value is the language type of Object. (e.g. arrays, functions, objects, regexes, new Number(0),\n         * and new String(''))\n         *\n         * @param value The value to check.\n         * @return Returns true if value is an object, else false.\n         */\n        isObject(value?: any): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * see _.isObject\n         */\n        isObject(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * see _.isObject\n         */\n        isObject(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isObjectLike\n    interface LoDashStatic {\n        /**\n         * Checks if `value` is object-like. A value is object-like if it's not `null`\n         * and has a `typeof` result of \"object\".\n         *\n         * @category Lang\n         * @param value The value to check.\n         * @returns Returns `true` if `value` is object-like, else `false`.\n         * @example\n         *\n         * _.isObjectLike({});\n         * // => true\n         *\n         * _.isObjectLike([1, 2, 3]);\n         * // => true\n         *\n         * _.isObjectLike(_.noop);\n         * // => false\n         *\n         * _.isObjectLike(null);\n         * // => false\n         */\n        isObjectLike(value?: any): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * see _.isObjectLike\n         */\n        isObjectLike(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * see _.isObjectLike\n         */\n        isObjectLike(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isPlainObject\n    interface LoDashStatic {\n        /**\n         * Checks if value is a plain object, that is, an object created by the Object constructor or one with a\n         * [[Prototype]] of null.\n         *\n         * Note: This method assumes objects created by the Object constructor have no inherited enumerable properties.\n         *\n         * @param value The value to check.\n         * @return Returns true if value is a plain object, else false.\n         */\n        isPlainObject(value?: any): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * see _.isPlainObject\n         */\n        isPlainObject(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * see _.isPlainObject\n         */\n        isPlainObject(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isRegExp\n    interface LoDashStatic {\n        /**\n         * Checks if value is classified as a RegExp object.\n         * @param value The value to check.\n         *\n         * @return Returns true if value is correctly classified, else false.\n         */\n        isRegExp(value?: any): value is RegExp;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * see _.isRegExp\n         */\n        isRegExp(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * see _.isRegExp\n         */\n        isRegExp(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isSafeInteger\n    interface LoDashStatic {\n        /**\n         * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754\n         * double precision number which isn't the result of a rounded unsafe integer.\n         *\n         * **Note:** This method is based on [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).\n         *\n         * @category Lang\n         * @param value The value to check.\n         * @returns Returns `true` if `value` is a safe integer, else `false`.\n         * @example\n         *\n         * _.isSafeInteger(3);\n         * // => true\n         *\n         * _.isSafeInteger(Number.MIN_VALUE);\n         * // => false\n         *\n         * _.isSafeInteger(Infinity);\n         * // => false\n         *\n         * _.isSafeInteger('3');\n         * // => false\n         */\n        isSafeInteger(value: any): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * see _.isSafeInteger\n         */\n        isSafeInteger(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * see _.isSafeInteger\n         */\n        isSafeInteger(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isSet\n    interface LoDashStatic {\n        /**\n         * Checks if value is classified as a Set object.\n         *\n         * @param value The value to check.\n         * @returns Returns true if value is correctly classified, else false.\n         */\n        isSet(value?: any): value is Set<any>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isSet\n         */\n        isSet(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isSet\n         */\n        isSet(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isString\n    interface LoDashStatic {\n        /**\n         * Checks if value is classified as a String primitive or object.\n         *\n         * @param value The value to check.\n         * @return Returns true if value is correctly classified, else false.\n         */\n        isString(value?: any): value is string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * see _.isString\n         */\n        isString(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * see _.isString\n         */\n        isString(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isSymbol\n    interface LoDashStatic {\n        /**\n         * Checks if `value` is classified as a `Symbol` primitive or object.\n         *\n         * @category Lang\n         * @param value The value to check.\n         * @returns Returns `true` if `value` is correctly classified, else `false`.\n         * @example\n         *\n         * _.isSymbol(Symbol.iterator);\n         * // => true\n         *\n         * _.isSymbol('abc');\n         * // => false\n         */\n        isSymbol(value: any): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * see _.isSymbol\n         */\n        isSymbol(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * see _.isSymbol\n         */\n        isSymbol(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isTypedArray\n    interface LoDashStatic {\n        /**\n         * Checks if value is classified as a typed array.\n         *\n         * @param value The value to check.\n         * @return Returns true if value is correctly classified, else false.\n         */\n        isTypedArray(value: any): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * see _.isTypedArray\n         */\n        isTypedArray(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * see _.isTypedArray\n         */\n        isTypedArray(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isUndefined\n    interface LoDashStatic {\n        /**\n         * Checks if value is undefined.\n         *\n         * @param value The value to check.\n         * @return Returns true if value is undefined, else false.\n         */\n        isUndefined(value: any): value is undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * see _.isUndefined\n         */\n        isUndefined(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * see _.isUndefined\n         */\n        isUndefined(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isWeakMap\n    interface LoDashStatic {\n        /**\n         * Checks if value is classified as a WeakMap object.\n         *\n         * @param value The value to check.\n         * @returns Returns true if value is correctly classified, else false.\n         */\n        isWeakMap(value?: any): value is WeakMap<object, any>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isSet\n         */\n        isWeakMap(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isSet\n         */\n        isWeakMap(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.isWeakSet\n    interface LoDashStatic {\n        /**\n         * Checks if value is classified as a WeakSet object.\n         *\n         * @param value The value to check.\n         * @returns Returns true if value is correctly classified, else false.\n         */\n        isWeakSet(value?: any): value is WeakSet<object>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.isWeakSet\n         */\n        isWeakSet(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.isWeakSet\n         */\n        isWeakSet(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.lt\n    interface LoDashStatic {\n        /**\n         * Checks if value is less than other.\n         *\n         * @param value The value to compare.\n         * @param other The other value to compare.\n         * @return Returns true if value is less than other, else false.\n         */\n        lt(\n            value: any,\n            other: any\n        ): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.lt\n         */\n        lt(other: any): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.lt\n         */\n        lt(other: any): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.lte\n    interface LoDashStatic {\n        /**\n         * Checks if value is less than or equal to other.\n         *\n         * @param value The value to compare.\n         * @param other The other value to compare.\n         * @return Returns true if value is less than or equal to other, else false.\n         */\n        lte(\n            value: any,\n            other: any\n        ): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.lte\n         */\n        lte(other: any): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.lte\n         */\n        lte(other: any): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.toArray\n    interface LoDashStatic {\n        /**\n         * Converts value to an array.\n         *\n         * @param value The value to convert.\n         * @return Returns the converted array.\n         */\n        toArray<T>(value: List<T> | Dictionary<T> | NumericDictionary<T> | null | undefined): T[];\n\n        /**\n         * @see _.toArray\n         */\n        toArray<T>(value: T): Array<T[keyof T]>;\n\n        /**\n         * @see _.toArray\n         */\n        toArray(): any[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.toArray\n         */\n        toArray<T>(this: LoDashImplicitWrapper<List<T> | Dictionary<T> | NumericDictionary<T> | null | undefined>): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.toArray\n         */\n        toArray<T extends object>(this: LoDashImplicitWrapper<T>): LoDashImplicitWrapper<Array<T[keyof T]>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.toArray\n         */\n        toArray<T>(this: LoDashExplicitWrapper<List<T> | Dictionary<T> | NumericDictionary<T> | null | undefined>): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.toArray\n         */\n        toArray<T extends object>(this: LoDashImplicitWrapper<T>): LoDashExplicitWrapper<Array<T[keyof T]>>;\n    }\n\n    //_.toPlainObject\n    interface LoDashStatic {\n        /**\n         * Converts value to a plain object flattening inherited enumerable properties of value to own properties\n         * of the plain object.\n         *\n         * @param value The value to convert.\n         * @return Returns the converted plain object.\n         */\n        toPlainObject(value?: any): any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.toPlainObject\n         */\n        toPlainObject(): LoDashImplicitWrapper<any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.toPlainObject\n         */\n        toPlainObject(): LoDashExplicitWrapper<any>;\n    }\n\n    //_.toFinite\n    interface LoDashStatic {\n        /**\n         * Converts `value` to a finite number.\n         *\n         * @since 4.12.0\n         * @category Lang\n         * @param value The value to convert.\n         * @returns Returns the converted number.\n         * @example\n         *\n         * _.toFinite(3.2);\n         * // => 3.2\n         *\n         * _.toFinite(Number.MIN_VALUE);\n         * // => 5e-324\n         *\n         * _.toFinite(Infinity);\n         * // => 1.7976931348623157e+308\n         *\n         * _.toFinite('3.2');\n         * // => 3.2\n         */\n        toFinite(value: any): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.toFinite\n         */\n        toFinite(): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.toFinite\n         */\n        toFinite(): LoDashExplicitWrapper<number>;\n    }\n\n    //_.toInteger\n    interface LoDashStatic {\n        /**\n         * Converts `value` to an integer.\n         *\n         * **Note:** This function is loosely based on [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).\n         *\n         * @category Lang\n         * @param value The value to convert.\n         * @returns Returns the converted integer.\n         * @example\n         *\n         * _.toInteger(3);\n         * // => 3\n         *\n         * _.toInteger(Number.MIN_VALUE);\n         * // => 0\n         *\n         * _.toInteger(Infinity);\n         * // => 1.7976931348623157e+308\n         *\n         * _.toInteger('3');\n         * // => 3\n         */\n        toInteger(value: any): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.toInteger\n         */\n        toInteger(): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.toInteger\n         */\n        toInteger(): LoDashExplicitWrapper<number>;\n    }\n\n    //_.toLength\n    interface LoDashStatic {\n        /**\n         * Converts `value` to an integer suitable for use as the length of an\n         * array-like object.\n         *\n         * **Note:** This method is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\n         *\n         * @category Lang\n         * @param value The value to convert.\n         * @return Returns the converted integer.\n         * @example\n         *\n         * _.toLength(3);\n         * // => 3\n         *\n         * _.toLength(Number.MIN_VALUE);\n         * // => 0\n         *\n         * _.toLength(Infinity);\n         * // => 4294967295\n         *\n         * _.toLength('3');\n         * // => 3\n         */\n        toLength(value: any): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.toLength\n         */\n        toLength(): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.toLength\n         */\n        toLength(): LoDashExplicitWrapper<number>;\n    }\n\n    //_.toNumber\n    interface LoDashStatic {\n        /**\n         * Converts `value` to a number.\n         *\n         * @category Lang\n         * @param value The value to process.\n         * @returns Returns the number.\n         * @example\n         *\n         * _.toNumber(3);\n         * // => 3\n         *\n         * _.toNumber(Number.MIN_VALUE);\n         * // => 5e-324\n         *\n         * _.toNumber(Infinity);\n         * // => Infinity\n         *\n         * _.toNumber('3');\n         * // => 3\n         */\n        toNumber(value: any): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.toNumber\n         */\n        toNumber(): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.toNumber\n         */\n        toNumber(): LoDashExplicitWrapper<number>;\n    }\n\n    //_.toSafeInteger\n    interface LoDashStatic {\n        /**\n         * Converts `value` to a safe integer. A safe integer can be compared and\n         * represented correctly.\n         *\n         * @category Lang\n         * @param value The value to convert.\n         * @returns Returns the converted integer.\n         * @example\n         *\n         * _.toSafeInteger(3);\n         * // => 3\n         *\n         * _.toSafeInteger(Number.MIN_VALUE);\n         * // => 0\n         *\n         * _.toSafeInteger(Infinity);\n         * // => 9007199254740991\n         *\n         * _.toSafeInteger('3');\n         * // => 3\n         */\n        toSafeInteger(value: any): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.toSafeInteger\n         */\n        toSafeInteger(): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.toSafeInteger\n         */\n        toSafeInteger(): LoDashExplicitWrapper<number>;\n    }\n\n    //_.toString\n    interface LoDashStatic {\n        /**\n         * Converts `value` to a string if it's not one. An empty string is returned\n         * for `null` and `undefined` values. The sign of `-0` is preserved.\n         *\n         * @category Lang\n         * @param value The value to process.\n         * @returns Returns the string.\n         * @example\n         *\n         * _.toString(null);\n         * // => ''\n         *\n         * _.toString(-0);\n         * // => '-0'\n         *\n         * _.toString([1, 2, 3]);\n         * // => '1,2,3'\n         */\n        toString(value: any): string;\n    }\n\n    /********\n     * Math *\n     ********/\n\n    //_.add\n    interface LoDashStatic {\n        /**\n         * Adds two numbers.\n         *\n         * @param augend The first number to add.\n         * @param addend The second number to add.\n         * @return Returns the sum.\n         */\n        add(\n            augend: number,\n            addend: number\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.add\n         */\n        add(addend: number): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.add\n         */\n        add(addend: number): LoDashExplicitWrapper<number>;\n    }\n\n    //_.ceil\n    interface LoDashStatic {\n        /**\n         * Calculates n rounded up to precision.\n         *\n         * @param n The number to round up.\n         * @param precision The precision to round up to.\n         * @return Returns the rounded up number.\n         */\n        ceil(\n            n: number,\n            precision?: number\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.ceil\n         */\n        ceil(precision?: number): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.ceil\n         */\n        ceil(precision?: number): LoDashExplicitWrapper<number>;\n    }\n\n    //_.divide\n    interface LoDashStatic {\n       /**\n        * Divide two numbers.\n        *\n        * @param dividend The first number in a division.\n        * @param divisor The second number in a division.\n        * @returns Returns the quotient.\n        */\n        divide(\n            dividend: number,\n            divisor: number\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.divide\n         */\n        divide(divisor: number): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.divide\n         */\n        divide(divisor: number): LoDashExplicitWrapper<number>;\n    }\n\n    //_.floor\n    interface LoDashStatic {\n        /**\n         * Calculates n rounded down to precision.\n         *\n         * @param n The number to round down.\n         * @param precision The precision to round down to.\n         * @return Returns the rounded down number.\n         */\n        floor(\n            n: number,\n            precision?: number\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.floor\n         */\n        floor(precision?: number): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.floor\n         */\n        floor(precision?: number): LoDashExplicitWrapper<number>;\n    }\n\n    //_.max\n    interface LoDashStatic {\n         /**\n          * Computes the maximum value of `array`. If `array` is empty or falsey\n          * `undefined` is returned.\n          *\n          * @category Math\n          * @param array The array to iterate over.\n          * @returns Returns the maximum value.\n          */\n        max<T>(\n            collection: List<T> | null | undefined\n        ): T | undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.max\n         */\n        max<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>): T | undefined;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.max\n         */\n        max<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>): LoDashExplicitWrapper<T | undefined>;\n    }\n\n    //_.maxBy\n    interface LoDashStatic {\n        /**\n         * This method is like `_.max` except that it accepts `iteratee` which is\n         * invoked for each element in `array` to generate the criterion by which\n         * the value is ranked. The iteratee is invoked with one argument: (value).\n         *\n         * @category Math\n         * @param array The array to iterate over.\n         * @param [iteratee=_.identity] The iteratee invoked per element.\n         * @returns Returns the maximum value.\n         * @example\n         *\n         * var objects = [{ 'n': 1 }, { 'n': 2 }];\n         *\n         * _.maxBy(objects, function(o) { return o.a; });\n         * // => { 'n': 2 }\n         *\n         * // using the `_.property` iteratee shorthand\n         * _.maxBy(objects, 'n');\n         * // => { 'n': 2 }\n         */\n        maxBy<T>(\n            collection: List<T> | null | undefined,\n            iteratee?: ListIteratee<T>\n        ): T | undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.maxBy\n         */\n        maxBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ListIteratee<T>\n        ): T | undefined;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.maxBy\n         */\n        maxBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ListIteratee<T>\n        ): LoDashExplicitWrapper<T | undefined>;\n    }\n\n    //_.mean\n    interface LoDashStatic {\n        /**\n         * Computes the mean of the values in `array`.\n         *\n         * @category Math\n         * @param array The array to iterate over.\n         * @returns Returns the mean.\n         * @example\n         *\n         * _.mean([4, 2, 8, 6]);\n         * // => 5\n         */\n        mean(\n            collection: List<any> | null | undefined\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.mean\n         */\n        mean(): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.mean\n         */\n        mean(): LoDashExplicitWrapper<number>;\n    }\n\n    //_.meanBy\n    interface LoDashStatic {\n      /**\n       * Computes the mean of the provided propties of the objects in the `array`\n       *\n       * @category Math\n       * @param array The array to iterate over.\n       * @param [iteratee=_.identity] The iteratee invoked per element.\n       * @returns Returns the mean.\n       * @example\n       *\n       * _.mean([{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }], 'n');\n       * // => 5\n       */\n        meanBy<T>(\n            collection: List<T> | null | undefined,\n            iteratee?: ListIteratee<T>\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.meanBy\n         */\n        meanBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ListIteratee<T>\n        ): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.meanBy\n         */\n        meanBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ListIteratee<T>\n        ): LoDashExplicitWrapper<number>;\n    }\n\n    //_.min\n    interface LoDashStatic {\n        /**\n         * Computes the minimum value of `array`. If `array` is empty or falsey\n         * `undefined` is returned.\n         *\n         * @category Math\n         * @param array The array to iterate over.\n         * @returns Returns the minimum value.\n         */\n        min<T>(\n            collection: List<T> | null | undefined\n        ): T | undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.min\n         */\n        min<T>(this: LoDashImplicitWrapper<List<T> | null | undefined>): T | undefined;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.min\n         */\n        min<T>(this: LoDashExplicitWrapper<List<T> | null | undefined>): LoDashExplicitWrapper<T | undefined>;\n    }\n\n    //_.minBy\n    interface LoDashStatic {\n        /**\n         * This method is like `_.min` except that it accepts `iteratee` which is\n         * invoked for each element in `array` to generate the criterion by which\n         * the value is ranked. The iteratee is invoked with one argument: (value).\n         *\n         * @category Math\n         * @param array The array to iterate over.\n         * @param [iteratee=_.identity] The iteratee invoked per element.\n         * @returns Returns the minimum value.\n         * @example\n         *\n         * var objects = [{ 'n': 1 }, { 'n': 2 }];\n         *\n         * _.minBy(objects, function(o) { return o.a; });\n         * // => { 'n': 1 }\n         *\n         * // using the `_.property` iteratee shorthand\n         * _.minBy(objects, 'n');\n         * // => { 'n': 1 }\n         */\n        minBy<T>(\n            collection: List<T> | null | undefined,\n            iteratee?: ListIteratee<T>\n        ): T | undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.minBy\n         */\n        minBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ListIteratee<T>\n        ): T | undefined;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.minBy\n         */\n        minBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ListIteratee<T>\n        ): LoDashExplicitWrapper<T | undefined>;\n    }\n\n    //_.multiply\n    interface LoDashStatic {\n        /**\n         * Multiply two numbers.\n         * @param multiplier The first number in a multiplication.\n         * @param multiplicand The second number in a multiplication.\n         * @returns Returns the product.\n         */\n        multiply(\n            multiplier: number,\n            multiplicand: number\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.multiply\n         */\n        multiply(multiplicand: number): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.multiply\n         */\n        multiply(multiplicand: number): LoDashExplicitWrapper<number>;\n    }\n\n    //_.round\n    interface LoDashStatic {\n        /**\n         * Calculates n rounded to precision.\n         *\n         * @param n The number to round.\n         * @param precision The precision to round to.\n         * @return Returns the rounded number.\n         */\n        round(\n            n: number,\n            precision?: number\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.round\n         */\n        round(precision?: number): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.round\n         */\n        round(precision?: number): LoDashExplicitWrapper<number>;\n    }\n\n    //_.sum\n    interface LoDashStatic {\n        /**\n         * Computes the sum of the values in `array`.\n         *\n         * @category Math\n         * @param array The array to iterate over.\n         * @returns Returns the sum.\n         * @example\n         *\n         * _.sum([4, 2, 8, 6]);\n         * // => 20\n         */\n        sum(collection: List<any> | null | undefined): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.sum\n         */\n        sum(): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.sum\n         */\n        sum(): LoDashExplicitWrapper<number>;\n    }\n\n    //_.sumBy\n    interface LoDashStatic {\n        /**\n         * This method is like `_.sum` except that it accepts `iteratee` which is\n         * invoked for each element in `array` to generate the value to be summed.\n         * The iteratee is invoked with one argument: (value).\n         *\n         * @category Math\n         * @param array The array to iterate over.\n         * @param [iteratee=_.identity] The iteratee invoked per element.\n         * @returns Returns the sum.\n         * @example\n         *\n         * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n         *\n         * _.sumBy(objects, function(o) { return o.n; });\n         * // => 20\n         *\n         * // using the `_.property` iteratee shorthand\n         * _.sumBy(objects, 'n');\n         * // => 20\n         */\n        sumBy<T>(\n            collection: List<T> | null | undefined,\n            iteratee?: ((value: T) => number) | string\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.sumBy\n         */\n        sumBy<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ((value: T) => number) | string\n        ): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.sumBy\n         */\n        sumBy<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ((value: T) => number) | string\n        ): LoDashExplicitWrapper<number>;\n    }\n\n    /**********\n     * Number *\n     **********/\n\n    //_.subtract\n    interface LoDashStatic {\n        /**\n         * Subtract two numbers.\n         *\n         * @category Math\n         * @param minuend The first number in a subtraction.\n         * @param subtrahend The second number in a subtraction.\n         * @returns Returns the difference.\n         * @example\n         *\n         * _.subtract(6, 4);\n         * // => 2\n         */\n        subtract(\n            minuend: number,\n            subtrahend: number\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.subtract\n         */\n        subtract(\n            subtrahend: number\n        ): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.subtract\n         */\n        subtract(\n            subtrahend: number\n        ): LoDashExplicitWrapper<number>;\n    }\n\n    //_.clamp\n    interface LoDashStatic {\n        /**\n         * Clamps `number` within the inclusive `lower` and `upper` bounds.\n         *\n         * @category Number\n         * @param number The number to clamp.\n         * @param [lower] The lower bound.\n         * @param upper The upper bound.\n         * @returns Returns the clamped number.\n         * @example\n         *\n         * _.clamp(-10, -5, 5);\n         * // => -5\n         *\n         * _.clamp(10, -5, 5);\n         * // => 5\n         */\n        clamp(\n            number: number,\n            lower: number,\n            upper: number\n        ): number;\n        clamp(\n            number: number,\n            upper: number\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.clamp\n         */\n        clamp(\n            lower: number,\n            upper: number\n        ): number;\n        clamp(\n            upper: number\n        ): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.clamp\n         */\n        clamp(\n            lower: number,\n            upper: number\n        ): LoDashExplicitWrapper<number>;\n        clamp(\n            upper: number\n        ): LoDashExplicitWrapper<number>;\n    }\n\n    //_.inRange\n    interface LoDashStatic {\n        /**\n         * Checks if n is between start and up to but not including, end. If end is not specified itâs set to start\n         * with start then set to 0.\n         *\n         * @param n The number to check.\n         * @param start The start of the range.\n         * @param end The end of the range.\n         * @return Returns true if n is in the range, else false.\n         */\n        inRange(\n            n: number,\n            start: number,\n            end?: number\n        ): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.inRange\n         */\n        inRange(\n            start: number,\n            end?: number\n        ): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.inRange\n         */\n        inRange(\n            start: number,\n            end?: number\n        ): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.random\n    interface LoDashStatic {\n        /**\n         * Produces a random number between min and max (inclusive). If only one argument is provided a number between\n         * 0 and the given number is returned. If floating is true, or either min or max are floats, a floating-point\n         * number is returned instead of an integer.\n         *\n         * @param min The minimum possible value.\n         * @param max The maximum possible value.\n         * @param floating Specify returning a floating-point number.\n         * @return Returns the random number.\n         */\n        random(\n            floating?: boolean\n        ): number;\n\n        /**\n         * @see _.random\n         */\n        random(\n            max: number,\n            floating?: boolean\n        ): number;\n\n        /**\n         * @see _.random\n         */\n        random(\n            min: number,\n            max: number,\n            floating?: boolean\n        ): number;\n\n        /**\n         * Produces a random number between min and max (inclusive). If only one argument is provided a number between\n         * 0 and the given number is returned. If floating is true, or either min or max are floats, a floating-point\n         * number is returned instead of an integer.\n         *\n         * @param min The minimum possible value.\n         * @param index Not used in this overload.\n         * @param guard Enables use as an iteratee for methods like _.map. You should not pass this parameter directly in your code.\n         * @return Returns the random number.\n         */\n        random(\n            min: number,\n            index: string | number,\n            guard: object\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.random\n         */\n        random(floating?: boolean): number;\n\n        /**\n         * @see _.random\n         */\n        random(\n            max: number,\n            floating?: boolean\n        ): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.random\n         */\n        random(floating?: boolean): LoDashExplicitWrapper<number>;\n\n        /**\n         * @see _.random\n         */\n        random(\n            max: number,\n            floating?: boolean\n        ): LoDashExplicitWrapper<number>;\n    }\n\n    /**********\n     * Object *\n     **********/\n\n    //_.assign\n    interface LoDashStatic {\n        /**\n         * Assigns own enumerable properties of source objects to the destination\n         * object. Source objects are applied from left to right. Subsequent sources\n         * overwrite property assignments of previous sources.\n         *\n         * **Note:** This method mutates `object` and is loosely based on\n         * [`Object.assign`](https://mdn.io/Object/assign).\n         *\n         * @category Object\n         * @param object The destination object.\n         * @param [sources] The source objects.\n         * @returns Returns `object`.\n         * @example\n         *\n         * function Foo() {\n         *   this.c = 3;\n         * }\n         *\n         * function Bar() {\n         *   this.e = 5;\n         * }\n         *\n         * Foo.prototype.d = 4;\n         * Bar.prototype.f = 6;\n         *\n         * _.assign({ 'a': 1 }, new Foo, new Bar);\n         * // => { 'a': 1, 'c': 3, 'e': 5 }\n         */\n        assign<TObject, TSource>(\n            object: TObject,\n            source: TSource\n        ): TObject & TSource;\n\n        /**\n         * @see assign\n         */\n        assign<TObject, TSource1, TSource2>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2\n        ): TObject & TSource1 & TSource2;\n\n        /**\n         * @see assign\n         */\n        assign<TObject, TSource1, TSource2, TSource3>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3\n        ): TObject & TSource1 & TSource2 & TSource3;\n\n        /**\n         * @see assign\n         */\n        assign<TObject, TSource1, TSource2, TSource3, TSource4>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4\n        ): TObject & TSource1 & TSource2 & TSource3 & TSource4;\n\n        /**\n         * @see _.assign\n         */\n        assign<TObject>(object: TObject): TObject;\n\n        /**\n         * @see _.assign\n         */\n        assign(\n            object: any,\n            ...otherArgs: any[]\n        ): any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.assign\n         */\n        assign<TSource>(\n            source: TSource\n        ): LoDashImplicitWrapper<TValue & TSource>;\n\n        /**\n         * @see assign\n         */\n        assign<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2>;\n\n        /**\n         * @see assign\n         */\n        assign<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2 & TSource3>;\n\n        /**\n         * @see assign\n         */\n        assign<TSource1, TSource2, TSource3, TSource4>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2 & TSource3 & TSource4>;\n\n        /**\n         * @see _.assign\n         */\n        assign(): LoDashImplicitWrapper<TValue>;\n\n        /**\n         * @see _.assign\n         */\n        assign(...otherArgs: any[]): LoDashImplicitWrapper<any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.assign\n         */\n        assign<TSource>(\n            source: TSource\n        ): LoDashExplicitWrapper<TValue & TSource>;\n\n        /**\n         * @see assign\n         */\n        assign<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2>;\n\n        /**\n         * @see assign\n         */\n        assign<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2 & TSource3>;\n\n        /**\n         * @see assign\n         */\n        assign<TSource1, TSource2, TSource3, TSource4>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2 & TSource3 & TSource4>;\n\n        /**\n         * @see _.assign\n         */\n        assign(): LoDashExplicitWrapper<TValue>;\n\n        /**\n         * @see _.assign\n         */\n        assign(...otherArgs: any[]): LoDashExplicitWrapper<any>;\n    }\n\n    interface LoDashStatic {\n        /**\n         * This method is like `_.assign` except that it accepts `customizer` which\n         * is invoked to produce the assigned values. If `customizer` returns `undefined`\n         * assignment is handled by the method instead. The `customizer` is invoked\n         * with five arguments: (objValue, srcValue, key, object, source).\n         *\n         * **Note:** This method mutates `object`.\n         *\n         * @category Object\n         * @param object The destination object.\n         * @param sources The source objects.\n         * @param [customizer] The function to customize assigned values.\n         * @returns Returns `object`.\n         * @example\n         *\n         * function customizer(objValue, srcValue) {\n         *   return _.isUndefined(objValue) ? srcValue : objValue;\n         * }\n         *\n         * var defaults = _.partialRight(_.assignWith, customizer);\n         *\n         * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n         * // => { 'a': 1, 'b': 2 }\n         */\n        assignWith<TObject, TSource>(\n            object: TObject,\n            source: TSource,\n            customizer: AssignCustomizer\n        ): TObject & TSource;\n\n        /**\n         * @see assignWith\n         */\n        assignWith<TObject, TSource1, TSource2>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            customizer: AssignCustomizer\n        ): TObject & TSource1 & TSource2;\n\n        /**\n         * @see assignWith\n         */\n        assignWith<TObject, TSource1, TSource2, TSource3>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            customizer: AssignCustomizer\n        ): TObject & TSource1 & TSource2 & TSource3;\n\n        /**\n         * @see assignWith\n         */\n        assignWith<TObject, TSource1, TSource2, TSource3, TSource4>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4,\n            customizer: AssignCustomizer\n        ): TObject & TSource1 & TSource2 & TSource3 & TSource4;\n\n        /**\n         * @see _.assignWith\n         */\n        assignWith<TObject>(object: TObject): TObject;\n\n        /**\n         * @see _.assignWith\n         */\n        assignWith<TResult>(\n            object: any,\n            ...otherArgs: any[]\n        ): TResult;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.assignWith\n         */\n        assignWith<TSource>(\n            source: TSource,\n            customizer: AssignCustomizer\n        ): LoDashImplicitWrapper<TValue & TSource>;\n\n        /**\n         * @see assignWith\n         */\n        assignWith<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2,\n            customizer: AssignCustomizer\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2>;\n\n        /**\n         * @see assignWith\n         */\n        assignWith<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            customizer: AssignCustomizer\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2 & TSource3>;\n\n        /**\n         * @see assignWith\n         */\n        assignWith<TSource1, TSource2, TSource3, TSource4>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4,\n            customizer: AssignCustomizer\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2 & TSource3 & TSource4>;\n\n        /**\n         * @see _.assignWith\n         */\n        assignWith(): LoDashImplicitWrapper<TValue>;\n\n        /**\n         * @see _.assignWith\n         */\n        assignWith<TResult>(...otherArgs: any[]): LoDashImplicitWrapper<TResult>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.assignWith\n         */\n        assignWith<TSource>(\n            source: TSource,\n            customizer: AssignCustomizer\n        ): LoDashExplicitWrapper<TValue & TSource>;\n\n        /**\n         * @see assignWith\n         */\n        assignWith<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2,\n            customizer: AssignCustomizer\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2>;\n\n        /**\n         * @see assignWith\n         */\n        assignWith<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            customizer: AssignCustomizer\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2 & TSource3>;\n\n        /**\n         * @see assignWith\n         */\n        assignWith<TSource1, TSource2, TSource3, TSource4>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4,\n            customizer: AssignCustomizer\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2 & TSource3 & TSource4>;\n\n        /**\n         * @see _.assignWith\n         */\n        assignWith(): LoDashExplicitWrapper<TValue>;\n\n        /**\n         * @see _.assignWith\n         */\n        assignWith(...otherArgs: any[]): LoDashExplicitWrapper<any>;\n    }\n\n    //_.assignIn\n    interface LoDashStatic {\n        /**\n         * This method is like `_.assign` except that it iterates over own and\n         * inherited source properties.\n         *\n         * **Note:** This method mutates `object`.\n         *\n         * @alias extend\n         * @category Object\n         * @param object The destination object.\n         * @param [sources] The source objects.\n         * @returns Returns `object`.\n         * @example\n         *\n         * function Foo() {\n         *   this.b = 2;\n         * }\n         *\n         * function Bar() {\n         *   this.d = 4;\n         * }\n         *\n         * Foo.prototype.c = 3;\n         * Bar.prototype.e = 5;\n         *\n         * _.assignIn({ 'a': 1 }, new Foo, new Bar);\n         * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5 }\n         */\n        assignIn<TObject, TSource>(\n            object: TObject,\n            source: TSource\n        ): TObject & TSource;\n\n        /**\n         * @see assignIn\n         */\n        assignIn<TObject, TSource1, TSource2>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2\n        ): TObject & TSource1 & TSource2;\n\n        /**\n         * @see assignIn\n         */\n        assignIn<TObject, TSource1, TSource2, TSource3>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3\n        ): TObject & TSource1 & TSource2 & TSource3;\n\n        /**\n         * @see assignIn\n         */\n        assignIn<TObject, TSource1, TSource2, TSource3, TSource4>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4\n        ): TObject & TSource1 & TSource2 & TSource3 & TSource4;\n\n        /**\n         * @see _.assignIn\n         */\n        assignIn<TObject>(object: TObject): TObject;\n\n        /**\n         * @see _.assignIn\n         */\n        assignIn<TResult>(\n            object: any,\n            ...otherArgs: any[]\n        ): TResult;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.assignIn\n         */\n        assignIn<TSource>(\n            source: TSource\n        ): LoDashImplicitWrapper<TValue & TSource>;\n\n        /**\n         * @see assignIn\n         */\n        assignIn<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2>;\n\n        /**\n         * @see assignIn\n         */\n        assignIn<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2 & TSource3>;\n\n        /**\n         * @see assignIn\n         */\n        assignIn<TSource1, TSource2, TSource3, TSource4>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2 & TSource3 & TSource4>;\n\n        /**\n         * @see _.assignIn\n         */\n        assignIn(): LoDashImplicitWrapper<TValue>;\n\n        /**\n         * @see _.assignIn\n         */\n        assignIn<TResult>(...otherArgs: any[]): LoDashImplicitWrapper<TResult>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.assignIn\n         */\n        assignIn<TSource>(\n            source: TSource\n        ): LoDashExplicitWrapper<TValue & TSource>;\n\n        /**\n         * @see assignIn\n         */\n        assignIn<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2>;\n\n        /**\n         * @see assignIn\n         */\n        assignIn<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2 & TSource3>;\n\n        /**\n         * @see assignIn\n         */\n        assignIn<TSource1, TSource2, TSource3, TSource4>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2 & TSource3 & TSource4>;\n\n        /**\n         * @see _.assignIn\n         */\n        assignIn(): LoDashExplicitWrapper<TValue>;\n\n        /**\n         * @see _.assignIn\n         */\n        assignIn(...otherArgs: any[]): LoDashExplicitWrapper<any>;\n    }\n\n    //_.assignInWith\n    type AssignCustomizer = (objectValue: any, sourceValue: any, key?: string, object?: {}, source?: {}) => any;\n\n    interface LoDashStatic {\n        /**\n         * This method is like `_.assignIn` except that it accepts `customizer` which\n         * is invoked to produce the assigned values. If `customizer` returns `undefined`\n         * assignment is handled by the method instead. The `customizer` is invoked\n         * with five arguments: (objValue, srcValue, key, object, source).\n         *\n         * **Note:** This method mutates `object`.\n         *\n         * @alias extendWith\n         * @category Object\n         * @param object The destination object.\n         * @param sources The source objects.\n         * @param [customizer] The function to customize assigned values.\n         * @returns Returns `object`.\n         * @example\n         *\n         * function customizer(objValue, srcValue) {\n         *   return _.isUndefined(objValue) ? srcValue : objValue;\n         * }\n         *\n         * var defaults = _.partialRight(_.assignInWith, customizer);\n         *\n         * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n         * // => { 'a': 1, 'b': 2 }\n         */\n        assignInWith<TObject, TSource>(\n            object: TObject,\n            source: TSource,\n            customizer: AssignCustomizer\n        ): TObject & TSource;\n\n        /**\n         * @see assignInWith\n         */\n        assignInWith<TObject, TSource1, TSource2>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            customizer: AssignCustomizer\n        ): TObject & TSource1 & TSource2;\n\n        /**\n         * @see assignInWith\n         */\n        assignInWith<TObject, TSource1, TSource2, TSource3>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            customizer: AssignCustomizer\n        ): TObject & TSource1 & TSource2 & TSource3;\n\n        /**\n         * @see assignInWith\n         */\n        assignInWith<TObject, TSource1, TSource2, TSource3, TSource4>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4,\n            customizer: AssignCustomizer\n        ): TObject & TSource1 & TSource2 & TSource3 & TSource4;\n\n        /**\n         * @see _.assignInWith\n         */\n        assignInWith<TObject>(object: TObject): TObject;\n\n        /**\n         * @see _.assignInWith\n         */\n        assignInWith<TResult>(\n            object: any,\n            ...otherArgs: any[]\n        ): TResult;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.assignInWith\n         */\n        assignInWith<TSource>(\n            source: TSource,\n            customizer: AssignCustomizer\n        ): LoDashImplicitWrapper<TValue & TSource>;\n\n        /**\n         * @see assignInWith\n         */\n        assignInWith<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2,\n            customizer: AssignCustomizer\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2>;\n\n        /**\n         * @see assignInWith\n         */\n        assignInWith<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            customizer: AssignCustomizer\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2 & TSource3>;\n\n        /**\n         * @see assignInWith\n         */\n        assignInWith<TSource1, TSource2, TSource3, TSource4>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4,\n            customizer: AssignCustomizer\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2 & TSource3 & TSource4>;\n\n        /**\n         * @see _.assignInWith\n         */\n        assignInWith(): LoDashImplicitWrapper<TValue>;\n\n        /**\n         * @see _.assignInWith\n         */\n        assignInWith<TResult>(...otherArgs: any[]): LoDashImplicitWrapper<TResult>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.assignInWith\n         */\n        assignInWith<TSource>(\n            source: TSource,\n            customizer: AssignCustomizer\n        ): LoDashExplicitWrapper<TValue & TSource>;\n\n        /**\n         * @see assignInWith\n         */\n        assignInWith<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2,\n            customizer: AssignCustomizer\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2>;\n\n        /**\n         * @see assignInWith\n         */\n        assignInWith<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            customizer: AssignCustomizer\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2 & TSource3>;\n\n        /**\n         * @see assignInWith\n         */\n        assignInWith<TSource1, TSource2, TSource3, TSource4>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4,\n            customizer: AssignCustomizer\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2 & TSource3 & TSource4>;\n\n        /**\n         * @see _.assignInWith\n         */\n        assignInWith(): LoDashExplicitWrapper<TValue>;\n\n        /**\n         * @see _.assignInWith\n         */\n        assignInWith(...otherArgs: any[]): LoDashExplicitWrapper<any>;\n    }\n\n    //_.create\n    interface LoDashStatic {\n        /**\n         * Creates an object that inherits from the given prototype object. If a properties object is provided its own\n         * enumerable properties are assigned to the created object.\n         *\n         * @param prototype The object to inherit from.\n         * @param properties The properties to assign to the object.\n         * @return Returns the new object.\n         */\n        create<T extends object, U extends object>(\n            prototype: T,\n            properties?: U\n        ): T & U;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.create\n         */\n        create<U extends object>(properties?: U): LoDashImplicitWrapper<TValue & U>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.create\n         */\n        create<U extends object>(properties?: U): LoDashExplicitWrapper<TValue & U>;\n    }\n\n    //_.defaults\n    interface LoDashStatic {\n        /**\n         * Assigns own enumerable properties of source object(s) to the destination object for all destination\n         * properties that resolve to undefined. Once a property is set, additional values of the same property are\n         * ignored.\n         *\n         * Note: This method mutates object.\n         *\n         * @param object The destination object.\n         * @param sources The source objects.\n         * @return The destination object.\n         */\n        defaults<TObject, TSource>(\n            object: TObject,\n            source: TSource\n        ): TSource & TObject;\n\n        /**\n         * @see _.defaults\n         */\n        defaults<TObject, TSource1, TSource2>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2\n        ): TSource2 & TSource1 & TObject;\n\n        /**\n         * @see _.defaults\n         */\n        defaults<TObject, TSource1, TSource2, TSource3>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3\n        ): TSource3 & TSource2 & TSource1 & TObject;\n\n        /**\n         * @see _.defaults\n         */\n        defaults<TObject, TSource1, TSource2, TSource3, TSource4>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4\n        ): TSource4 & TSource3 & TSource2 & TSource1 & TObject;\n\n        /**\n         * @see _.defaults\n         */\n        defaults<TObject>(object: TObject): TObject;\n\n        /**\n         * @see _.defaults\n         */\n        defaults(\n            object: any,\n            ...sources: any[]\n        ): any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.defaults\n         */\n        defaults<TSource>(\n            source: TSource\n        ): LoDashImplicitWrapper<TSource & TValue>;\n\n        /**\n         * @see _.defaults\n         */\n        defaults<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2\n        ): LoDashImplicitWrapper<TSource2 & TSource1 & TValue>;\n\n        /**\n         * @see _.defaults\n         */\n        defaults<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3\n        ): LoDashImplicitWrapper<TSource3 & TSource2 & TSource1 & TValue>;\n\n        /**\n         * @see _.defaults\n         */\n        defaults<TSource1, TSource2, TSource3, TSource4>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4\n        ): LoDashImplicitWrapper<TSource4 & TSource3 & TSource2 & TSource1 & TValue>;\n\n        /**\n         * @see _.defaults\n         */\n        defaults(): LoDashImplicitWrapper<TValue>;\n\n        /**\n         * @see _.defaults\n         */\n        defaults(...sources: any[]): LoDashImplicitWrapper<any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.defaults\n         */\n        defaults<TSource>(\n            source: TSource\n        ): LoDashExplicitWrapper<TSource & TValue>;\n\n        /**\n         * @see _.defaults\n         */\n        defaults<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2\n        ): LoDashExplicitWrapper<TSource2 & TSource1 & TValue>;\n\n        /**\n         * @see _.defaults\n         */\n        defaults<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3\n        ): LoDashExplicitWrapper<TSource3 & TSource2 & TSource1 & TValue>;\n\n        /**\n         * @see _.defaults\n         */\n        defaults<TSource1, TSource2, TSource3, TSource4>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4\n        ): LoDashExplicitWrapper<TSource4 & TSource3 & TSource2 & TSource1 & TValue>;\n\n        /**\n         * @see _.defaults\n         */\n        defaults(): LoDashExplicitWrapper<TValue>;\n\n        /**\n         * @see _.defaults\n         */\n        defaults(...sources: any[]): LoDashExplicitWrapper<any>;\n    }\n\n    //_.defaultsDeep\n    interface LoDashStatic {\n        /**\n         * This method is like _.defaults except that it recursively assigns default properties.\n         * @param object The destination object.\n         * @param sources The source objects.\n         * @return Returns object.\n         **/\n        defaultsDeep(\n            object: any,\n            ...sources: any[]): any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.defaultsDeep\n         **/\n        defaultsDeep(...sources: any[]): LoDashImplicitWrapper<any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.defaultsDeep\n         **/\n        defaultsDeep(...sources: any[]): LoDashExplicitWrapper<any>;\n    }\n\n    //_.entries\n    interface LoDashStatic {\n        /**\n         * @see _.toPairs\n         */\n        entries<T>(object?: Dictionary<T>): Array<[string, T]>;\n\n        /**\n         * @see _.toPairs\n         */\n        entries(object?: object): Array<[string, any]>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.toPairs\n         */\n        entries<T>(this: LoDashImplicitWrapper<Dictionary<T>>): LoDashImplicitWrapper<Array<[string, T]>>;\n\n        /**\n         * @see _.toPairs\n         */\n        entries(): LoDashImplicitWrapper<Array<[string, any]>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.toPairs\n         */\n        entries<T>(this: LoDashExplicitWrapper<Dictionary<T>>): LoDashExplicitWrapper<Array<[string, T]>>;\n\n        /**\n         * @see _.toPairs\n         */\n        entries(): LoDashExplicitWrapper<Array<[string, any]>>;\n    }\n\n    //_.entriesIn\n    interface LoDashStatic {\n        /**\n         * @see _.toPairsIn\n         */\n        entriesIn<T>(object?: Dictionary<T>): Array<[string, T]>;\n\n        /**\n         * @see _.toPairsIn\n         */\n        entriesIn(object?: object): Array<[string, any]>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.toPairsIn\n         */\n        entriesIn<T>(this: LoDashImplicitWrapper<Dictionary<T>>): LoDashImplicitWrapper<Array<[string, T]>>;\n\n        /**\n         * @see _.toPairsIn\n         */\n        entriesIn(): LoDashImplicitWrapper<Array<[string, any]>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.toPairsIn\n         */\n        entriesIn<T>(this: LoDashExplicitWrapper<Dictionary<T>>): LoDashExplicitWrapper<Array<[string, T]>>;\n\n        /**\n         * @see _.toPairsIn\n         */\n        entriesIn(): LoDashExplicitWrapper<Array<[string, any]>>;\n    }\n\n    // _.extend\n    interface LoDashStatic {\n        /**\n         * @see _.assignIn\n         */\n        extend<TObject, TSource>(\n            object: TObject,\n            source: TSource\n        ): TObject & TSource;\n\n        /**\n         * @see _.assignIn\n         */\n        extend<TObject, TSource1, TSource2>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2\n        ): TObject & TSource1 & TSource2;\n\n        /**\n         * @see _.assignIn\n         */\n        extend<TObject, TSource1, TSource2, TSource3>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3\n        ): TObject & TSource1 & TSource2 & TSource3;\n\n        /**\n         * @see _.assignIn\n         */\n        extend<TObject, TSource1, TSource2, TSource3, TSource4>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4\n        ): TObject & TSource1 & TSource2 & TSource3 & TSource4;\n\n        /**\n         * @see _.assignIn\n         */\n        extend<TObject>(object: TObject): TObject;\n\n        /**\n         * @see _.assignIn\n         */\n        extend<TResult>(\n            object: any,\n            ...otherArgs: any[]\n        ): TResult;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.assignIn\n         */\n        extend<TSource>(\n            source: TSource\n        ): LoDashImplicitWrapper<TValue & TSource>;\n\n        /**\n         * @see _.assignIn\n         */\n        extend<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2>;\n\n        /**\n         * @see _.assignIn\n         */\n        extend<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2 & TSource3>;\n\n        /**\n         * @see _.assignIn\n         */\n        extend<TSource1, TSource2, TSource3, TSource4>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2 & TSource3 & TSource4>;\n\n        /**\n         * @see _.assignIn\n         */\n        extend(): LoDashImplicitWrapper<TValue>;\n\n        /**\n         * @see _.assignIn\n         */\n        extend(...otherArgs: any[]): LoDashImplicitWrapper<any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.assignIn\n         */\n        extend<TSource>(\n            source: TSource\n        ): LoDashExplicitWrapper<TValue & TSource>;\n\n        /**\n         * @see _.assignIn\n         */\n        extend<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2>;\n\n        /**\n         * @see _.assignIn\n         */\n        extend<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2 & TSource3>;\n\n        /**\n         * @see _.assignIn\n         */\n        extend<TSource1, TSource2, TSource3, TSource4>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2 & TSource3 & TSource4>;\n\n        /**\n         * @see _.assignIn\n         */\n        extend(): LoDashExplicitWrapper<TValue>;\n\n        /**\n         * @see _.assignIn\n         */\n        extend(...otherArgs: any[]): LoDashExplicitWrapper<any>;\n    }\n\n    interface LoDashStatic {\n        /**\n         * @see _.assignInWith\n         */\n        extendWith<TObject, TSource>(\n            object: TObject,\n            source: TSource,\n            customizer: AssignCustomizer\n        ): TObject & TSource;\n\n        /**\n         * @see _.assignInWith\n         */\n        extendWith<TObject, TSource1, TSource2>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            customizer: AssignCustomizer\n        ): TObject & TSource1 & TSource2;\n\n        /**\n         * @see _.assignInWith\n         */\n        extendWith<TObject, TSource1, TSource2, TSource3>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            customizer: AssignCustomizer\n        ): TObject & TSource1 & TSource2 & TSource3;\n\n        /**\n         * @see _.assignInWith\n         */\n        extendWith<TObject, TSource1, TSource2, TSource3, TSource4>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4,\n            customizer: AssignCustomizer\n        ): TObject & TSource1 & TSource2 & TSource3 & TSource4;\n\n        /**\n         * @see _.assignInWith\n         */\n        extendWith<TObject>(object: TObject): TObject;\n\n        /**\n         * @see _.assignInWith\n         */\n        extendWith<TResult>(\n            object: any,\n            ...otherArgs: any[]\n        ): TResult;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.assignInWith\n         */\n        extendWith<TSource>(\n            source: TSource,\n            customizer: AssignCustomizer\n        ): LoDashImplicitWrapper<TValue & TSource>;\n\n        /**\n         * @see _.assignInWith\n         */\n        extendWith<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2,\n            customizer: AssignCustomizer\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2>;\n\n        /**\n         * @see _.assignInWith\n         */\n        extendWith<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            customizer: AssignCustomizer\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2 & TSource3>;\n\n        /**\n         * @see _.assignInWith\n         */\n        extendWith<TSource1, TSource2, TSource3, TSource4>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4,\n            customizer: AssignCustomizer\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2 & TSource3 & TSource4>;\n\n        /**\n         * @see _.assignInWith\n         */\n        extendWith(): LoDashImplicitWrapper<TValue>;\n\n        /**\n         * @see _.assignInWith\n         */\n        extendWith(...otherArgs: any[]): LoDashImplicitWrapper<any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.assignInWith\n         */\n        extendWith<TSource>(\n            source: TSource,\n            customizer: AssignCustomizer\n        ): LoDashExplicitWrapper<TValue & TSource>;\n\n        /**\n         * @see _.assignInWith\n         */\n        extendWith<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2,\n            customizer: AssignCustomizer\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2>;\n\n        /**\n         * @see _.assignInWith\n         */\n        extendWith<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            customizer: AssignCustomizer\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2 & TSource3>;\n\n        /**\n         * @see _.assignInWith\n         */\n        extendWith<TSource1, TSource2, TSource3, TSource4>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4,\n            customizer: AssignCustomizer\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2 & TSource3 & TSource4>;\n\n        /**\n         * @see _.assignInWith\n         */\n        extendWith(): LoDashExplicitWrapper<TValue>;\n\n        /**\n         * @see _.assignInWith\n         */\n        extendWith(...otherArgs: any[]): LoDashExplicitWrapper<any>;\n    }\n\n    //_.findKey\n    interface LoDashStatic {\n        /**\n         * This method is like _.find except that it returns the key of the first element predicate returns truthy for\n         * instead of the element itself.\n         *\n         * If a property name is provided for predicate the created _.property style callback returns the property\n         * value of the given element.\n         *\n         * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for\n         * elements that have a matching property value, else false.\n         *\n         * If an object is provided for predicate the created _.matches style callback returns true for elements that\n         * have the properties of the given object, else false.\n         *\n         * @param object The object to search.\n         * @param predicate The function invoked per iteration.\n         * @param thisArg The this binding of predicate.\n         * @return Returns the key of the matched element, else undefined.\n         */\n        findKey<T>(\n            object: T | null | undefined,\n            predicate?: ObjectIteratee<T>\n        ): string | undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.findKey\n         */\n        findKey<T>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            predicate?: ObjectIteratee<T>\n        ): string | undefined;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.findKey\n         */\n        findKey<T>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            predicate?: ObjectIteratee<T>\n        ): LoDashExplicitWrapper<string | undefined>;\n    }\n\n    //_.findLastKey\n    interface LoDashStatic {\n        /**\n         * This method is like _.findKey except that it iterates over elements of a collection in the opposite order.\n         *\n         * If a property name is provided for predicate the created _.property style callback returns the property\n         * value of the given element.\n         *\n         * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for\n         * elements that have a matching property value, else false.\n         *\n         * If an object is provided for predicate the created _.matches style callback returns true for elements that\n         * have the properties of the given object, else false.\n         *\n         * @param object The object to search.\n         * @param predicate The function invoked per iteration.\n         * @param thisArg The this binding of predicate.\n         * @return Returns the key of the matched element, else undefined.\n         */\n        findLastKey<T>(\n            object: T | null | undefined,\n            predicate?: ObjectIteratee<T>\n        ): string | undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.findLastKey\n         */\n        findLastKey<T>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            predicate?: ObjectIteratee<T>\n        ): string | undefined;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.findLastKey\n         */\n        findLastKey<T>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            predicate?: ObjectIteratee<T>\n        ): LoDashExplicitWrapper<string | undefined>;\n    }\n\n    //_.forIn\n    interface LoDashStatic {\n        /**\n         * Iterates over own and inherited enumerable properties of an object invoking iteratee for each property. The\n         * iteratee is bound to thisArg and invoked with three arguments: (value, key, object). Iteratee functions may\n         * exit iteration early by explicitly returning false.\n         *\n         * @param object The object to iterate over.\n         * @param iteratee The function invoked per iteration.\n         * @param thisArg The this binding of iteratee.\n         * @return Returns object.\n         */\n        forIn<T>(\n            object: T,\n            iteratee?: ObjectIterator<T, any>\n        ): T;\n\n        /**\n         * @see _.forIn\n         */\n        forIn<T>(\n            object: T | null | undefined,\n            iteratee?: ObjectIterator<T, any>\n        ): T | null | undefined;\n    }\n\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.forIn\n         */\n        forIn<T>(\n            this: LoDashWrapper<T | null | undefined>,\n            iteratee?: ObjectIterator<T, any>\n        ): this;\n    }\n\n    //_.forInRight\n    interface LoDashStatic {\n        /**\n         * This method is like _.forIn except that it iterates over properties of object in the opposite order.\n         *\n         * @param object The object to iterate over.\n         * @param iteratee The function invoked per iteration.\n         * @param thisArg The this binding of iteratee.\n         * @return Returns object.\n         */\n        forInRight<T>(\n            object: T,\n            iteratee?: ObjectIterator<T, any>\n        ): T;\n\n        /**\n         * @see _.forInRight\n         */\n        forInRight<T>(\n            object: T | null | undefined,\n            iteratee?: ObjectIterator<T, any>\n        ): T | null | undefined;\n    }\n\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.forInRight\n         */\n        forInRight<T>(\n            this: LoDashWrapper<T | null | undefined>,\n            iteratee?: ObjectIterator<T, any>\n        ): this;\n    }\n\n    //_.forOwn\n    interface LoDashStatic {\n        /**\n         * Iterates over own enumerable properties of an object invoking iteratee for each property. The iteratee is\n         * bound to thisArg and invoked with three arguments: (value, key, object). Iteratee functions may exit\n         * iteration early by explicitly returning false.\n         *\n         * @param object The object to iterate over.\n         * @param iteratee The function invoked per iteration.\n         * @param thisArg The this binding of iteratee.\n         * @return Returns object.\n         */\n        forOwn<T>(\n            object: T,\n            iteratee?: ObjectIterator<T, any>\n        ): T;\n\n        /**\n         * @see _.forOwn\n         */\n        forOwn<T>(\n            object: T | null | undefined,\n            iteratee?: ObjectIterator<T, any>\n        ): T | null | undefined;\n    }\n\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.forOwn\n         */\n        forOwn<T>(\n            this: LoDashWrapper<T | null | undefined>,\n            iteratee?: ObjectIterator<T, any>\n        ): this;\n    }\n\n    //_.forOwnRight\n    interface LoDashStatic {\n        /**\n         * This method is like _.forOwn except that it iterates over properties of object in the opposite order.\n         *\n         * @param object The object to iterate over.\n         * @param iteratee The function invoked per iteration.\n         * @param thisArg The this binding of iteratee.\n         * @return Returns object.\n         */\n        forOwnRight<T>(\n            object: T,\n            iteratee?: ObjectIterator<T, any>\n        ): T;\n\n        /**\n         * @see _.forOwnRight\n         */\n        forOwnRight<T>(\n            object: T | null | undefined,\n            iteratee?: ObjectIterator<T, any>\n        ): T | null | undefined;\n    }\n\n    interface LoDashWrapper<TValue> {\n        /**\n         * @see _.forOwnRight\n         */\n        forOwnRight<T>(\n            this: LoDashWrapper<T | null | undefined>,\n            iteratee?: ObjectIterator<T, any>\n        ): this;\n    }\n\n    //_.functions\n    interface LoDashStatic {\n        /**\n         * Creates an array of function property names from own enumerable properties\n         * of `object`.\n         *\n         * @category Object\n         * @param object The object to inspect.\n         * @returns Returns the new array of property names.\n         * @example\n         *\n         * function Foo() {\n         *   this.a = _.constant('a');\n         *   this.b = _.constant('b');\n         * }\n         *\n         * Foo.prototype.c = _.constant('c');\n         *\n         * _.functions(new Foo);\n         * // => ['a', 'b']\n         */\n        functions(object: any): string[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.functions\n         */\n        functions(): LoDashImplicitWrapper<string[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.functions\n         */\n        functions(): LoDashExplicitWrapper<string[]>;\n    }\n\n    //_.functionsIn\n    interface LoDashStatic {\n        /**\n         * Creates an array of function property names from own and inherited\n         * enumerable properties of `object`.\n         *\n         * @category Object\n         * @param object The object to inspect.\n         * @returns Returns the new array of property names.\n         * @example\n         *\n         * function Foo() {\n         *   this.a = _.constant('a');\n         *   this.b = _.constant('b');\n         * }\n         *\n         * Foo.prototype.c = _.constant('c');\n         *\n         * _.functionsIn(new Foo);\n         * // => ['a', 'b', 'c']\n         */\n        functionsIn<T extends {}>(object: any): string[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.functionsIn\n         */\n        functionsIn(): LoDashImplicitWrapper<string[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.functionsIn\n         */\n        functionsIn(): LoDashExplicitWrapper<string[]>;\n    }\n\n    //_.get\n    interface LoDashStatic {\n        /**\n         * Gets the property value at path of object. If the resolved value is undefined the defaultValue is used\n         * in its place.\n         *\n         * @param object The object to query.\n         * @param path The path of the property to get.\n         * @param defaultValue The value returned if the resolved value is undefined.\n         * @return Returns the resolved value.\n         */\n        get<TObject extends object, TKey extends keyof TObject>(\n            object: TObject,\n            path: TKey | [TKey]\n        ): TObject[TKey];\n\n        /**\n         * @see _.get\n         */\n        get<TObject extends object, TKey extends keyof TObject>(\n            object: TObject | null | undefined,\n            path: TKey | [TKey]\n        ): TObject[TKey] | undefined;\n\n        /**\n         * @see _.get\n         */\n        get<TObject extends object, TKey extends keyof TObject, TDefault>(\n            object: TObject | null | undefined,\n            path: TKey | [TKey],\n            defaultValue: TDefault\n        ): TObject[TKey] | TDefault;\n\n        /**\n         * @see _.get\n         */\n        get<TDefault>(\n            object: null | undefined,\n            path: PropertyPath,\n            defaultValue: TDefault\n        ): TDefault;\n\n        /**\n         * @see _.get\n         */\n        get(\n            object: null | undefined,\n            path: PropertyPath\n        ): undefined;\n\n        /**\n         * @see _.get\n         */\n        get(\n            object: any,\n            path: PropertyPath,\n            defaultValue?: any\n        ): any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.get\n         */\n        get<TKey extends keyof TValue>(\n            path: TKey | [TKey]\n        ): TValue[TKey];\n\n        /**\n         * @see _.get\n         */\n        get<TObject extends object, TKey extends keyof TObject>(\n            this: LoDashImplicitWrapper<TObject | null | undefined>,\n            path: TKey | [TKey],\n        ): TObject[TKey] | undefined;\n\n        /**\n         * @see _.get\n         */\n        get<TObject extends object, TKey extends keyof TObject, TDefault>(\n            this: LoDashImplicitWrapper<TObject | null | undefined>,\n            path: TKey | [TKey],\n            defaultValue: TDefault\n        ): TObject[TKey] | TDefault;\n\n        /**\n         * @see _.get\n         */\n        get<TDefault>(\n            this: LoDashImplicitWrapper<null | undefined>,\n            path: PropertyPath,\n            defaultValue: TDefault\n        ): TDefault;\n\n        /**\n         * @see _.get\n         */\n        get(\n            this: LoDashImplicitWrapper<null | undefined>,\n            path: PropertyPath\n        ): undefined;\n\n        /**\n         * @see _.get\n         */\n        get<TResult>(\n            path: PropertyPath,\n            defaultValue?: any\n        ): any;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.get\n         */\n        get<TKey extends keyof TValue>(\n            path: TKey | [TKey]\n        ): LoDashExplicitWrapper<TValue[TKey]>;\n\n        /**\n         * @see _.get\n         */\n        get<TObject extends object, TKey extends keyof TObject>(\n            this: LoDashExplicitWrapper<TObject | null | undefined>,\n            path: TKey | [TKey],\n        ): LoDashExplicitWrapper<TObject[TKey] | undefined>;\n\n        /**\n         * @see _.get\n         */\n        get<TObject extends object, TKey extends keyof TObject, TDefault>(\n            this: LoDashExplicitWrapper<TObject | null | undefined>,\n            path: TKey | [TKey],\n            defaultValue: TDefault\n        ): LoDashExplicitWrapper<TObject[TKey] | TDefault>;\n\n        /**\n         * @see _.get\n         */\n        get<TDefault>(\n            this: LoDashExplicitWrapper<null | undefined>,\n            path: PropertyPath,\n            defaultValue: TDefault\n        ): LoDashExplicitWrapper<TDefault>;\n\n        /**\n         * @see _.get\n         */\n        get(\n            this: LoDashExplicitWrapper<null | undefined>,\n            path: PropertyPath\n        ): LoDashExplicitWrapper<undefined>;\n\n        /**\n         * @see _.get\n         */\n        get(\n            path: PropertyPath,\n            defaultValue?: any\n        ): LoDashExplicitWrapper<any>;\n    }\n\n    //_.has\n    interface LoDashStatic {\n        /**\n         * Checks if `path` is a direct property of `object`.\n         *\n         * @category Object\n         * @param object The object to query.\n         * @param path The path to check.\n         * @returns Returns `true` if `path` exists, else `false`.\n         * @example\n         *\n         * var object = { 'a': { 'b': { 'c': 3 } } };\n         * var other = _.create({ 'a': _.create({ 'b': _.create({ 'c': 3 }) }) });\n         *\n         * _.has(object, 'a');\n         * // => true\n         *\n         * _.has(object, 'a.b.c');\n         * // => true\n         *\n         * _.has(object, ['a', 'b', 'c']);\n         * // => true\n         *\n         * _.has(other, 'a');\n         * // => false\n         */\n        has<T>(\n            object: T,\n            path: PropertyPath\n        ): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.has\n         */\n        has(path: PropertyPath): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.has\n         */\n        has(path: PropertyPath): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.hasIn\n    interface LoDashStatic {\n        /**\n         * Checks if `path` is a direct or inherited property of `object`.\n         *\n         * @category Object\n         * @param object The object to query.\n         * @param path The path to check.\n         * @returns Returns `true` if `path` exists, else `false`.\n         * @example\n         *\n         * var object = _.create({ 'a': _.create({ 'b': _.create({ 'c': 3 }) }) });\n         *\n         * _.hasIn(object, 'a');\n         * // => true\n         *\n         * _.hasIn(object, 'a.b.c');\n         * // => true\n         *\n         * _.hasIn(object, ['a', 'b', 'c']);\n         * // => true\n         *\n         * _.hasIn(object, 'b');\n         * // => false\n         */\n        hasIn<T>(\n            object: T,\n            path: PropertyPath\n        ): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.hasIn\n         */\n        hasIn(path: PropertyPath): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.hasIn\n         */\n        hasIn(path: PropertyPath): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.invert\n    interface LoDashStatic {\n        /**\n         * Creates an object composed of the inverted keys and values of object. If object contains duplicate values,\n         * subsequent values overwrite property assignments of previous values unless multiValue is true.\n         *\n         * @param object The object to invert.\n         * @param multiValue Allow multiple values per key.\n         * @return Returns the new inverted object.\n         */\n        invert(\n            object: object\n        ): Dictionary<string>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.invert\n         */\n        invert(): LoDashImplicitWrapper<Dictionary<string>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.invert\n         */\n        invert(): LoDashExplicitWrapper<Dictionary<string>>;\n    }\n\n    //_.invertBy\n    interface LoDashStatic {\n        /**\n         * This method is like _.invert except that the inverted object is generated from the results of running each\n         * element of object through iteratee. The corresponding inverted value of each inverted key is an array of\n         * keys responsible for generating the inverted value. The iteratee is invoked with one argument: (value).\n         *\n         * @param object The object to invert.\n         * @param interatee The iteratee invoked per element.\n         * @return Returns the new inverted object.\n         */\n        invertBy<T>(\n            object: List<T> | Dictionary<T> | NumericDictionary<T> | null | undefined,\n            interatee?: ValueIteratee<T>\n        ): Dictionary<string[]>;\n\n        /**\n         * @see _.invertBy\n         */\n        invertBy<T extends object>(\n            object: T | null | undefined,\n            interatee?: ValueIteratee<T[keyof T]>\n        ): Dictionary<string[]>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.invertBy\n         */\n        invertBy<T>(\n            this: LoDashImplicitWrapper<List<T> | Dictionary<T> | NumericDictionary<T> | null | undefined>,\n            interatee?: ValueIteratee<T>\n        ): LoDashImplicitWrapper<Dictionary<string[]>>;\n\n        /**\n         * @see _.invertBy\n         */\n        invertBy<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            interatee?: ValueIteratee<T[keyof T]>\n        ): LoDashImplicitWrapper<Dictionary<string[]>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.invertBy\n         */\n        invertBy<T>(\n            this: LoDashExplicitWrapper<List<T> | Dictionary<T> | NumericDictionary<T> | null | undefined>,\n            interatee?: ValueIteratee<T>\n        ): LoDashExplicitWrapper<Dictionary<string[]>>;\n\n        /**\n         * @see _.invertBy\n         */\n        invertBy<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            interatee?: ValueIteratee<T[keyof T]>\n        ): LoDashExplicitWrapper<Dictionary<string[]>>;\n    }\n\n    //_.keys\n    interface LoDashStatic {\n        /**\n         * Creates an array of the own enumerable property names of object.\n         *\n         * Note: Non-object values are coerced to objects. See the ES spec for more details.\n         *\n         * @param object The object to query.\n         * @return Returns the array of property names.\n         */\n        keys(object?: any): string[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.keys\n         */\n        keys(): LoDashImplicitWrapper<string[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.keys\n         */\n        keys(): LoDashExplicitWrapper<string[]>;\n    }\n\n    //_.keysIn\n    interface LoDashStatic {\n        /**\n         * Creates an array of the own and inherited enumerable property names of object.\n         *\n         * Note: Non-object values are coerced to objects.\n         *\n         * @param object The object to query.\n         * @return An array of property names.\n         */\n        keysIn(object?: any): string[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.keysIn\n         */\n        keysIn(): LoDashImplicitWrapper<string[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.keysIn\n         */\n        keysIn(): LoDashExplicitWrapper<string[]>;\n    }\n\n    //_.mapKeys\n    interface LoDashStatic {\n        /**\n         * The opposite of _.mapValues; this method creates an object with the same values as object and keys generated\n         * by running each own enumerable property of object through iteratee.\n         *\n         * @param object The object to iterate over.\n         * @param iteratee The function invoked per iteration.\n         * @param thisArg The this binding of iteratee.\n         * @return Returns the new mapped object.\n         */\n        mapKeys<T>(\n            object: List<T> | null | undefined,\n            iteratee?: ListIteratee<T>\n        ): Dictionary<T>;\n\n        /**\n         * @see _.mapKeys\n         */\n        mapKeys<T>(\n            object: Dictionary<T> | null | undefined,\n            iteratee?: DictionaryIteratee<T>\n        ): Dictionary<T>;\n\n        /**\n         * @see _.mapKeys\n         */\n        mapKeys(\n            object: object | null | undefined,\n            iteratee?: ObjectIteratee<any>\n        ): Dictionary<any>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.mapKeys\n         */\n        mapKeys<T>(\n            this: LoDashImplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ListIteratee<T>\n        ): LoDashImplicitWrapper<Dictionary<T>>;\n\n        /**\n         * @see _.mapKeys\n         */\n        mapKeys<T>(\n            this: LoDashImplicitWrapper<Dictionary<T> | null | undefined>,\n            iteratee?: DictionaryIteratee<T>\n        ): LoDashImplicitWrapper<Dictionary<T>>;\n\n        /**\n         * @see _.mapKeys\n         */\n        mapKeys(\n            this: LoDashImplicitWrapper<object | null | undefined>,\n            iteratee?: ObjectIteratee<any>\n        ): LoDashImplicitWrapper<Dictionary<any>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.mapKeys\n         */\n        mapKeys<T>(\n            this: LoDashExplicitWrapper<List<T> | null | undefined>,\n            iteratee?: ListIteratee<T>\n        ): LoDashExplicitWrapper<Dictionary<T>>;\n\n        /**\n         * @see _.mapKeys\n         */\n        mapKeys<T>(\n            this: LoDashExplicitWrapper<Dictionary<T> | null | undefined>,\n            iteratee?: DictionaryIteratee<T>\n        ): LoDashExplicitWrapper<Dictionary<T>>;\n\n        /**\n         * @see _.mapKeys\n         */\n        mapKeys(\n            this: LoDashExplicitWrapper<object | null | undefined>,\n            iteratee?: ObjectIteratee<any>\n        ): LoDashExplicitWrapper<Dictionary<any>>;\n    }\n\n    //_.mapValues\n    interface LoDashStatic {\n        /**\n        * Creates an object with the same keys as object and values generated by running each own\n        * enumerable property of object through iteratee. The iteratee function is bound to thisArg\n        * and invoked with three arguments: (value, key, object).\n        *\n        * If a property name is provided iteratee the created \"_.property\" style callback returns\n        * the property value of the given element.\n        *\n        * If a value is also provided for thisArg the creted \"_.matchesProperty\" style callback returns\n        * true for elements that have a matching property value, else false;.\n        *\n        * If an object is provided for iteratee the created \"_.matches\" style callback returns true\n        * for elements that have the properties of the given object, else false.\n        *\n        * @param object The object to iterate over.\n        * @param [iteratee=_.identity]  The function invoked per iteration.\n        * @param [thisArg] The `this` binding of `iteratee`.\n        * @return Returns the new mapped object.\n        */\n        mapValues<T extends object, TResult>(obj: T | null | undefined, callback: ObjectIterator<T, TResult>): { [P in keyof T]: TResult };\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T extends object>(obj: T | null | undefined, iteratee: object): { [P in keyof T]: boolean };\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T, TKey extends keyof T>(obj: Dictionary<T> | null | undefined, iteratee: TKey): Dictionary<T[TKey]>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T extends object, TKey extends keyof T>(obj: T | null | undefined, iteratee: string): { [P in keyof T]: any };\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<TResult>(obj: string | null | undefined, callback: StringIterator<TResult>): NumericDictionary<TResult>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T>(obj: Dictionary<T> | null | undefined): Dictionary<T>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T extends object>(obj: T): T;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T extends object>(obj: T | null | undefined): T | {};\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues(obj: string | null | undefined): NumericDictionary<string>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T extends object, TResult>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            callback: ObjectIterator<T, TResult>\n        ): LoDashImplicitWrapper<{ [P in keyof T]: TResult }>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            iteratee: object\n        ): LoDashImplicitWrapper<{ [P in keyof T]: boolean }>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T, TKey extends keyof T>(\n            this: LoDashImplicitWrapper<Dictionary<T> | null | undefined>,\n            iteratee: TKey\n        ): LoDashImplicitWrapper<Dictionary<T[TKey]>>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T extends object, TKey extends keyof T>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            iteratee: string\n        ): LoDashImplicitWrapper<{ [P in keyof T]: any }>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<TResult>(\n            this: LoDashImplicitWrapper<string | null | undefined>,\n            callback: StringIterator<TResult>\n        ): LoDashImplicitWrapper<NumericDictionary<TResult>>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T>(this: LoDashImplicitWrapper<Dictionary<T> | null | undefined>): LoDashImplicitWrapper<Dictionary<T>>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T extends object>(this: LoDashImplicitWrapper<T>): LoDashImplicitWrapper<T>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T extends object>(this: LoDashImplicitWrapper<T | null | undefined>): LoDashImplicitWrapper<T | {}>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues(this: LoDashImplicitWrapper<string | null | undefined>): LoDashImplicitWrapper<NumericDictionary<string>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T extends object, TResult>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            callback: ObjectIterator<T, TResult>\n        ): LoDashExplicitWrapper<{ [P in keyof T]: TResult }>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            iteratee: object\n        ): LoDashExplicitWrapper<{ [P in keyof T]: boolean }>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T, TKey extends keyof T>(\n            this: LoDashExplicitWrapper<Dictionary<T> | null | undefined>,\n            iteratee: TKey\n        ): LoDashExplicitWrapper<Dictionary<T[TKey]>>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T extends object, TKey extends keyof T>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            iteratee: string\n        ): LoDashExplicitWrapper<{ [P in keyof T]: any }>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<TResult>(\n            this: LoDashExplicitWrapper<string | null | undefined>,\n            callback: StringIterator<TResult>\n        ): LoDashExplicitWrapper<NumericDictionary<TResult>>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T>(this: LoDashExplicitWrapper<Dictionary<T> | null | undefined>): LoDashExplicitWrapper<Dictionary<T>>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T extends object>(this: LoDashExplicitWrapper<T>): LoDashExplicitWrapper<T>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T extends object>(this: LoDashExplicitWrapper<T | null | undefined>): LoDashExplicitWrapper<T | {}>;\n\n        /**\n         * @see _.mapValues\n         */\n        mapValues(this: LoDashExplicitWrapper<string | null | undefined>): LoDashExplicitWrapper<NumericDictionary<string>>;\n    }\n\n    //_.merge\n    interface LoDashStatic {\n        /**\n         * Recursively merges own and inherited enumerable properties of source\n         * objects into the destination object, skipping source properties that resolve\n         * to `undefined`. Array and plain object properties are merged recursively.\n         * Other objects and value types are overridden by assignment. Source objects\n         * are applied from left to right. Subsequent sources overwrite property\n         * assignments of previous sources.\n         *\n         * **Note:** This method mutates `object`.\n         *\n         * @category Object\n         * @param object The destination object.\n         * @param [sources] The source objects.\n         * @returns Returns `object`.\n         * @example\n         *\n         * var users = {\n         *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]\n         * };\n         *\n         * var ages = {\n         *   'data': [{ 'age': 36 }, { 'age': 40 }]\n         * };\n         *\n         * _.merge(users, ages);\n         * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }\n         */\n        merge<TObject, TSource>(\n            object: TObject,\n            source: TSource\n        ): TObject & TSource;\n\n        /**\n         * @see _.merge\n         */\n        merge<TObject, TSource1, TSource2>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2\n        ): TObject & TSource1 & TSource2;\n\n        /**\n         * @see _.merge\n         */\n        merge<TObject, TSource1, TSource2, TSource3>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3\n        ): TObject & TSource1 & TSource2 & TSource3;\n\n        /**\n         * @see _.merge\n         */\n        merge<TObject, TSource1, TSource2, TSource3, TSource4>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4\n        ): TObject & TSource1 & TSource2 & TSource3 & TSource4;\n\n        /**\n         * @see _.merge\n         */\n        merge(\n            object: any,\n            ...otherArgs: any[]\n        ): any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.merge\n         */\n        merge<TSource>(\n            source: TSource\n        ): LoDashImplicitWrapper<TValue & TSource>;\n\n        /**\n         * @see _.merge\n         */\n        merge<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2>;\n\n        /**\n         * @see _.merge\n         */\n        merge<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2 & TSource3>;\n\n        /**\n         * @see _.merge\n         */\n        merge<TSource1, TSource2, TSource3, TSource4>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2 & TSource3 & TSource4>;\n\n        /**\n         * @see _.merge\n         */\n        merge(\n            ...otherArgs: any[]\n        ): LoDashImplicitWrapper<any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.merge\n         */\n        merge<TSource>(\n            source: TSource\n        ): LoDashExplicitWrapper<TValue & TSource>;\n\n        /**\n         * @see _.merge\n         */\n        merge<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2>;\n\n        /**\n         * @see _.merge\n         */\n        merge<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2 & TSource3>;\n\n        /**\n         * @see _.merge\n         */\n        merge<TSource1, TSource2, TSource3, TSource4>(\n        ): LoDashExplicitWrapper<TValue & TSource1 & TSource2 & TSource3 & TSource4>;\n\n        /**\n         * @see _.merge\n         */\n        merge(\n            ...otherArgs: any[]\n        ): LoDashExplicitWrapper<any>;\n    }\n\n    //_.mergeWith\n    type MergeWithCustomizer = { bivariantHack(value: any, srcValue: any, key: string, object: any, source: any): any; }[\"bivariantHack\"]\n\n    interface LoDashStatic {\n        /**\n         * This method is like `_.merge` except that it accepts `customizer` which\n         * is invoked to produce the merged values of the destination and source\n         * properties. If `customizer` returns `undefined` merging is handled by the\n         * method instead. The `customizer` is invoked with seven arguments:\n         * (objValue, srcValue, key, object, source, stack).\n         *\n         * @category Object\n         * @param object The destination object.\n         * @param sources The source objects.\n         * @param customizer The function to customize assigned values.\n         * @returns Returns `object`.\n         * @example\n         *\n         * function customizer(objValue, srcValue) {\n         *   if (_.isArray(objValue)) {\n         *     return objValue.concat(srcValue);\n         *   }\n         * }\n         *\n         * var object = {\n         *   'fruits': ['apple'],\n         *   'vegetables': ['beet']\n         * };\n         *\n         * var other = {\n         *   'fruits': ['banana'],\n         *   'vegetables': ['carrot']\n         * };\n         *\n         * _.merge(object, other, customizer);\n         * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }\n         */\n        mergeWith<TObject, TSource>(\n            object: TObject,\n            source: TSource,\n            customizer: MergeWithCustomizer\n        ): TObject & TSource;\n\n        /**\n         * @see _.mergeWith\n         */\n        mergeWith<TObject, TSource1, TSource2>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            customizer: MergeWithCustomizer\n        ): TObject & TSource1 & TSource2;\n\n        /**\n         * @see _.mergeWith\n         */\n        mergeWith<TObject, TSource1, TSource2, TSource3>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            customizer: MergeWithCustomizer\n        ): TObject & TSource1 & TSource2 & TSource3;\n\n        /**\n         * @see _.mergeWith\n         */\n        mergeWith<TObject, TSource1, TSource2, TSource3, TSource4>(\n            object: TObject,\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4,\n            customizer: MergeWithCustomizer\n        ): TObject & TSource1 & TSource2 & TSource3 & TSource4;\n\n        /**\n         * @see _.mergeWith\n         */\n        mergeWith(\n            object: any,\n            ...otherArgs: any[]\n        ): any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.mergeWith\n         */\n        mergeWith<TSource>(\n            source: TSource,\n            customizer: MergeWithCustomizer\n        ): LoDashImplicitWrapper<TValue & TSource>;\n\n        /**\n         * @see _.mergeWith\n         */\n        mergeWith<TSource1, TSource2>(\n            source1: TSource1,\n            source2: TSource2,\n            customizer: MergeWithCustomizer\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2>;\n\n        /**\n         * @see _.mergeWith\n         */\n        mergeWith<TSource1, TSource2, TSource3>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            customizer: MergeWithCustomizer\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2 & TSource3>;\n\n        /**\n         * @see _.mergeWith\n         */\n        mergeWith<TSource1, TSource2, TSource3, TSource4>(\n            source1: TSource1,\n            source2: TSource2,\n            source3: TSource3,\n            source4: TSource4,\n            customizer: MergeWithCustomizer\n        ): LoDashImplicitWrapper<TValue & TSource1 & TSource2 & TSource3 & TSource4>;\n\n        /**\n         * @see _.mergeWith\n         */\n        mergeWith(\n            ...otherArgs: any[]\n        ): LoDashImplicitWrapper<any>;\n    }\n\n    //_.omit\n    interface LoDashStatic {\n        /**\n         * The opposite of `_.pick`; this method creates an object composed of the\n         * own and inherited enumerable properties of `object` that are not omitted.\n         *\n         * @category Object\n         * @param object The source object.\n         * @param [paths] The property names to omit, specified\n         *  individually or in arrays..\n         * @returns Returns the new object.\n         * @example\n         *\n         * var object = { 'a': 1, 'b': '2', 'c': 3 };\n         *\n         * _.omit(object, ['a', 'c']);\n         * // => { 'b': '2' }\n         */\n        omit<T>(\n            object: Dictionary<T>,\n            ...paths: PropertyPath[]\n        ): Dictionary<T>;\n\n        /**\n         * @see _.omit\n         */\n        omit<T extends object>(\n            object: T | null | undefined,\n            ...paths: PropertyPath[]\n        ): PartialObject<T>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.omit\n         */\n        omit<T>(\n            this: LoDashImplicitWrapper<Dictionary<T>>,\n            ...paths: PropertyPath[]\n        ): LoDashImplicitWrapper<Dictionary<T>>;\n\n        /**\n         * @see _.omit\n         */\n        omit<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            ...paths: PropertyPath[]\n        ): LoDashImplicitWrapper<PartialObject<T>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.omit\n         */\n        omit<T>(\n            this: LoDashExplicitWrapper<Dictionary<T>>,\n            ...paths: PropertyPath[]\n        ): LoDashExplicitWrapper<Dictionary<T>>;\n\n        /**\n         * @see _.omit\n         */\n        omit<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            ...paths: PropertyPath[]\n        ): LoDashExplicitWrapper<PartialObject<T>>;\n    }\n\n    //_.omitBy\n    interface LoDashStatic {\n        /**\n         * The opposite of `_.pickBy`; this method creates an object composed of the\n         * own and inherited enumerable properties of `object` that `predicate`\n         * doesn't return truthy for.\n         *\n         * @category Object\n         * @param object The source object.\n         * @param [predicate=_.identity] The function invoked per property.\n         * @returns Returns the new object.\n         * @example\n         *\n         * var object = { 'a': 1, 'b': '2', 'c': 3 };\n         *\n         * _.omitBy(object, _.isNumber);\n         * // => { 'b': '2' }\n         */\n        omitBy<T extends object>(\n            object: T | null | undefined,\n            predicate: ValueKeyIteratee<T[keyof T]>\n        ): PartialObject<T>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.omitBy\n         */\n        omitBy<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            predicate: ValueKeyIteratee<T[keyof T]>\n        ): LoDashImplicitWrapper<PartialObject<T>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.omitBy\n         */\n        omitBy<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            predicate: ValueKeyIteratee<T[keyof T]>\n        ): LoDashExplicitWrapper<PartialObject<T>>;\n    }\n\n    //_.pick\n    interface LoDashStatic {\n        /**\n         * Creates an object composed of the picked `object` properties.\n         *\n         * @category Object\n         * @param object The source object.\n         * @param [props] The property names to pick, specified\n         *  individually or in arrays.\n         * @returns Returns the new object.\n         * @example\n         *\n         * var object = { 'a': 1, 'b': '2', 'c': 3 };\n         *\n         * _.pick(object, ['a', 'c']);\n         * // => { 'a': 1, 'c': 3 }\n         */\n        pick<T extends object, U extends keyof T>(\n            object: T,\n             ...props: Array<Many<U>>\n        ): Pick<T, U>;\n\n        /**\n         * @see _.pick\n         */\n        pick<T>(\n            object: T | null | undefined,\n            ...props: PropertyPath[]\n        ): PartialDeep<T>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.pick\n         */\n        pick<T extends object, U extends keyof T>(\n            this: LoDashImplicitWrapper<T>,\n            ...props: Array<Many<U>>\n        ): LoDashImplicitWrapper<Pick<T, U>>;\n\n        /**\n         * @see _.pick\n         */\n        pick<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            ...props: PropertyPath[]\n        ): LoDashImplicitWrapper<PartialObject<T>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.pick\n         */\n        pick<T extends object, U extends keyof T>(\n            this: LoDashExplicitWrapper<T>,\n            ...props: Array<Many<U>>\n        ): LoDashExplicitWrapper<Pick<T, U>>;\n\n        /**\n         * @see _.pick\n         */\n        pick<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            ...props: PropertyPath[]\n        ): LoDashExplicitWrapper<PartialObject<T>>;\n    }\n\n    //_.pickBy\n    interface LoDashStatic {\n        /**\n         * Creates an object composed of the `object` properties `predicate` returns\n         * truthy for. The predicate is invoked with two arguments: (value, key).\n         *\n         * @category Object\n         * @param object The source object.\n         * @param [predicate=_.identity] The function invoked per property.\n         * @returns Returns the new object.\n         * @example\n         *\n         * var object = { 'a': 1, 'b': '2', 'c': 3 };\n         *\n         * _.pickBy(object, _.isNumber);\n         * // => { 'a': 1, 'c': 3 }\n         */\n        pickBy<T extends object>(\n            object: T | null | undefined,\n            predicate?: ValueKeyIteratee<T[keyof T]>\n        ): PartialObject<T>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.pickBy\n         */\n        pickBy<T extends object>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            predicate?: ValueKeyIteratee<T[keyof T]>\n        ): LoDashImplicitWrapper<PartialObject<T>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.pickBy\n         */\n        pickBy<T extends object>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            predicate?: ValueKeyIteratee<T[keyof T]>\n        ): LoDashExplicitWrapper<PartialObject<T>>;\n    }\n\n    //_.result\n    interface LoDashStatic {\n        /**\n         * This method is like _.get except that if the resolved value is a function itâs invoked with the this binding\n         * of its parent object and its result is returned.\n         *\n         * @param object The object to query.\n         * @param path The path of the property to resolve.\n         * @param defaultValue The value returned if the resolved value is undefined.\n         * @return Returns the resolved value.\n         */\n        result<TResult>(\n            object: any,\n            path: PropertyPath,\n            defaultValue?: TResult|((...args: any[]) => TResult)\n        ): TResult;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.result\n         */\n        result<TResult>(\n            path: PropertyPath,\n            defaultValue?: TResult|((...args: any[]) => TResult)\n        ): TResult;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.result\n         */\n        result<TResult>(\n            path: PropertyPath,\n            defaultValue?: TResult|((...args: any[]) => TResult)\n        ): LoDashExplicitWrapper<TResult>;\n    }\n\n    //_.set\n    interface LoDashStatic {\n        /**\n         * Sets the value at path of object. If a portion of path doesnât exist itâs created. Arrays are created for\n         * missing index properties while objects are created for all other missing properties. Use _.setWith to\n         * customize path creation.\n         *\n         * @param object The object to modify.\n         * @param path The path of the property to set.\n         * @param value The value to set.\n         * @return Returns object.\n         */\n        set<T extends object>(\n            object: T,\n            path: PropertyPath,\n            value: any\n        ): T;\n\n        /**\n         * @see _.set\n         */\n        set<TResult>(\n            object: object,\n            path: PropertyPath,\n            value: any\n        ): TResult;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.set\n         */\n        set(\n            path: PropertyPath,\n            value: any\n        ): this;\n\n        /**\n         * @see _.set\n         */\n        set<TResult>(\n            path: PropertyPath,\n            value: any\n        ): LoDashImplicitWrapper<TResult>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.set\n         */\n        set(\n            path: PropertyPath,\n            value: any\n        ): this;\n\n        /**\n         * @see _.set\n         */\n        set<TResult>(\n            path: PropertyPath,\n            value: any\n        ): LoDashExplicitWrapper<TResult>;\n    }\n\n    //_.setWith\n    type SetWithCustomizer<T> = (nsValue: any, key: string, nsObject: T) => any;\n\n    interface LoDashStatic {\n        /**\n         * This method is like _.set except that it accepts customizer which is invoked to produce the objects of\n         * path. If customizer returns undefined path creation is handled by the method instead. The customizer is\n         * invoked with three arguments: (nsValue, key, nsObject).\n         *\n         * @param object The object to modify.\n         * @param path The path of the property to set.\n         * @param value The value to set.\n         * @parem customizer The function to customize assigned values.\n         * @return Returns object.\n         */\n        setWith<T extends object>(\n            object: T,\n            path: PropertyPath,\n            value: any,\n            customizer?: SetWithCustomizer<T>\n        ): T;\n\n        setWith<T extends object, TResult>(\n            object: T,\n            path: PropertyPath,\n            value: any,\n            customizer?: SetWithCustomizer<T>\n        ): TResult;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.setWith\n         */\n        setWith(\n            path: PropertyPath,\n            value: any,\n            customizer?: SetWithCustomizer<TValue>\n        ): this;\n\n        /**\n         * @see _.setWith\n         */\n        setWith<TResult>(\n            path: PropertyPath,\n            value: any,\n            customizer?: SetWithCustomizer<TValue>\n        ): LoDashImplicitWrapper<TResult>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.setWith\n         */\n        setWith(\n            path: PropertyPath,\n            value: any,\n            customizer?: SetWithCustomizer<TValue>\n        ): this;\n\n        /**\n         * @see _.setWith\n         */\n        setWith<TResult>(\n            path: PropertyPath,\n            value: any,\n            customizer?: SetWithCustomizer<TValue>\n        ): LoDashExplicitWrapper<TResult>;\n    }\n\n    //_.toPairs\n    interface LoDashStatic {\n        /**\n         * Creates an array of own enumerable key-value pairs for object.\n         *\n         * @param object The object to query.\n         * @return Returns the new array of key-value pairs.\n         */\n        toPairs<T>(object?: Dictionary<T>): Array<[string, T]>;\n\n        /**\n         * @see _.toPairs\n         */\n        toPairs(object?: object): Array<[string, any]>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.toPairs\n         */\n        toPairs<T>(this: LoDashImplicitWrapper<Dictionary<T>>): LoDashImplicitWrapper<Array<[string, T]>>;\n\n        /**\n         * @see _.toPairs\n         */\n        toPairs(): LoDashImplicitWrapper<Array<[string, any]>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.toPairs\n         */\n        toPairs<T>(this: LoDashExplicitWrapper<Dictionary<T>>): LoDashExplicitWrapper<Array<[string, T]>>;\n\n        /**\n         * @see _.toPairs\n         */\n        toPairs(): LoDashExplicitWrapper<Array<[string, any]>>;\n    }\n\n    //_.toPairsIn\n    interface LoDashStatic {\n        /**\n         * Creates an array of own and inherited enumerable key-value pairs for object.\n         *\n         * @param object The object to query.\n         * @return Returns the new array of key-value pairs.\n         */\n        toPairsIn<T>(object?: Dictionary<T>): Array<[string, T]>;\n\n        /**\n         * @see _.toPairsIn\n         */\n        toPairsIn(object?: object): Array<[string, any]>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.toPairsIn\n         */\n        toPairsIn<T>(this: LoDashImplicitWrapper<Dictionary<T>>): LoDashImplicitWrapper<Array<[string, T]>>;\n\n        /**\n         * @see _.toPairsIn\n         */\n        toPairsIn(): LoDashImplicitWrapper<Array<[string, any]>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.toPairsIn\n         */\n        toPairsIn<T>(this: LoDashExplicitWrapper<Dictionary<T>>): LoDashExplicitWrapper<Array<[string, T]>>;\n\n        /**\n         * @see _.toPairsIn\n         */\n        toPairsIn(): LoDashExplicitWrapper<Array<[string, any]>>;\n    }\n\n    //_.transform\n    interface LoDashStatic {\n        /**\n         * An alternative to _.reduce; this method transforms object to a new accumulator object which is the result of\n         * running each of its own enumerable properties through iteratee, with each invocation potentially mutating\n         * the accumulator object. The iteratee is bound to thisArg and invoked with four arguments: (accumulator,\n         * value, key, object). Iteratee functions may exit iteration early by explicitly returning false.\n         *\n         * @param object The object to iterate over.\n         * @param iteratee The function invoked per iteration.\n         * @param accumulator The custom accumulator value.\n         * @param thisArg The this binding of iteratee.\n         * @return Returns the accumulated value.\n         */\n        transform<T, TResult>(\n            object: T[],\n            iteratee: MemoVoidArrayIterator<T, TResult[]>,\n            accumulator?: TResult[]\n        ): TResult[];\n\n        /**\n         * @see _.transform\n         */\n        transform<T, TResult>(\n            object: T[],\n            iteratee: MemoVoidArrayIterator<T, Dictionary<TResult>>,\n            accumulator: Dictionary<TResult>\n        ): Dictionary<TResult>;\n\n        /**\n         * @see _.transform\n         */\n        transform<T, TResult>(\n            object: Dictionary<T>,\n            iteratee: MemoVoidDictionaryIterator<T, Dictionary<TResult>>,\n            accumulator?: Dictionary<TResult>\n        ): Dictionary<TResult>;\n\n        /**\n         * @see _.transform\n         */\n        transform<T, TResult>(\n            object: Dictionary<T>,\n            iteratee: MemoVoidDictionaryIterator<T, TResult[]>,\n            accumulator: TResult[]\n        ): TResult[];\n\n        /**\n         * @see _.transform\n         */\n        transform(\n            object: any[],\n        ): any[];\n\n        /**\n         * @see _.transform\n         */\n        transform(\n            object: object,\n        ): Dictionary<any>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.transform\n         */\n        transform<T, TResult>(\n            this: LoDashImplicitWrapper<T[]>,\n            iteratee: MemoVoidArrayIterator<T, TResult[]>,\n            accumulator?: TResult[]\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.transform\n         */\n        transform<T, TResult>(\n            this: LoDashImplicitWrapper<T[]>,\n            iteratee: MemoVoidArrayIterator<T, Dictionary<TResult>>,\n            accumulator: Dictionary<TResult>\n        ): LoDashImplicitWrapper<Dictionary<TResult>>;\n\n        /**\n         * @see _.transform\n         */\n        transform<T, TResult>(\n            this: LoDashImplicitWrapper<Dictionary<T>>,\n            iteratee: MemoVoidDictionaryIterator<T, Dictionary<TResult>>,\n            accumulator?: Dictionary<TResult>\n        ): LoDashImplicitWrapper<Dictionary<TResult>>;\n\n        /**\n         * @see _.transform\n         */\n        transform<T, TResult>(\n            this: LoDashImplicitWrapper<Dictionary<T>>,\n            iteratee: MemoVoidDictionaryIterator<T, TResult[]>,\n            accumulator: TResult[]\n        ): LoDashImplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.transform\n         */\n        transform(\n            this: LoDashImplicitWrapper<any[]>,\n        ): LoDashImplicitWrapper<any[]>;\n\n        /**\n         * @see _.transform\n         */\n        transform(): LoDashImplicitWrapper<Dictionary<any>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.transform\n         */\n        transform<T, TResult>(\n            this: LoDashExplicitWrapper<T[]>,\n            iteratee: MemoVoidArrayIterator<T, TResult[]>,\n            accumulator?: TResult[]\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.transform\n         */\n        transform<T, TResult>(\n            this: LoDashExplicitWrapper<T[]>,\n            iteratee: MemoVoidArrayIterator<T, Dictionary<TResult>>,\n            accumulator?: Dictionary<TResult>\n        ): LoDashExplicitWrapper<Dictionary<TResult>>;\n\n        /**\n         * @see _.transform\n         */\n        transform<T, TResult>(\n            this: LoDashExplicitWrapper<Dictionary<T>>,\n            iteratee: MemoVoidDictionaryIterator<T, Dictionary<TResult>>,\n            accumulator?: Dictionary<TResult>\n        ): LoDashExplicitWrapper<Dictionary<TResult>>;\n\n        /**\n         * @see _.transform\n         */\n        transform<T, TResult>(\n            this: LoDashExplicitWrapper<Dictionary<T>>,\n            iteratee: MemoVoidDictionaryIterator<T, TResult[]>,\n            accumulator?: TResult[]\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.transform\n         */\n        transform(\n            this: LoDashExplicitWrapper<any[]>,\n        ): LoDashExplicitWrapper<any[]>;\n\n        /**\n         * @see _.transform\n         */\n        transform(): LoDashExplicitWrapper<Dictionary<any>>;\n    }\n\n    //_.unset\n    interface LoDashStatic {\n        /**\n         * Removes the property at path of object.\n         *\n         * Note: This method mutates object.\n         *\n         * @param object The object to modify.\n         * @param path The path of the property to unset.\n         * @return Returns true if the property is deleted, else false.\n         */\n        unset(\n            object: any,\n            path: PropertyPath\n        ): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.unset\n         */\n        unset(path: PropertyPath): LoDashImplicitWrapper<boolean>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.unset\n         */\n        unset(path: PropertyPath): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.update\n    interface LoDashStatic {\n        /**\n         * This method is like _.set except that accepts updater to produce the value to set. Use _.updateWith to\n         * customize path creation. The updater is invoked with one argument: (value).\n         *\n         * @param object The object to modify.\n         * @param path The path of the property to set.\n         * @param updater The function to produce the updated value.\n         * @return Returns object.\n         */\n        update(\n            object: object,\n            path: PropertyPath,\n            updater: (value: any) => any\n        ): any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.update\n         */\n        update(\n            path: PropertyPath,\n            updater: (value: any) => any\n        ): LoDashImplicitWrapper<any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.update\n         */\n        update(\n            path: PropertyPath,\n            updater: (value: any) => any\n        ): LoDashExplicitWrapper<any>;\n    }\n\n    //_.updateWith\n    interface LoDashStatic {\n        /**\n         * This method is like `_.update` except that it accepts `customizer` which is\n         * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n         * path creation is handled by the method instead. The `customizer` is invoked\n         * with three arguments: (nsValue, key, nsObject).\n         *\n         * **Note:** This method mutates `object`.\n         *\n         * @since 4.6.0\n         * @category Object\n         * @param object The object to modify.\n         * @param path The path of the property to set.\n         * @param updater The function to produce the updated value.\n         * @param [customizer] The function to customize assigned values.\n         * @returns Returns `object`.\n         * @example\n         *\n         * var object = {};\n         *\n         * _.updateWith(object, '[0][1]', _.constant('a'), Object);\n         * // => { '0': { '1': 'a' } }\n         */\n        updateWith<T extends object>(\n            object: T,\n            path: PropertyPath,\n            updater: (oldValue: any) => any,\n            customizer?: SetWithCustomizer<T>\n        ): T;\n\n        /**\n         * @see _.updateWith\n         */\n        updateWith<T extends object, TResult>(\n            object: T,\n            path: PropertyPath,\n            updater: (oldValue: any) => any,\n            customizer?: SetWithCustomizer<T>\n        ): TResult;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.updateWith\n         */\n        updateWith(\n            path: PropertyPath,\n            updater: (oldValue: any) => any,\n            customizer?: SetWithCustomizer<TValue>\n        ): this;\n\n        /**\n         * @see _.updateWith\n         */\n        updateWith<TResult>(\n            path: PropertyPath,\n            updater: (oldValue: any) => any,\n            customizer?: SetWithCustomizer<TValue>\n        ): LoDashImplicitWrapper<TResult>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.updateWith\n         */\n        updateWith(\n            path: PropertyPath,\n            updater: (oldValue: any) => any,\n            customizer?: SetWithCustomizer<TValue>\n        ): this;\n\n        /**\n         * @see _.updateWith\n         */\n        updateWith<TResult>(\n            path: PropertyPath,\n            updater: (oldValue: any) => any,\n            customizer?: SetWithCustomizer<TValue>\n        ): LoDashExplicitWrapper<TResult>;\n    }\n\n    //_.values\n    interface LoDashStatic {\n        /**\n         * Creates an array of the own enumerable property values of object.\n         *\n         * @param object The object to query.\n         * @return Returns an array of property values.\n         */\n        values<T>(object: Dictionary<T>|NumericDictionary<T>|List<T> | null | undefined): T[];\n\n        /**\n         * @see _.values\n         */\n        values<T extends object>(object: T | null | undefined): Array<T[keyof T]>;\n\n        /**\n         * @see _.values\n         */\n        values(object: any): any[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.values\n         */\n        values<T>(this: LoDashImplicitWrapper<Dictionary<T> | NumericDictionary<T> | List<T> | null | undefined>): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.values\n         */\n        values<T extends object>(this: LoDashImplicitWrapper<T | null | undefined>): LoDashImplicitWrapper<Array<T[keyof T]>>;\n\n        /**\n         * @see _.values\n         */\n        values(): LoDashImplicitWrapper<any[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.values\n         */\n        values<T>(this: LoDashExplicitWrapper<Dictionary<T> | NumericDictionary<T> | List<T> | null | undefined>): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.values\n         */\n        values<T extends object>(this: LoDashExplicitWrapper<T | null | undefined>): LoDashExplicitWrapper<Array<T[keyof T]>>;\n\n        /**\n         * @see _.values\n         */\n        values(): LoDashExplicitWrapper<any[]>;\n    }\n\n    //_.valuesIn\n    interface LoDashStatic {\n        /**\n         * Creates an array of the own and inherited enumerable property values of object.\n         *\n         * @param object The object to query.\n         * @return Returns the array of property values.\n         */\n        valuesIn<T>(object: Dictionary<T>|NumericDictionary<T>|List<T> | null | undefined): T[];\n\n        /**\n         * @see _.valuesIn\n         */\n        valuesIn<T extends object>(object: T | null | undefined): Array<T[keyof T]>;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.valuesIn\n         */\n        valuesIn<T>(this: LoDashImplicitWrapper<Dictionary<T> | NumericDictionary<T> | List<T> | null | undefined>): LoDashImplicitWrapper<T[]>;\n\n        /**\n         * @see _.valuesIn\n         */\n        valuesIn<T extends object>(this: LoDashImplicitWrapper<T | null | undefined>): LoDashImplicitWrapper<Array<T[keyof T]>>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.valuesIn\n         */\n        valuesIn<T>(this: LoDashExplicitWrapper<Dictionary<T> | NumericDictionary<T> | List<T> | null | undefined>): LoDashExplicitWrapper<T[]>;\n\n        /**\n         * @see _.valuesIn\n         */\n        valuesIn<T extends object>(this: LoDashExplicitWrapper<T | null | undefined>): LoDashExplicitWrapper<Array<T[keyof T]>>;\n    }\n\n    /**********\n     * String *\n     **********/\n\n    //_.camelCase\n    interface LoDashStatic {\n        /**\n         * Converts string to camel case.\n         *\n         * @param string The string to convert.\n         * @return Returns the camel cased string.\n         */\n        camelCase(string?: string): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.camelCase\n         */\n        camelCase(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.camelCase\n         */\n        camelCase(): LoDashExplicitWrapper<string>;\n    }\n\n    //_.capitalize\n    interface LoDashStatic {\n        /**\n         * Converts the first character of string to upper case and the remaining to lower case.\n         *\n         * @param string The string to capitalize.\n         * @return Returns the capitalized string.\n         */\n        capitalize(string?: string): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.capitalize\n         */\n        capitalize(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.capitalize\n         */\n        capitalize(): LoDashExplicitWrapper<string>;\n    }\n\n    //_.deburr\n    interface LoDashStatic {\n        /**\n         * Deburrs string by converting latin-1 supplementary letters to basic latin letters and removing combining\n         * diacritical marks.\n         *\n         * @param string The string to deburr.\n         * @return Returns the deburred string.\n         */\n        deburr(string?: string): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.deburr\n         */\n        deburr(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.deburr\n         */\n        deburr(): LoDashExplicitWrapper<string>;\n    }\n\n    //_.endsWith\n    interface LoDashStatic {\n        /**\n         * Checks if string ends with the given target string.\n         *\n         * @param string The string to search.\n         * @param target The string to search for.\n         * @param position The position to search from.\n         * @return Returns true if string ends with target, else false.\n         */\n        endsWith(\n            string?: string,\n            target?: string,\n            position?: number\n        ): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.endsWith\n         */\n        endsWith(\n            target?: string,\n            position?: number\n        ): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.endsWith\n         */\n        endsWith(\n            target?: string,\n            position?: number\n        ): LoDashExplicitWrapper<boolean>;\n    }\n\n    // _.escape\n    interface LoDashStatic {\n        /**\n         * Converts the characters \"&\", \"<\", \">\", '\"', \"'\", and \"`\" in string to their corresponding HTML entities.\n         *\n         * Note: No other characters are escaped. To escape additional characters use a third-party library like he.\n         *\n         * hough the \">\" character is escaped for symmetry, characters like \">\" and \"/\" donât need escaping in HTML\n         * and have no special meaning unless they're part of a tag or unquoted attribute value. See Mathias Bynensâs\n         * article (under \"semi-related fun fact\") for more details.\n         *\n         * Backticks are escaped because in IE < 9, they can break out of attribute values or HTML comments. See #59,\n         * #102, #108, and #133 of the HTML5 Security Cheatsheet for more details.\n         *\n         * When working with HTML you should always quote attribute values to reduce XSS vectors.\n         *\n         * @param string The string to escape.\n         * @return Returns the escaped string.\n         */\n        escape(string?: string): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.escape\n         */\n        escape(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.escape\n         */\n        escape(): LoDashExplicitWrapper<string>;\n    }\n\n    // _.escapeRegExp\n    interface LoDashStatic {\n        /**\n         * Escapes the RegExp special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\", \"?\", \"(\", \")\", \"[\", \"]\",\n         * \"{\", \"}\", and \"|\" in string.\n         *\n         * @param string The string to escape.\n         * @return Returns the escaped string.\n         */\n        escapeRegExp(string?: string): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.escapeRegExp\n         */\n        escapeRegExp(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.escapeRegExp\n         */\n        escapeRegExp(): LoDashExplicitWrapper<string>;\n    }\n\n    //_.kebabCase\n    interface LoDashStatic {\n        /**\n         * Converts string to kebab case.\n         *\n         * @param string The string to convert.\n         * @return Returns the kebab cased string.\n         */\n        kebabCase(string?: string): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.kebabCase\n         */\n        kebabCase(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.kebabCase\n         */\n        kebabCase(): LoDashExplicitWrapper<string>;\n    }\n\n    //_.lowerCase\n    interface LoDashStatic {\n        /**\n         * Converts `string`, as space separated words, to lower case.\n         *\n         * @param string The string to convert.\n         * @return Returns the lower cased string.\n         */\n        lowerCase(string?: string): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.lowerCase\n         */\n        lowerCase(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.lowerCase\n         */\n        lowerCase(): LoDashExplicitWrapper<string>;\n    }\n\n    //_.lowerFirst\n    interface LoDashStatic {\n        /**\n         * Converts the first character of `string` to lower case.\n         *\n         * @param string The string to convert.\n         * @return Returns the converted string.\n         */\n        lowerFirst(string?: string): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.lowerFirst\n         */\n        lowerFirst(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.lowerFirst\n         */\n        lowerFirst(): LoDashExplicitWrapper<string>;\n    }\n\n    //_.pad\n    interface LoDashStatic {\n        /**\n         * Pads string on the left and right sides if itâs shorter than length. Padding characters are truncated if\n         * they canât be evenly divided by length.\n         *\n         * @param string The string to pad.\n         * @param length The padding length.\n         * @param chars The string used as padding.\n         * @return Returns the padded string.\n         */\n        pad(\n            string?: string,\n            length?: number,\n            chars?: string\n        ): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.pad\n         */\n        pad(\n            length?: number,\n            chars?: string\n        ): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.pad\n         */\n        pad(\n            length?: number,\n            chars?: string\n        ): LoDashExplicitWrapper<string>;\n    }\n\n    //_.padEnd\n    interface LoDashStatic {\n        /**\n         * Pads string on the right side if itâs shorter than length. Padding characters are truncated if they exceed\n         * length.\n         *\n         * @param string The string to pad.\n         * @param length The padding length.\n         * @param chars The string used as padding.\n         * @return Returns the padded string.\n         */\n        padEnd(\n            string?: string,\n            length?: number,\n            chars?: string\n        ): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.padEnd\n         */\n        padEnd(\n            length?: number,\n            chars?: string\n        ): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.padEnd\n         */\n        padEnd(\n            length?: number,\n            chars?: string\n        ): LoDashExplicitWrapper<string>;\n    }\n\n    //_.padStart\n    interface LoDashStatic {\n        /**\n         * Pads string on the left side if itâs shorter than length. Padding characters are truncated if they exceed\n         * length.\n         *\n         * @param string The string to pad.\n         * @param length The padding length.\n         * @param chars The string used as padding.\n         * @return Returns the padded string.\n         */\n        padStart(\n            string?: string,\n            length?: number,\n            chars?: string\n        ): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.padStart\n         */\n        padStart(\n            length?: number,\n            chars?: string\n        ): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.padStart\n         */\n        padStart(\n            length?: number,\n            chars?: string\n        ): LoDashExplicitWrapper<string>;\n    }\n\n    //_.parseInt\n    interface LoDashStatic {\n        /**\n         * Converts string to an integer of the specified radix. If radix is undefined or 0, a radix of 10 is used\n         * unless value is a hexadecimal, in which case a radix of 16 is used.\n         *\n         * Note: This method aligns with the ES5 implementation of parseInt.\n         *\n         * @param string The string to convert.\n         * @param radix The radix to interpret value by.\n         * @return Returns the converted integer.\n         */\n        parseInt(\n            string: string,\n            radix?: number\n        ): number;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.parseInt\n         */\n        parseInt(radix?: number): number;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.parseInt\n         */\n        parseInt(radix?: number): LoDashExplicitWrapper<number>;\n    }\n\n    //_.repeat\n    interface LoDashStatic {\n        /**\n         * Repeats the given string n times.\n         *\n         * @param string The string to repeat.\n         * @param n The number of times to repeat the string.\n         * @return Returns the repeated string.\n         */\n        repeat(\n            string?: string,\n            n?: number\n        ): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.repeat\n         */\n        repeat(n?: number): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.repeat\n         */\n        repeat(n?: number): LoDashExplicitWrapper<string>;\n    }\n\n    type ReplaceFunction = (match: string, ...args: any[]) => string;\n\n    //_.replace\n    interface LoDashStatic {\n        /**\n         * Replaces matches for pattern in string with replacement.\n         *\n         * Note: This method is based on String#replace.\n         *\n         * @return Returns the modified string.\n         */\n        replace(\n            string: string,\n            pattern: RegExp | string,\n            replacement: ReplaceFunction | string\n        ): string;\n\n        /**\n         * @see _.replace\n         */\n        replace(\n            pattern: RegExp | string,\n            replacement: ReplaceFunction | string\n        ): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.replace\n         */\n        replace(\n            pattern: RegExp|string,\n            replacement: ReplaceFunction | string\n        ): string;\n\n        /**\n         * @see _.replace\n         */\n        replace(\n            replacement: ReplaceFunction | string\n        ): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.replace\n         */\n        replace(\n            pattern: RegExp | string,\n            replacement: ReplaceFunction | string\n        ): LoDashExplicitWrapper<string>;\n\n        /**\n         * @see _.replace\n         */\n        replace(\n            replacement: ReplaceFunction | string\n        ): LoDashExplicitWrapper<string>;\n    }\n\n    //_.snakeCase\n    interface LoDashStatic {\n        /**\n         * Converts string to snake case.\n         *\n         * @param string The string to convert.\n         * @return Returns the snake cased string.\n         */\n        snakeCase(string?: string): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.snakeCase\n         */\n        snakeCase(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.snakeCase\n         */\n        snakeCase(): LoDashExplicitWrapper<string>;\n    }\n\n    //_.split\n    interface LoDashStatic {\n        /**\n         * Splits string by separator.\n         *\n         * Note: This method is based on String#split.\n         *\n         * @param string The string to trim.\n         * @param separator The separator pattern to split by.\n         * @param limit The length to truncate results to.\n         * @return Returns the new array of string segments.\n         */\n        split(\n            string: string,\n            separator?: RegExp|string,\n            limit?: number\n        ): string[];\n\n        /**\n         * Splits string by separator.\n         *\n         * Note: This method is based on String#split.\n         *\n         * @param string The string to trim.\n         * @param index Not used in this overload.\n         * @param guard Enables use as an iteratee for methods like _.map. You should not pass this parameter directly in your code.\n         * @return Returns the new array of string segments.\n         */\n        split(\n            string: string,\n            index: string | number,\n            guard: object\n        ): string[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.split\n         */\n        split(\n            separator?: RegExp|string,\n            limit?: number\n        ): LoDashImplicitWrapper<string[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.split\n         */\n        split(\n            separator?: RegExp|string,\n            limit?: number\n        ): LoDashExplicitWrapper<string[]>;\n    }\n\n    //_.startCase\n    interface LoDashStatic {\n        /**\n         * Converts string to start case.\n         *\n         * @param string The string to convert.\n         * @return Returns the start cased string.\n         */\n        startCase(string?: string): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.startCase\n         */\n        startCase(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.startCase\n         */\n        startCase(): LoDashExplicitWrapper<string>;\n    }\n\n    //_.startsWith\n    interface LoDashStatic {\n        /**\n         * Checks if string starts with the given target string.\n         *\n         * @param string The string to search.\n         * @param target The string to search for.\n         * @param position The position to search from.\n         * @return Returns true if string starts with target, else false.\n         */\n        startsWith(\n            string?: string,\n            target?: string,\n            position?: number\n        ): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.startsWith\n         */\n        startsWith(\n            target?: string,\n            position?: number\n        ): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.startsWith\n         */\n        startsWith(\n            target?: string,\n            position?: number\n        ): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.template\n    interface TemplateOptions extends TemplateSettings {\n        /**\n         * The sourceURL of the template's compiled source.\n         */\n        sourceURL?: string;\n    }\n\n    interface TemplateExecutor {\n        (data?: object): string;\n        source: string;\n    }\n\n    interface LoDashStatic {\n        /**\n         * Creates a compiled template function that can interpolate data properties in \"interpolate\" delimiters,\n         * HTML-escape interpolated data properties in \"escape\" delimiters, and execute JavaScript in \"evaluate\"\n         * delimiters. Data properties may be accessed as free variables in the template. If a setting object is\n         * provided it takes precedence over _.templateSettings values.\n         *\n         * Note: In the development build _.template utilizes\n         * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl) for easier\n         * debugging.\n         *\n         * For more information on precompiling templates see\n         * [lodash's custom builds documentation](https://lodash.com/custom-builds).\n         *\n         * For more information on Chrome extension sandboxes see\n         * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).\n         *\n         * @param string The template string.\n         * @param options The options object.\n         * @param options.escape The HTML \"escape\" delimiter.\n         * @param options.evaluate The \"evaluate\" delimiter.\n         * @param options.imports An object to import into the template as free variables.\n         * @param options.interpolate The \"interpolate\" delimiter.\n         * @param options.sourceURL The sourceURL of the template's compiled source.\n         * @param options.variable The data object variable name.\n         * @return Returns the compiled template function.\n         */\n        template(\n            string?: string,\n            options?: TemplateOptions\n        ): TemplateExecutor;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.template\n         */\n        template(options?: TemplateOptions): TemplateExecutor;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.template\n         */\n        template(options?: TemplateOptions): LoDashExplicitWrapper<TemplateExecutor>;\n    }\n\n    //_.toLower\n    interface LoDashStatic {\n        /**\n         * Converts `string`, as a whole, to lower case.\n         *\n         * @param string The string to convert.\n         * @return Returns the lower cased string.\n         */\n        toLower(string?: string): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.toLower\n         */\n        toLower(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.toLower\n         */\n        toLower(): LoDashExplicitWrapper<string>;\n    }\n\n    //_.toUpper\n    interface LoDashStatic {\n        /**\n         * Converts `string`, as a whole, to upper case.\n         *\n         * @param string The string to convert.\n         * @return Returns the upper cased string.\n         */\n        toUpper(string?: string): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.toUpper\n         */\n        toUpper(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.toUpper\n         */\n        toUpper(): LoDashExplicitWrapper<string>;\n    }\n\n    //_.trim\n    interface LoDashStatic {\n        /**\n         * Removes leading and trailing whitespace or specified characters from string.\n         *\n         * @param string The string to trim.\n         * @param chars The characters to trim.\n         * @return Returns the trimmed string.\n         */\n        trim(\n            string?: string,\n            chars?: string\n        ): string;\n\n        /**\n         * Removes leading and trailing whitespace or specified characters from string.\n         *\n         * @param string The string to trim.\n         * @param index Not used in this overload.\n         * @param guard Enables use as an iteratee for methods like _.map. You should not pass this parameter directly in your code.\n         * @return Returns the trimmed string.\n         */\n        trim(\n            string: string,\n            index: string | number,\n            guard: object\n        ): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.trim\n         */\n        trim(chars?: string): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.trim\n         */\n        trim(chars?: string): LoDashExplicitWrapper<string>;\n    }\n\n    //_.trimEnd\n    interface LoDashStatic {\n        /**\n         * Removes trailing whitespace or specified characters from string.\n         *\n         * @param string The string to trim.\n         * @param chars The characters to trim.\n         * @return Returns the trimmed string.\n         */\n        trimEnd(\n            string?: string,\n            chars?: string\n        ): string;\n\n        /**\n         * Removes trailing whitespace or specified characters from string.\n         *\n         * @param string The string to trim.\n         * @param index Not used in this overload.\n         * @param guard Enables use as an iteratee for methods like _.map. You should not pass this parameter directly in your code.\n         * @return Returns the trimmed string.\n         */\n        trimEnd(\n            string: string,\n            index: string | number,\n            guard: object\n        ): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.trimEnd\n         */\n        trimEnd(chars?: string): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.trimEnd\n         */\n        trimEnd(chars?: string): LoDashExplicitWrapper<string>;\n    }\n\n    //_.trimStart\n    interface LoDashStatic {\n        /**\n         * Removes leading whitespace or specified characters from string.\n         *\n         * @param string The string to trim.\n         * @param chars The characters to trim.\n         * @return Returns the trimmed string.\n         */\n        trimStart(\n            string?: string,\n            chars?: string\n        ): string;\n\n        /**\n         * Removes leading whitespace or specified characters from string.\n         *\n         * @param string The string to trim.\n         * @param index Not used in this overload.\n         * @param guard Enables use as an iteratee for methods like _.map. You should not pass this parameter directly in your code.\n         * @return Returns the trimmed string.\n         */\n        trimStart(\n            string: string,\n            index: string | number,\n            guard: object\n        ): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.trimStart\n         */\n        trimStart(chars?: string): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.trimStart\n         */\n        trimStart(chars?: string): LoDashExplicitWrapper<string>;\n    }\n\n    //_.truncate\n    interface TruncateOptions {\n        /** The maximum string length. */\n        length?: number;\n        /** The string to indicate text is omitted. */\n        omission?: string;\n        /** The separator pattern to truncate to. */\n        separator?: string|RegExp;\n    }\n\n    interface LoDashStatic {\n        /**\n         * Truncates string if itâs longer than the given maximum string length. The last characters of the truncated\n         * string are replaced with the omission string which defaults to \"â¦\".\n         *\n         * @param string The string to truncate.\n         * @param options The options object or maximum string length.\n         * @return Returns the truncated string.\n         */\n        truncate(\n            string?: string,\n            options?: TruncateOptions\n        ): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.truncate\n         */\n        truncate(options?: TruncateOptions): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.truncate\n         */\n        truncate(options?: TruncateOptions): LoDashExplicitWrapper<string>;\n    }\n\n    //_.unescape\n    interface LoDashStatic {\n        /**\n         * The inverse of _.escape; this method converts the HTML entities &amp;, &lt;, &gt;, &quot;, &#39;, and &#96;\n         * in string to their corresponding characters.\n         *\n         * Note: No other HTML entities are unescaped. To unescape additional HTML entities use a third-party library\n         * like he.\n         *\n         * @param string The string to unescape.\n         * @return Returns the unescaped string.\n         */\n        unescape(string?: string): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.unescape\n         */\n        unescape(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.unescape\n         */\n        unescape(): LoDashExplicitWrapper<string>;\n    }\n\n    //_.upperCase\n    interface LoDashStatic {\n        /**\n         * Converts `string`, as space separated words, to upper case.\n         *\n         * @param string The string to convert.\n         * @return Returns the upper cased string.\n         */\n        upperCase(string?: string): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.upperCase\n         */\n        upperCase(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.upperCase\n         */\n        upperCase(): LoDashExplicitWrapper<string>;\n    }\n\n    //_.upperFirst\n    interface LoDashStatic {\n        /**\n         * Converts the first character of `string` to upper case.\n         *\n         * @param string The string to convert.\n         * @return Returns the converted string.\n         */\n        upperFirst(string?: string): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.upperFirst\n         */\n        upperFirst(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.upperFirst\n         */\n        upperFirst(): LoDashExplicitWrapper<string>;\n    }\n\n    //_.words\n    interface LoDashStatic {\n        /**\n         * Splits `string` into an array of its words.\n         *\n         * @param string The string to inspect.\n         * @param pattern The pattern to match words.\n         * @return Returns the words of `string`.\n         */\n        words(\n            string?: string,\n            pattern?: string|RegExp\n        ): string[];\n\n        /**\n         * Splits `string` into an array of its words.\n         *\n         * @param string The string to inspect.\n         * @param index Not used in this overload.\n         * @param guard Enables use as an iteratee for methods like _.map. You should not pass this parameter directly in your code.\n         * @return Returns the words of `string`.\n         */\n        words(\n            string: string,\n            index: string | number,\n            guard: object\n        ): string[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.words\n         */\n        words(pattern?: string|RegExp): string[];\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.words\n         */\n        words(pattern?: string|RegExp): LoDashExplicitWrapper<string[]>;\n    }\n\n    /***********\n     * Utility *\n     ***********/\n\n    //_.attempt\n    interface LoDashStatic {\n        /**\n         * Attempts to invoke func, returning either the result or the caught error object. Any additional arguments\n         * are provided to func when itâs invoked.\n         *\n         * @param func The function to attempt.\n         * @return Returns the func result or error object.\n         */\n        attempt<TResult>(func: (...args: any[]) => TResult, ...args: any[]): TResult|Error;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.attempt\n         */\n        attempt<TResult>(...args: any[]): TResult|Error;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.attempt\n         */\n        attempt<TResult>(...args: any[]): LoDashExplicitWrapper<TResult|Error>;\n    }\n\n    //_.constant\n    interface LoDashStatic {\n        /**\n         * Creates a function that returns value.\n         *\n         * @param value The value to return from the new function.\n         * @return Returns the new function.\n         */\n        constant<T>(value: T): () => T;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.constant\n         */\n        constant(): LoDashImplicitWrapper<() => TValue>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.constant\n         */\n        constant(): LoDashExplicitWrapper<() => TValue>;\n    }\n\n    //_.defaultTo\n    interface LoDashStatic {\n        /**\n         * Checks `value` to determine whether a default value should be returned in\n         * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,\n         * or `undefined`.\n         *\n         * @param value The value to check.\n         * @param defaultValue The default value.\n         * @returns Returns the resolved value.\n         */\n        defaultTo<T>(value: T | null | undefined, defaultValue: T): T;\n\n        /**\n         * @see _.defaultTo\n         */\n        defaultTo<T, TDefault>(\n            value: T | null | undefined,\n            defaultValue: TDefault\n        ): T | TDefault;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.defaultTo\n         */\n        defaultTo<T>(this: LoDashImplicitWrapper<T | null | undefined>, defaultValue: T): T;\n\n        /**\n         * @see _.defaultTo\n         */\n        defaultTo<T, TDefault>(\n            this: LoDashImplicitWrapper<T | null | undefined>,\n            defaultValue: TDefault\n        ): T | TDefault;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.defaultTo\n         */\n        defaultTo<T>(this: LoDashExplicitWrapper<T | null | undefined>, defaultValue: T): LoDashExplicitWrapper<T>;\n\n        /**\n         * @see _.defaultTo\n         */\n        defaultTo<T, TDefault>(\n            this: LoDashExplicitWrapper<T | null | undefined>,\n            defaultValue: TDefault\n        ): LoDashExplicitWrapper<T | TDefault>;\n    }\n\n    //_.identity\n    interface LoDashStatic {\n        /**\n         * This method returns the first argument provided to it.\n         *\n         * @param value Any value.\n         * @return Returns value.\n         */\n        identity<T>(value: T): T;\n\n        /**\n         * @see _.identity\n         */\n        identity(): undefined;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.identity\n         */\n        identity(): TValue;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.identity\n         */\n        identity(): this;\n    }\n\n    //_.iteratee\n    interface LoDashStatic {\n        /**\n         * Creates a function that invokes `func` with the arguments of the created\n         * function. If `func` is a property name the created callback returns the\n         * property value for a given element. If `func` is an object the created\n         * callback returns `true` for elements that contain the equivalent object properties, otherwise it returns `false`.\n         *\n         * @category Util\n         * @param [func=_.identity] The value to convert to a callback.\n         * @returns Returns the callback.\n         * @example\n         *\n         * var users = [\n         *   { 'user': 'barney', 'age': 36 },\n         *   { 'user': 'fred',   'age': 40 }\n         * ];\n         *\n         * // create custom iteratee shorthands\n         * _.iteratee = _.wrap(_.iteratee, function(callback, func) {\n         *   var p = /^(\\S+)\\s*([<>])\\s*(\\S+)$/.exec(func);\n         *   return !p ? callback(func) : function(object) {\n         *     return (p[2] == '>' ? object[p[1]] > p[3] : object[p[1]] < p[3]);\n         *   };\n         * });\n         *\n         * _.filter(users, 'age > 36');\n         * // => [{ 'user': 'fred', 'age': 40 }]\n         */\n        iteratee<TFunction extends (...args: any[]) => any>(\n            func: TFunction | string | object\n        ): TFunction;\n\n        /**\n         * @see _.iteratee\n         */\n        iteratee(): typeof _.identity; // tslint:disable-line:no-unnecessary-qualifier\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.iteratee\n         */\n        iteratee<TFunction extends (...args: any[]) => any>(\n            this: LoDashImplicitWrapper<TFunction | string | object>\n        ): LoDashImplicitWrapper<TFunction>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.iteratee\n         */\n        iteratee<TFunction extends (...args: any[]) => any>(\n            this: LoDashExplicitWrapper<TFunction | string | object>\n        ): LoDashExplicitWrapper<TFunction>;\n    }\n\n    //_.matches\n    interface LoDashStatic {\n        /**\n         * Creates a function that performs a deep comparison between a given object and source, returning true if the\n         * given object has equivalent property values, else false.\n         *\n         * Note: This method supports comparing arrays, booleans, Date objects, numbers, Object objects, regexes, and\n         * strings. Objects are compared by their own, not inherited, enumerable properties. For comparing a single own\n         * or inherited property value see _.matchesProperty.\n         *\n         * @param source The object of property values to match.\n         * @return Returns the new function.\n         */\n        matches<T>(source: T): (value: any) => boolean;\n\n        /**\n         * @see _.matches\n         */\n        matches<T, V>(source: T): (value: V) => boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.matches\n         */\n        matches<V>(): LoDashImplicitWrapper<(value: V) => boolean>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.matches\n         */\n        matches<V>(): LoDashExplicitWrapper<(value: V) => boolean>;\n    }\n\n    //_.matchesProperty\n    interface LoDashStatic {\n        /**\n         * Creates a function that compares the property value of path on a given object to value.\n         *\n         * Note: This method supports comparing arrays, booleans, Date objects, numbers, Object objects, regexes, and\n         * strings. Objects are compared by their own, not inherited, enumerable properties.\n         *\n         * @param path The path of the property to get.\n         * @param srcValue The value to match.\n         * @return Returns the new function.\n         */\n        matchesProperty<T>(\n            path: PropertyPath,\n            srcValue: T\n        ): (value: any) => boolean;\n\n        /**\n         * @see _.matchesProperty\n         */\n        matchesProperty<T, V>(\n            path: PropertyPath,\n            srcValue: T\n        ): (value: V) => boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.matchesProperty\n         */\n        matchesProperty<SrcValue>(\n            srcValue: SrcValue\n        ): LoDashImplicitWrapper<(value: any) => boolean>;\n\n        /**\n         * @see _.matchesProperty\n         */\n        matchesProperty<SrcValue, Value>(\n            srcValue: SrcValue\n        ): LoDashImplicitWrapper<(value: Value) => boolean>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.matchesProperty\n         */\n        matchesProperty<SrcValue>(\n            srcValue: SrcValue\n        ): LoDashExplicitWrapper<(value: any) => boolean>;\n\n        /**\n         * @see _.matchesProperty\n         */\n        matchesProperty<SrcValue, Value>(\n            srcValue: SrcValue\n        ): LoDashExplicitWrapper<(value: Value) => boolean>;\n    }\n\n    //_.method\n    interface LoDashStatic {\n        /**\n         * Creates a function that invokes the method at path on a given object. Any additional arguments are provided\n         * to the invoked method.\n         *\n         * @param path The path of the method to invoke.\n         * @param args The arguments to invoke the method with.\n         * @return Returns the new function.\n         */\n        method(\n            path: PropertyPath,\n            ...args: any[]\n        ): (object: any) => any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.method\n         */\n        method(...args: any[]): LoDashImplicitWrapper<(object: any) => any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.method\n         */\n        method(...args: any[]): LoDashExplicitWrapper<(object: any) => any>;\n    }\n\n    //_.methodOf\n    interface LoDashStatic {\n        /**\n         * The opposite of _.method; this method creates a function that invokes the method at a given path on object.\n         * Any additional arguments are provided to the invoked method.\n         *\n         * @param object The object to query.\n         * @param args The arguments to invoke the method with.\n         * @return Returns the new function.\n         */\n        methodOf(\n            object: object,\n            ...args: any[]\n        ): (path: PropertyPath) => any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.methodOf\n         */\n        methodOf(\n            ...args: any[]\n        ): LoDashImplicitWrapper<(path: PropertyPath) => any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.methodOf\n         */\n        methodOf(\n            ...args: any[]\n        ): LoDashExplicitWrapper<(path: PropertyPath) => any>;\n    }\n\n    //_.mixin\n    interface MixinOptions {\n        chain?: boolean;\n    }\n\n    interface LoDashStatic {\n        /**\n         * Adds all own enumerable function properties of a source object to the destination object. If object is a\n         * function then methods are added to its prototype as well.\n         *\n         * Note: Use _.runInContext to create a pristine lodash function to avoid conflicts caused by modifying\n         * the original.\n         *\n         * @param object The destination object.\n         * @param source The object of functions to add.\n         * @param options The options object.\n         * @param options.chain Specify whether the functions added are chainable.\n         * @return Returns object.\n         */\n        mixin<TObject>(\n            object: TObject,\n            source: Dictionary<(...args: any[]) => any>,\n            options?: MixinOptions\n        ): TObject;\n\n        /**\n         * @see _.mixin\n         */\n        mixin<TResult>(\n            source: Dictionary<(...args: any[]) => any>,\n            options?: MixinOptions\n        ): LoDashStatic;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.mixin\n         */\n        mixin(\n            source: Dictionary<(...args: any[]) => any>,\n            options?: MixinOptions\n        ): this;\n\n        /**\n         * @see _.mixin\n         */\n        mixin(\n            options?: MixinOptions\n        ): LoDashImplicitWrapper<LoDashStatic>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.mixin\n         */\n        mixin(\n            source: Dictionary<(...args: any[]) => any>,\n            options?: MixinOptions\n        ): this;\n\n        /**\n         * @see _.mixin\n         */\n        mixin(\n            options?: MixinOptions\n        ): LoDashExplicitWrapper<LoDashStatic>;\n    }\n\n    //_.noConflict\n    interface LoDashStatic {\n        /**\n         * Reverts the _ variable to its previous value and returns a reference to the lodash function.\n         *\n         * @return Returns the lodash function.\n         */\n        noConflict(): typeof _;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.noConflict\n         */\n        noConflict(): typeof _;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.noConflict\n         */\n        noConflict(): LoDashExplicitWrapper<typeof _>;\n    }\n\n    //_.noop\n    interface LoDashStatic {\n        /**\n         * A no-operation function that returns undefined regardless of the arguments it receives.\n         *\n         * @return undefined\n         */\n        noop(...args: any[]): void;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.noop\n         */\n        noop(...args: any[]): void;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.noop\n         */\n        noop(...args: any[]): LoDashExplicitWrapper<undefined>;\n    }\n\n    //_.nthArg\n    interface LoDashStatic {\n        /**\n         * Creates a function that returns its nth argument.\n         *\n         * @param n The index of the argument to return.\n         * @return Returns the new function.\n         */\n        nthArg(n?: number): (...args: any[]) => any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.nthArg\n         */\n        nthArg(): LoDashImplicitWrapper<(...args: any[]) => any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.nthArg\n         */\n        nthArg(): LoDashExplicitWrapper<(...args: any[]) => any>;\n    }\n\n    //_.over\n    interface LoDashStatic {\n        /**\n         * Creates a function that invokes iteratees with the arguments provided to the created function and returns\n         * their results.\n         *\n         * @param iteratees The iteratees to invoke.\n         * @return Returns the new function.\n         */\n        over<TResult>(...iteratees: Array<Many<(...args: any[]) => TResult>>): (...args: any[]) => TResult[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.over\n         */\n        over<TResult>(\n            this: LoDashImplicitWrapper<Many<(...args: any[]) => TResult>>,\n            ...iteratees: Array<Many<(...args: any[]) => TResult>>\n        ): LoDashImplicitWrapper<(...args: any[]) => TResult[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.over\n         */\n        over<TResult>(\n            this: LoDashExplicitWrapper<Many<(...args: any[]) => TResult>>,\n            ...iteratees: Array<Many<(...args: any[]) => TResult>>\n        ): LoDashExplicitWrapper<(...args: any[]) => TResult[]>;\n    }\n\n    //_.overEvery\n    interface LoDashStatic {\n        /**\n         * Creates a function that checks if all of the predicates return truthy when invoked with the arguments\n         * provided to the created function.\n         *\n         * @param predicates The predicates to check.\n         * @return Returns the new function.\n         */\n        overEvery<T>(...predicates: Array<Many<(...args: T[]) => boolean>>): (...args: T[]) => boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.overEvery\n         */\n        overEvery<T>(...predicates: Array<Many<(...args: T[]) => boolean>>): LoDashImplicitWrapper<(...args: T[]) => boolean>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.overEvery\n         */\n        overEvery<T>(...predicates: Array<Many<(...args: T[]) => boolean>>): LoDashExplicitWrapper<(...args: T[]) => boolean>;\n    }\n\n    //_.overSome\n    interface LoDashStatic {\n        /**\n         * Creates a function that checks if any of the predicates return truthy when invoked with the arguments\n         * provided to the created function.\n         *\n         * @param predicates The predicates to check.\n         * @return Returns the new function.\n         */\n        overSome<T>(...predicates: Array<Many<(...args: T[]) => boolean>>): (...args: T[]) => boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.overSome\n         */\n        overSome<T>(...predicates: Array<Many<(...args: T[]) => boolean>>): LoDashImplicitWrapper<(...args: T[]) => boolean>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.overSome\n         */\n        overSome<T>(...predicates: Array<Many<(...args: T[]) => boolean>>): LoDashExplicitWrapper<(...args: T[]) => boolean>;\n    }\n\n    //_.property\n    interface LoDashStatic {\n        /**\n         * Creates a function that returns the property value at path on a given object.\n         *\n         * @param path The path of the property to get.\n         * @return Returns the new function.\n         */\n        property<TObj, TResult>(path: PropertyPath): (obj: TObj) => TResult;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.property\n         */\n        property<TObj, TResult>(): LoDashImplicitWrapper<(obj: TObj) => TResult>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.property\n         */\n        property<TObj, TResult>(): LoDashExplicitWrapper<(obj: TObj) => TResult>;\n    }\n\n    //_.propertyOf\n    interface LoDashStatic {\n        /**\n         * The opposite of _.property; this method creates a function that returns the property value at a given path\n         * on object.\n         *\n         * @param object The object to query.\n         * @return Returns the new function.\n         */\n        propertyOf<T extends {}>(object: T): (path: PropertyPath) => any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.propertyOf\n         */\n        propertyOf(): LoDashImplicitWrapper<(path: PropertyPath) => any>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.propertyOf\n         */\n        propertyOf(): LoDashExplicitWrapper<(path: PropertyPath) => any>;\n    }\n\n    //_.range\n    interface LoDashStatic {\n        /**\n         * Creates an array of numbers (positive and/or negative) progressing from start up to, but not including, end.\n         * If end is not specified itâs set to start with start then set to 0. If end is less than start a zero-length\n         * range is created unless a negative step is specified.\n         *\n         * @param start The start of the range.\n         * @param end The end of the range.\n         * @param step The value to increment or decrement by.\n         * @return Returns a new range array.\n         */\n        range(\n            start: number,\n            end?: number,\n            step?: number\n        ): number[];\n\n        /**\n         * Creates an array of numbers (positive and/or negative) progressing from start up to, but not including, end.\n         * If end is not specified itâs set to start with start then set to 0. If end is less than start a zero-length\n         * range is created unless a negative step is specified.\n         *\n         * @param start The start of the range.\n         * @param index Not used in this overload.\n         * @param guard Enables use as an iteratee for methods like _.map. You should not pass this parameter directly in your code.\n         * @return Returns a new range array.\n         */\n        range(\n            end: number,\n            index: string | number,\n            guard: object\n        ): number[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.range\n         */\n        range(\n            end?: number,\n            step?: number\n        ): LoDashImplicitWrapper<number[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.range\n         */\n        range(\n            end?: number,\n            step?: number\n        ): LoDashExplicitWrapper<number[]>;\n    }\n\n    //_.rangeRight\n    interface LoDashStatic {\n        /**\n         * This method is like `_.range` except that it populates values in\n         * descending order.\n         *\n         * @category Util\n         * @param start The start of the range.\n         * @param end The end of the range.\n         * @param step The value to increment or decrement by.\n         * @returns Returns the new array of numbers.\n         * @example\n         *\n         * _.rangeRight(4);\n         * // => [3, 2, 1, 0]\n         *\n         * _.rangeRight(-4);\n         * // => [-3, -2, -1, 0]\n         *\n         * _.rangeRight(1, 5);\n         * // => [4, 3, 2, 1]\n         *\n         * _.rangeRight(0, 20, 5);\n         * // => [15, 10, 5, 0]\n         *\n         * _.rangeRight(0, -4, -1);\n         * // => [-3, -2, -1, 0]\n         *\n         * _.rangeRight(1, 4, 0);\n         * // => [1, 1, 1]\n         *\n         * _.rangeRight(0);\n         * // => []\n         */\n        rangeRight(\n            start: number,\n            end?: number,\n            step?: number\n        ): number[];\n\n        /**\n         * This method is like _.range except that it populates values in\n         * descending order.\n         *\n         * @param start The start of the range.\n         * @param index Not used in this overload.\n         * @param guard Enables use as an iteratee for methods like _.map. You should not pass this parameter directly in your code.\n         * @return Returns a new range array.\n         */\n        rangeRight(\n            end: number,\n            index: string | number,\n            guard: object\n        ): number[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.rangeRight\n         */\n        rangeRight(\n            end?: number,\n            step?: number\n        ): LoDashImplicitWrapper<number[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.rangeRight\n         */\n        rangeRight(\n            end?: number,\n            step?: number\n        ): LoDashExplicitWrapper<number[]>;\n    }\n\n    //_.runInContext\n    interface LoDashStatic {\n        /**\n         * Create a new pristine lodash function using the given context object.\n         *\n         * @param context The context object.\n         * @return Returns a new lodash function.\n         */\n        runInContext(context?: object): typeof _;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.runInContext\n         */\n        runInContext(): typeof _;\n    }\n\n    // _.stubArray\n    interface LoDashStatic {\n        /**\n         * This method returns a new empty array.\n         *\n         * @returns Returns the new empty array.\n         */\n        stubArray(): any[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.stubArray\n         */\n        stubArray(): any[];\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.stubArray\n         */\n        stubArray(): LoDashExplicitWrapper<any[]>;\n    }\n\n    // _.stubFalse\n    interface LoDashStatic {\n        /**\n         * This method returns `false`.\n         *\n         * @returns Returns `false`.\n         */\n        stubFalse(): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.stubFalse\n         */\n        stubFalse(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.stubFalse\n         */\n        stubFalse(): LoDashExplicitWrapper<boolean>;\n    }\n\n    interface LoDashStatic {\n        /**\n         * This method returns a new empty object.\n         *\n         * @returns Returns the new empty object.\n         */\n        stubObject(): any;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.stubObject\n         */\n        stubObject(): any;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.stubObject\n         */\n        stubObject(): LoDashExplicitWrapper<any>;\n    }\n\n    interface LoDashStatic {\n        /**\n         * This method returns an empty string.\n         *\n         * @returns Returns the empty string.\n         */\n        stubString(): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.stubString\n         */\n        stubString(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.stubString\n         */\n        stubString(): LoDashExplicitWrapper<string>;\n    }\n\n    interface LoDashStatic {\n        /**\n         * This method returns `true`.\n         *\n         * @returns Returns `true`.\n         */\n        stubTrue(): boolean;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.stubTrue\n         */\n        stubTrue(): boolean;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.stubTrue\n         */\n        stubTrue(): LoDashExplicitWrapper<boolean>;\n    }\n\n    //_.times\n    interface LoDashStatic {\n        /**\n         * Invokes the iteratee function n times, returning an array of the results of each invocation. The iteratee\n         * is invoked with one argument; (index).\n         *\n         * @param n The number of times to invoke iteratee.\n         * @param iteratee The function invoked per iteration.\n         * @return Returns the array of results.\n         */\n        times<TResult>(\n            n: number,\n            iteratee: (num: number) => TResult\n        ): TResult[];\n\n        /**\n         * @see _.times\n         */\n        times(n: number): number[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.times\n         */\n        times<TResult>(\n            iteratee: (num: number) => TResult\n        ): TResult[];\n\n        /**\n         * @see _.times\n         */\n        times(): number[];\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.times\n         */\n        times<TResult>(\n            iteratee: (num: number) => TResult\n        ): LoDashExplicitWrapper<TResult[]>;\n\n        /**\n         * @see _.times\n         */\n        times(): LoDashExplicitWrapper<number[]>;\n    }\n\n    //_.toPath\n    interface LoDashStatic {\n        /**\n         * Converts `value` to a property path array.\n         *\n         * @category Util\n         * @param value The value to convert.\n         * @returns Returns the new property path array.\n         * @example\n         *\n         * _.toPath('a.b.c');\n         * // => ['a', 'b', 'c']\n         *\n         * _.toPath('a[0].b.c');\n         * // => ['a', '0', 'b', 'c']\n         *\n         * var path = ['a', 'b', 'c'],\n         *     newPath = _.toPath(path);\n         *\n         * console.log(newPath);\n         * // => ['a', 'b', 'c']\n         *\n         * console.log(path === newPath);\n         * // => false\n         */\n        toPath(value: any): string[];\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.toPath\n         */\n        toPath(): LoDashImplicitWrapper<string[]>;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.toPath\n         */\n        toPath(): LoDashExplicitWrapper<string[]>;\n    }\n\n    //_.uniqueId\n    interface LoDashStatic {\n        /**\n         * Generates a unique ID. If prefix is provided the ID is appended to it.\n         *\n         * @param prefix The value to prefix the ID with.\n         * @return Returns the unique ID.\n         */\n        uniqueId(prefix?: string): string;\n    }\n\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.uniqueId\n         */\n        uniqueId(): string;\n    }\n\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.uniqueId\n         */\n        uniqueId(): LoDashExplicitWrapper<string>;\n    }\n\n    type NotVoid = {} | null | undefined;\n    type ArrayIterator<T, TResult> = (value: T, index: number, collection: T[]) => TResult;\n    type ListIterator<T, TResult> = (value: T, index: number, collection: List<T>) => TResult;\n    type ListIteratee<T> = ListIterator<T, NotVoid> | string | [string, any] | PartialDeep<T>;\n    type ListIterateeCustom<T, TResult> = ListIterator<T, TResult> | string | object | [string, any] | PartialDeep<T>;\n    type ListIteratorTypeGuard<T, S extends T> = (value: T, index: number, collection: List<T>) => value is S;\n\n    // Note: key should be string, not keyof T, because the actual object may contain extra properties that were not specified in the type.\n    type ObjectIterator<TObject, TResult> = (value: TObject[keyof TObject], key: string, collection: TObject) => TResult;\n    type ObjectIteratee<TObject> = ObjectIterator<TObject, NotVoid> | string | [string, any] | PartialDeep<TObject[keyof TObject]>;\n    type ObjectIterateeCustom<TObject, TResult> = ObjectIterator<TObject, TResult> | string | object | [string, any] | PartialDeep<TObject[keyof TObject]>;\n    type ObjectIteratorTypeGuard<TObject, S extends TObject[keyof TObject]> = (value: TObject[keyof TObject], key: string, collection: TObject) => value is S;\n\n    type DictionaryIterator<T, TResult> = ObjectIterator<Dictionary<T>, TResult>;\n    type DictionaryIteratee<T> = ObjectIteratee<Dictionary<T>>;\n    type DictionaryIteratorTypeGuard<T, S extends T> = ObjectIteratorTypeGuard<Dictionary<T>, S>;\n\n    type NumericDictionaryIterator<T, TResult> = (value: T, key: number, collection: NumericDictionary<T>) => TResult;\n    type NumericDictionaryIteratee<T> = NumericDictionaryIterator<T, NotVoid> | string | [string, any] | PartialDeep<T>;\n    type NumericDictionaryIterateeCustom<T, TResult> = NumericDictionaryIterator<T, TResult> | string | [string, any] | PartialDeep<T>;\n\n    type StringIterator<TResult> = (char: string, index: number, string: string) => TResult;\n\n    type MemoVoidIterator<T, TResult> = (prev: TResult, curr: T, indexOrKey: any, list: T[]) => void;\n\n    /** @deprecated Use MemoListIterator or MemoObjectIterator instead.  */\n    type MemoIterator<T, TResult> = (prev: TResult, curr: T, indexOrKey: any, list: T[]) => TResult;\n    type MemoListIterator<T, TResult, TList> = (prev: TResult, curr: T, index: number, list: TList) => TResult;\n    type MemoObjectIterator<T, TResult, TList> = (prev: TResult, curr: T, key: string, list: TList) => TResult;\n\n    type MemoVoidArrayIterator<T, TResult> = (acc: TResult, curr: T, index: number, arr: T[]) => void;\n    type MemoVoidDictionaryIterator<T, TResult> = (acc: TResult, curr: T, key: string, dict: Dictionary<T>) => void;\n\n    type ValueIteratee<T> = ((value: T) => NotVoid) | string | [string, any] | PartialDeep<T>;\n    type ValueKeyIteratee<T> = ((value: T, key: string) => NotVoid) | string | [string, any] | PartialDeep<T>;\n    type Comparator<T> = (a: T, b: T) => boolean;\n    type Comparator2<T1, T2> = (a: T1, b: T2) => boolean;\n\n    type PropertyName = string | number | symbol;\n    type PropertyPath = Many<PropertyName>;\n\n    /** Common interface between Arrays and jQuery objects */\n    type List<T> = ArrayLike<T>;\n\n    interface Dictionary<T> {\n        [index: string]: T;\n    }\n\n    interface NumericDictionary<T> {\n        [index: number]: T;\n    }\n\n    interface Cancelable {\n        cancel(): void;\n        flush(): void;\n    }\n\n    type PartialDeep<T> = {\n        [P in keyof T]?: PartialDeep<T[P]>;\n    };\n\n    // For backwards compatibility\n    type LoDashImplicitArrayWrapper<T> = LoDashImplicitWrapper<T[]>;\n    type LoDashImplicitNillableArrayWrapper<T> = LoDashImplicitWrapper<T[] | null | undefined>;\n    type LoDashImplicitObjectWrapper<T> = LoDashImplicitWrapper<T>;\n    type LoDashImplicitNillableObjectWrapper<T> = LoDashImplicitWrapper<T | null | undefined>;\n    type LoDashImplicitNumberArrayWrapper = LoDashImplicitWrapper<number[]>;\n    type LoDashImplicitStringWrapper = LoDashImplicitWrapper<string>;\n    type LoDashExplicitArrayWrapper<T> = LoDashExplicitWrapper<T[]>;\n    type LoDashExplicitNillableArrayWrapper<T> = LoDashExplicitWrapper<T[] | null | undefined>;\n    type LoDashExplicitObjectWrapper<T> = LoDashExplicitWrapper<T>;\n    type LoDashExplicitNillableObjectWrapper<T> = LoDashExplicitWrapper<T | null | undefined>;\n    type LoDashExplicitNumberArrayWrapper = LoDashExplicitWrapper<number[]>;\n    type LoDashExplicitStringWrapper = LoDashExplicitWrapper<string>;\n}\n\n// Backward compatibility with --target es5\ndeclare global {\n    interface Set<T> { }\n    interface Map<K, V> { }\n    interface WeakSet<T> { }\n    interface WeakMap<K extends object, V> { }\n}\n"}}},"startX":0,"startY":0,"4705ce0d-bce9-4245-80d4-3ffc7f0621e6":{"id":"4705ce0d-bce9-4245-80d4-3ffc7f0621e6","parent":"4c694dd6-8dfe-4e5f-bdde-ea6e84f0e65a","name":"PJ-lambda.js","type":"LAMBDA_FILE","isDirectory":false,"children":[],"isRemovable":true,"filePath":"PJ/PJ-lambda.js","resources":{"ddb-test_table":{"name":"ddb-test_table","type":"DynamoDB","config":{"mode":1,"operation":"put","table":{"arn":"arn:aws:dynamodb:us-east-1:480964559519:table/test_table","name":"test_table","partitionKey":"id","partitionKeyType":"S","hasSortKey":false,"sortKey":"","sortKeyType":"S"},"parameters":{"Key":{},"Item":{"HI":"OKAY"}}}},"apig-iamapi-ruwan-listrole":{"name":"apig-iamapi-ruwan-listrole","type":"API_GATEWAY","config":{"apiMode":1,"apiName":"iamapi-ruwan","apiId":"cdqo4fbd05","endpointType":"EDGE","resourceMode":1,"resourcePath":"/listrole","resourceName":"listrole","resourceId":"ptww7c","restMethod":"GET"}}},"code":"const ddb = AWS.DynamoDB.DocumentClient();\nfunction handle(event, context, callback) {\n    ddb.put({\n        TableName: 'test_table',\n        Item: { HI: 'OKAY' }\n    }, function (err, data) {\n        if (err) {\n            //handle error\n        } else {\n            //your logic goes here\n        }\n    });\n\n}","ast":{"type":"File","start":0,"end":311,"loc":{"start":{"line":1,"column":0},"end":{"line":14,"column":1}},"program":{"type":"Program","start":0,"end":311,"loc":{"start":{"line":1,"column":0},"end":{"line":14,"column":1}},"sourceType":"module","body":[{"type":"VariableDeclaration","start":0,"end":42,"loc":{"start":{"line":1,"column":0},"end":{"line":1,"column":42}},"declarations":[{"type":"VariableDeclarator","start":6,"end":41,"loc":{"start":{"line":1,"column":6},"end":{"line":1,"column":41}},"id":{"type":"Identifier","start":6,"end":9,"loc":{"start":{"line":1,"column":6},"end":{"line":1,"column":9},"identifierName":"ddb"},"name":"ddb"},"init":{"type":"CallExpression","start":12,"end":41,"loc":{"start":{"line":1,"column":12},"end":{"line":1,"column":41}},"callee":{"type":"MemberExpression","start":12,"end":39,"loc":{"start":{"line":1,"column":12},"end":{"line":1,"column":39}},"object":{"type":"MemberExpression","start":12,"end":24,"loc":{"start":{"line":1,"column":12},"end":{"line":1,"column":24}},"object":{"type":"Identifier","start":12,"end":15,"loc":{"start":{"line":1,"column":12},"end":{"line":1,"column":15},"identifierName":"AWS"},"name":"AWS"},"property":{"type":"Identifier","start":16,"end":24,"loc":{"start":{"line":1,"column":16},"end":{"line":1,"column":24},"identifierName":"DynamoDB"},"name":"DynamoDB"},"computed":false},"property":{"type":"Identifier","start":25,"end":39,"loc":{"start":{"line":1,"column":25},"end":{"line":1,"column":39},"identifierName":"DocumentClient"},"name":"DocumentClient"},"computed":false},"arguments":[]}}],"kind":"const"},{"type":"FunctionDeclaration","start":43,"end":311,"loc":{"start":{"line":2,"column":0},"end":{"line":14,"column":1}},"id":{"type":"Identifier","start":52,"end":58,"loc":{"start":{"line":2,"column":9},"end":{"line":2,"column":15},"identifierName":"handle"},"name":"handle"},"generator":false,"async":false,"params":[{"type":"Identifier","start":59,"end":64,"loc":{"start":{"line":2,"column":16},"end":{"line":2,"column":21},"identifierName":"event"},"name":"event"},{"type":"Identifier","start":66,"end":73,"loc":{"start":{"line":2,"column":23},"end":{"line":2,"column":30},"identifierName":"context"},"name":"context"},{"type":"Identifier","start":75,"end":83,"loc":{"start":{"line":2,"column":32},"end":{"line":2,"column":40},"identifierName":"callback"},"name":"callback"}],"body":{"type":"BlockStatement","start":85,"end":311,"loc":{"start":{"line":2,"column":42},"end":{"line":14,"column":1}},"body":[{"type":"ExpressionStatement","start":91,"end":308,"loc":{"start":{"line":3,"column":4},"end":{"line":12,"column":7}},"expression":{"type":"CallExpression","start":91,"end":307,"loc":{"start":{"line":3,"column":4},"end":{"line":12,"column":6}},"callee":{"type":"MemberExpression","start":91,"end":98,"loc":{"start":{"line":3,"column":4},"end":{"line":3,"column":11}},"object":{"type":"Identifier","start":91,"end":94,"loc":{"start":{"line":3,"column":4},"end":{"line":3,"column":7},"identifierName":"ddb"},"name":"ddb"},"property":{"type":"Identifier","start":95,"end":98,"loc":{"start":{"line":3,"column":8},"end":{"line":3,"column":11},"identifierName":"put"},"name":"put"},"computed":false},"arguments":[{"type":"ObjectExpression","start":99,"end":168,"loc":{"start":{"line":3,"column":12},"end":{"line":6,"column":5}},"properties":[{"type":"ObjectProperty","start":109,"end":132,"loc":{"start":{"line":4,"column":8},"end":{"line":4,"column":31}},"method":false,"key":{"type":"Identifier","start":109,"end":118,"loc":{"start":{"line":4,"column":8},"end":{"line":4,"column":17},"identifierName":"TableName"},"name":"TableName"},"computed":false,"shorthand":false,"value":{"type":"StringLiteral","start":120,"end":132,"loc":{"start":{"line":4,"column":19},"end":{"line":4,"column":31}},"extra":{"rawValue":"test_table","raw":"'test_table'"},"value":"test_table"}},{"type":"ObjectProperty","start":142,"end":162,"loc":{"start":{"line":5,"column":8},"end":{"line":5,"column":28}},"method":false,"key":{"type":"Identifier","start":142,"end":146,"loc":{"start":{"line":5,"column":8},"end":{"line":5,"column":12},"identifierName":"Item"},"name":"Item"},"computed":false,"shorthand":false,"value":{"type":"ObjectExpression","start":148,"end":162,"loc":{"start":{"line":5,"column":14},"end":{"line":5,"column":28}},"properties":[{"type":"ObjectProperty","start":150,"end":160,"loc":{"start":{"line":5,"column":16},"end":{"line":5,"column":26}},"method":false,"key":{"type":"Identifier","start":150,"end":152,"loc":{"start":{"line":5,"column":16},"end":{"line":5,"column":18},"identifierName":"HI"},"name":"HI"},"computed":false,"shorthand":false,"value":{"type":"StringLiteral","start":154,"end":160,"loc":{"start":{"line":5,"column":20},"end":{"line":5,"column":26}},"extra":{"rawValue":"OKAY","raw":"'OKAY'"},"value":"OKAY"}}]}}]},{"type":"FunctionExpression","start":170,"end":306,"loc":{"start":{"line":6,"column":7},"end":{"line":12,"column":5}},"id":null,"generator":false,"async":false,"params":[{"type":"Identifier","start":180,"end":183,"loc":{"start":{"line":6,"column":17},"end":{"line":6,"column":20},"identifierName":"err"},"name":"err"},{"type":"Identifier","start":185,"end":189,"loc":{"start":{"line":6,"column":22},"end":{"line":6,"column":26},"identifierName":"data"},"name":"data"}],"body":{"type":"BlockStatement","start":191,"end":306,"loc":{"start":{"line":6,"column":28},"end":{"line":12,"column":5}},"body":[{"type":"IfStatement","start":201,"end":300,"loc":{"start":{"line":7,"column":8},"end":{"line":11,"column":9}},"test":{"type":"Identifier","start":205,"end":208,"loc":{"start":{"line":7,"column":12},"end":{"line":7,"column":15},"identifierName":"err"},"name":"err"},"consequent":{"type":"BlockStatement","start":210,"end":248,"loc":{"start":{"line":7,"column":17},"end":{"line":9,"column":9}},"body":[],"directives":[],"leadingComments":null,"innerComments":[{"type":"CommentLine","value":"handle error","start":224,"end":238,"loc":{"start":{"line":8,"column":12},"end":{"line":8,"column":26}}}]},"alternate":{"type":"BlockStatement","start":254,"end":300,"loc":{"start":{"line":9,"column":15},"end":{"line":11,"column":9}},"body":[],"directives":[],"leadingComments":[{"type":"CommentLine","value":"handle error","start":224,"end":238,"loc":{"start":{"line":8,"column":12},"end":{"line":8,"column":26}}}],"innerComments":[{"type":"CommentLine","value":"your logic goes here","start":268,"end":290,"loc":{"start":{"line":10,"column":12},"end":{"line":10,"column":34}}}]}}],"directives":[]},"trailingComments":[{"type":"CommentLine","value":"handle error","start":224,"end":238,"loc":{"start":{"line":8,"column":12},"end":{"line":8,"column":26}}},{"type":"CommentLine","value":"your logic goes here","start":268,"end":290,"loc":{"start":{"line":10,"column":12},"end":{"line":10,"column":34}}}]}]}}],"directives":[]}}],"directives":[]},"comments":[{"type":"CommentLine","value":"handle error","start":224,"end":238,"loc":{"start":{"line":8,"column":12},"end":{"line":8,"column":26}}},{"type":"CommentLine","value":"your logic goes here","start":268,"end":290,"loc":{"start":{"line":10,"column":12},"end":{"line":10,"column":34}}}]},"formatted":true,"triggers":["apig-iamapi-ruwan-listrole"]}},"RESOURCE_POPUP_STATE_NAME":{"scrollPosition":37,"visible":false,"isEditMode":false,"droppedY":null},"NOTIFICATION_BAR_STATE_NAME":{"ERROR":[{"type":"ERROR","shortMessage":"Error in deleting the change set undefined","description":{"message":"Missing required key 'ChangeSetName' in params","code":"MissingRequiredParameter","time":"2018-01-03T10:53:16.083Z"},"isProgress":false},{"type":"ERROR","shortMessage":"Error creating the change set 4705ce0dbce9424580d43ffc7f0621e6StackChangeSet1!","description":{"message":"2 validation errors detected: Value '4705ce0dbce9424580d43ffc7f0621e6Stack' at 'stackName' failed to satisfy constraint: Member must satisfy regular expression pattern: [a-zA-Z][-a-zA-Z0-9]*|arn:[-a-zA-Z0-9:/._+]*; Value '4705ce0dbce9424580d43ffc7f0621e6StackChangeSet1' at 'changeSetName' failed to satisfy constraint: Member must satisfy regular expression pattern: [a-zA-Z][-a-zA-Z0-9]*","code":"ValidationError","time":"2018-01-03T10:53:09.555Z","requestId":"495306e4-f074-11e7-9da2-bf40d2a90a8e","statusCode":400,"retryable":false,"retryDelay":19.71057542216206},"isProgress":false}],"WARN":[],"INFO":[{"type":"INFO","shortMessage":"Committing Changes...","description":"","isProgress":true},{"type":"INFO","shortMessage":"Build BuildProject-PJ:5c8e3be1-1304-4c15-a96c-30f0812bc0a7 was completed","description":"Build BuildProject-PJ:5c8e3be1-1304-4c15-a96c-30f0812bc0a7 was completed","isProgress":false},{"type":"INFO","shortMessage":"A build BuildProject-PJ:5c8e3be1-1304-4c15-a96c-30f0812bc0a7 was started","description":"A build BuildProject-PJ:5c8e3be1-1304-4c15-a96c-30f0812bc0a7 was started","isProgress":false},{"type":"INFO","shortMessage":"Successfully Committed Changes","description":"","isProgress":false},{"type":"INFO","shortMessage":"Committing Changes...","description":"","isProgress":true},{"type":"INFO","shortMessage":"Deployment cloud-formation generated for lambda 4705ce0d-bce9-4245-80d4-3ffc7f0621e6","description":"Deployment cloud-formation generated for lambda 4705ce0d-bce9-4245-80d4-3ffc7f0621e6","isProgress":false},{"type":"INFO","shortMessage":"Build BuildProject-PJ:aea99d6f-ff9c-40bd-85e4-ad1380e8d5a4 was completed","description":"Build BuildProject-PJ:aea99d6f-ff9c-40bd-85e4-ad1380e8d5a4 was completed","isProgress":false},{"type":"INFO","shortMessage":"A build BuildProject-PJ:aea99d6f-ff9c-40bd-85e4-ad1380e8d5a4 was started","description":"A build BuildProject-PJ:aea99d6f-ff9c-40bd-85e4-ad1380e8d5a4 was started","isProgress":false},{"type":"INFO","shortMessage":"Project BuildProject-PJ created for project PJ","description":"Project BuildProject-PJ created for project PJ","isProgress":false},{"type":"INFO","shortMessage":"Successfully Committed Changes","description":"","isProgress":false},{"type":"INFO","shortMessage":"Committing Changes...","description":"","isProgress":true}],"DEBUG":[{"type":"DEBUG","shortMessage":"Completed trigger permissions generation for lambda 4705ce0d-bce9-4245-80d4-3ffc7f0621e6","description":"Completed trigger permissions generation for lambda 4705ce0d-bce9-4245-80d4-3ffc7f0621e6","isProgress":false},{"type":"DEBUG","shortMessage":"Completed execution role generation for lambda 4705ce0d-bce9-4245-80d4-3ffc7f0621e6","description":"Completed execution role generation for lambda 4705ce0d-bce9-4245-80d4-3ffc7f0621e6","isProgress":false},{"type":"DEBUG","shortMessage":"Completed CF definition generation for lambda 4705ce0d-bce9-4245-80d4-3ffc7f0621e6","description":"Completed CF definition generation for lambda 4705ce0d-bce9-4245-80d4-3ffc7f0621e6","isProgress":false}],"latest":{"type":"INFO","shortMessage":"Committing Changes...","description":"","isProgress":true},"notificationType":11},"DEPLOYMENT_STATE_NAME":{},"BUILD_STATE_NAME":{"PJ":{"name":"BuildProject-PJ","role":"arn:aws:iam::480964559519:role/new-idea-code-build-role","bucket":"new-idea-codebuild-artifacts","repository":"https://github.com/sigmaidetest/PJ.git","builds":{"BuildProject-PJ:aea99d6f-ff9c-40bd-85e4-ad1380e8d5a4":{"complete":true,"status":"SUCCEEDED","log":"https://console.aws.amazon.com/cloudwatch/home?region=us-east-1#logEvent:group=/aws/codebuild/BuildProject-PJ;stream=aea99d6f-ff9c-40bd-85e4-ad1380e8d5a4","startTime":"2018-01-03T10:50:32.957Z","endTime":"2018-01-03T10:51:02.844Z","artifact":"arn:aws:s3:::new-idea-codebuild-artifacts/BuildProject-PJ-Artifacts/aea99d6f-ff9c-40bd-85e4-ad1380e8d5a4/BuildProject-PJ.zip","phases":{"phaseType":"SUBMITTED","phaseStatus":"SUCCEEDED","startTime":"2018-01-03T10:50:32.957Z","endTime":"2018-01-03T10:50:33.357Z","durationInSeconds":0,"PROVISIONING":{"status":"SUCCEEDED","duration":22},"DOWNLOAD_SOURCE":{"status":"SUCCEEDED","duration":3},"INSTALL":{"status":"SUCCEEDED","duration":0},"PRE_BUILD":{"status":"SUCCEEDED","duration":0},"BUILD":{"status":"SUCCEEDED","duration":0},"POST_BUILD":{"status":"SUCCEEDED","duration":0},"UPLOAD_ARTIFACTS":{"status":"SUCCEEDED","duration":1},"FINALIZING":{"status":"SUCCEEDED","duration":2},"COMPLETED":{}}},"BuildProject-PJ:5c8e3be1-1304-4c15-a96c-30f0812bc0a7":{"complete":true,"status":"SUCCEEDED","log":"https://console.aws.amazon.com/cloudwatch/home?region=us-east-1#logEvent:group=/aws/codebuild/BuildProject-PJ;stream=5c8e3be1-1304-4c15-a96c-30f0812bc0a7","startTime":"2018-01-03T10:56:10.228Z","endTime":"2018-01-03T10:56:23.217Z","artifact":"arn:aws:s3:::new-idea-codebuild-artifacts/BuildProject-PJ-Artifacts/5c8e3be1-1304-4c15-a96c-30f0812bc0a7/BuildProject-PJ.zip","phases":{"phaseType":"SUBMITTED","phaseStatus":"SUCCEEDED","startTime":"2018-01-03T10:56:10.228Z","endTime":"2018-01-03T10:56:10.581Z","durationInSeconds":0,"PROVISIONING":{"status":"SUCCEEDED","duration":6},"DOWNLOAD_SOURCE":{"status":"SUCCEEDED","duration":1},"INSTALL":{"status":"SUCCEEDED","duration":0},"PRE_BUILD":{"status":"SUCCEEDED","duration":0},"BUILD":{"status":"SUCCEEDED","duration":0},"POST_BUILD":{"status":"SUCCEEDED","duration":0},"UPLOAD_ARTIFACTS":{"status":"SUCCEEDED","duration":1},"FINALIZING":{"status":"SUCCEEDED","duration":3},"COMPLETED":{}}}},"latest":"BuildProject-PJ:5c8e3be1-1304-4c15-a96c-30f0812bc0a7"}},"PROJECT_META_STATE_NAME":{"projectName":"PJ","projectDescription":"DESC","projectVersion":"1.0"}}